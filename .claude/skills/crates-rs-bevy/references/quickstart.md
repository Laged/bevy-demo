# Crates-Rs-Bevy - Quickstart

**Pages:** 883

---

## Struct Cone Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Cone.html

**Contents:**
- Struct Cone Copy item path
- Fields§
- Implementations§
  - impl Cone
    - pub const fn new(radius: f32, height: f32) -> Cone
      - Examples found in repository?
    - pub const fn base(&self) -> Circle
    - pub fn slant_height(&self) -> f32
    - pub fn lateral_area(&self) -> f32
    - pub fn base_area(&self) -> f32

A cone primitive centered on the midpoint between the tip of the cone and the center of its base.

The cone is oriented with its tip pointing towards the Y axis.

The radius of the base

The height of the cone

Create a new Cone from a radius and height.

Get the base of the cone as a Circle

Get the slant height of the cone, the length of the line segment connecting a point on the base to the apex

Get the surface area of the side of the cone, also known as the lateral area

Get the surface area of the base of the cone

Returns the default Cone with a base radius of 0.5 and a height of 1.0.

Get the total surface area of the cone

Get the volume of the cone

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Cone {
    pub radius: f32,
    pub height: f32,
}
```

Example 2 (javascript):
```javascript
357fn draw_gizmos(mut gizmos: Gizmos, spotlight: Query<(&GlobalTransform, &SpotLight, &Visibility)>) {
358    if let Ok((global_transform, spotlight, visibility)) = spotlight.single()
359        && visibility != Visibility::Hidden
360    {
361        gizmos.primitive_3d(
362            &Cone::new(7.0 * spotlight.outer_angle, 7.0),
363            Isometry3d {
364                rotation: global_transform.rotation() * Quat::from_rotation_x(FRAC_PI_2),
365                translation: global_transform.translation_vec3a() * 0.5,
366            },
367            YELLOW,
368        );
369    }
370}
```

---

## Struct QuinticInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuinticInOutCurve.html

**Contents:**
- Struct QuinticInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for QuinticInOutCurve
    - fn clone(&self) -> QuinticInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuinticInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as QuinticIn for t < 0.5 and as QuinticOut for t >= 0.5

Due to this piecewise definition, this is only C¹ despite being a quintic: the acceleration jumps from +40 to -40 at t = ½.

Consider using SmootherStepCurve instead, which is also quintic.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuinticInOutCurve;
```

---

## Struct EntityRef Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EntityRef.html

**Contents:**
- Struct EntityRef Copy item path
- §Examples
- Implementations§
  - impl<'w> EntityRef<'w>
    - pub fn id(&self) -> Entity
    - pub fn location(&self) -> EntityLocation
    - pub fn archetype(&self) -> &Archetype
    - pub fn contains<T>(&self) -> boolwhere T: Component,
        - §Notes
    - pub fn contains_id(&self, component_id: ComponentId) -> bool

A read-only reference to a particular Entity and all of its components.

Read-only access disjoint with mutable access.

Returns the ID of the current entity.

Gets metadata indicating the location where the current entity is stored.

Returns the archetype that the current entity belongs to.

Returns true if the current entity has a component of type T. Otherwise, this returns false.

If you do not know the concrete type of a component, consider using Self::contains_id or Self::contains_type_id.

Returns true if the current entity has a component identified by component_id. Otherwise, this returns false.

Returns true if the current entity has a component with the type identified by type_id. Otherwise, this returns false.

Gets access to the component of type T for the current entity. Returns None if the entity does not have a component of type T.

Gets access to the component of type T for the current entity, including change detection information as a Ref.

Returns None if the entity does not have a component of type T.

Retrieves the change ticks for the given component. This can be useful for implementing change detection in custom runtimes.

Retrieves the change ticks for the given ComponentId. This can be useful for implementing change detection in custom runtimes.

You should prefer to use the typed API EntityRef::get_change_ticks where possible and only use this in cases where the actual component types are not known at compile time.

Returns untyped read-only reference(s) to component(s) for the current entity, based on the given ComponentIds.

You should prefer to use the typed API EntityRef::get where possible and only use this in cases where the actual component types are not known at compile time.

Unlike EntityRef::get, this returns untyped reference(s) to component(s), and it’s the job of the caller to ensure the correct type(s) are dereferenced (if necessary).

Returns EntityComponentError::MissingComponent if the entity does not have a component.

Returns read-only components for the current entity that match the query Q.

If the entity does not have the components required by the query Q.

Returns read-only components for the current entity that match the query Q, or None if the entity does not have the components required by the query Q.

Returns the source code location from which this entity has been spawned.

Returns the Tick at which this entity has been spawned.

EntityRef’s comparison trait implementations match the underlying Enti

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct EntityRef<'w> { /* private fields */ }
```

Example 2 (unknown):
```unknown
fn disjoint_system(
    query1: Query<&mut A>,
    query2: Query<EntityRef, Without<A>>,
) {
    // ...
}
```

Example 3 (javascript):
```javascript
77fn on_insert_name(mut world: DeferredWorld<'_>, HookContext { entity, .. }: HookContext) {
78    let Some(&name) = world.entity(entity).get::<Name>() else {
79        unreachable!("Insert hook guarantees `Name` is available on entity")
80    };
81    let Some(mut index) = world.get_resource_mut::<NameIndex>() else {
82        return;
83    };
84
85    index.name_to_entity.insert(name, entity);
86}
87
88/// When a [`Name`] is removed or replaced, remove it from our [`NameIndex`].
89///
90/// Since all mutations to [`Name`] are captured by hooks, we know it is currently
91/// inserted in the i
...
```

Example 4 (javascript):
```javascript
let entity = world.spawn(Foo(42)).id();

// Grab the component ID for `Foo` in whatever way you like.
let component_id = world.register_component::<Foo>();

// Then, get the component by ID.
let ptr = world.entity(entity).get_by_id(component_id);
```

---

## Struct AudioSource Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AudioSource.html

**Contents:**
- Struct AudioSource Copy item path
- Fields§
- Trait Implementations§
  - impl AsRef<[u8]> for AudioSource
    - fn as_ref(&self) -> &[u8] ⓘ
  - impl Clone for AudioSource
    - fn clone(&self) -> AudioSource
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for AudioSource
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

A source of audio data

Raw data of the audio source.

The data must be one of the file formats supported by Bevy (wav, ogg, flac, or mp3). However, support for these file formats is not part of Bevy’s default feature set. In order to be able to use these file formats, you will have to enable the appropriate optional features.

It is decoded using rodio::decoder::Decoder. The decoder has conditionally compiled methods depending on the features enabled. If the format used is not enabled, then this will panic with an UnrecognizedFormat error.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AudioSource {
    pub bytes: Arc<[u8]>,
}
```

---

## Module ops Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/ops/index.html

**Contents:**
- Module ops Copy item path
- Traits§
- Functions§

This mod re-exports the correct versions of floating-point operations with unspecified precision in the standard library depending on whether the libm crate feature is enabled.

All the functions here are named according to their versions in the standard library.

It also provides no_std compatible alternatives to certain floating-point operations which are not provided in the core library.

---

## Enum RayCastVisibility Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.RayCastVisibility.html

**Contents:**
- Enum RayCastVisibility Copy item path
- Variants§
  - Any
  - Visible
  - VisibleInView
- Trait Implementations§
  - impl Clone for RayCastVisibility
    - fn clone(&self) -> RayCastVisibility
    - fn clone_from(&mut self, source: &Self)
  - impl Enum for RayCastVisibility

How a ray cast should handle Visibility.

Completely ignore visibility checks. Hidden items can still be ray cast against.

Only cast rays against entities that are visible in the hierarchy. See Visibility.

Only cast rays against entities that are visible in the hierarchy and visible to a camera or light. See Visibility.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum RayCastVisibility {
    Any,
    Visible,
    VisibleInView,
}
```

---

## Struct LightProbe Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LightProbe.html

**Contents:**
- Struct LightProbe Copy item path
- Implementations§
  - impl LightProbe
    - pub fn new() -> LightProbe
- Trait Implementations§
  - impl Clone for LightProbe
    - fn clone(&self) -> LightProbe
    - fn clone_from(&mut self, source: &Self)
  - impl Component for LightProbewhere LightProbe: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table

A marker component for a light probe, which is a cuboid region that provides global illumination to all fragments inside it.

Note that a light probe will have no effect unless the entity contains some kind of illumination, which can either be an EnvironmentMapLight or an IrradianceVolume.

The light probe range is conceptually a unit cube (1×1×1) centered on the origin. The Transform applied to this entity can scale, rotate, or translate that cube so that it contains all fragments that should take this light probe into account.

When multiple sources of indirect illumination can be applied to a fragment, the highest-quality one is chosen. Diffuse and specular illumination are considered separately, so, for example, Bevy may decide to sample the diffuse illumination from an irradiance volume and the specular illumination from a reflection probe. From highest priority to lowest priority, the ranking is as follows:

Note that ambient light is always added to the diffuse component and does not participate in the ranking. That is, ambient light is applied in addition to, not instead of, the light sources above.

A terminology note: Unfortunately, there is little agreement across game and graphics engines as to what to call the various techniques that Bevy groups under the term light probe. In Bevy, a light probe is the generic term that encompasses both reflection probes and irradiance volumes. In object-oriented terms, light probe is the superclass, and reflection probe and irradiance volume are subclasses. In other engines, you may see the term light probe refer to an irradiance volume with a single voxel, or perhaps some other technique, while in Bevy light probe refers not to a specific technique but rather to a class of techniques. Developers familiar with other engines should be aware of this terminology difference.

Creates a new light probe component.

Required Components: Transform, Visibility.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LightProbe;
```

---

## Struct Polyline2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Polyline2d.html

**Contents:**
- Struct Polyline2d Copy item path
- Fields§
- Implementations§
  - impl Polyline2d
    - pub fn new(vertices: impl IntoIterator<Item = Vec2>) -> Polyline2d
      - Examples found in repository?
    - pub fn with_subdivisions( start: Vec2, end: Vec2, subdivisions: usize, ) -> Polyline2d
- Trait Implementations§
  - impl Bounded2d for Polyline2d
    - fn aabb_2d(&self, isometry: impl Into<Isometry2d>) -> Aabb2d

A series of connected line segments in 2D space.

The vertices of the polyline

Create a new Polyline2d from its vertices

Create a new Polyline2d from two endpoints with subdivision points. subdivisions = 0 creates a simple line with just start and end points. subdivisions = 1 adds one point in the middle, creating 2 segments, etc.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Polyline2d {
    pub vertices: Vec<Vec2>,
}
```

Example 2 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

---

## Struct Lcha Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Lcha.html

**Contents:**
- Struct Lcha Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Lcha
    - pub const fn new(lightness: f32, chroma: f32, hue: f32, alpha: f32) -> Lcha
      - §Arguments
    - pub const fn lch(lightness: f32, chroma: f32, hue: f32) -> Lcha
      - §Arguments
    - pub const fn with_chroma(self, chroma: f32) -> Lcha

Color in LCH color space, with alpha

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The lightness channel. [0.0, 1.5]

The chroma channel. [0.0, 1.5]

The hue channel. [0.0, 360.0]

The alpha channel. [0.0, 1.0]

Construct a new Lcha color from components.

Construct a new Lcha color from (h, s, l) components, with the default alpha (1.0).

Return a copy of this color with the chroma channel set to the given value.

Return a copy of this color with the lightness channel set to the given value.

Generate a deterministic but quasi-randomly distributed color from a provided index.

This can be helpful for generating debug colors.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Lcha {
    pub lightness: f32,
    pub chroma: f32,
    pub hue: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

Example 3 (javascript):
```javascript
// Unique color for an entity
// let entity_index = entity.index();
let color = Lcha::sequential_dispersed(entity_index);

// Palette with 5 distinct hues
let palette = (0..5).map(Lcha::sequential_dispersed).collect::<Vec<_>>();
```

---

## Struct Commands Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Commands.html

**Contents:**
- Struct Commands Copy item path
- §Usage
- §Implementing
- §Error handling
- Implementations§
  - impl<'w, 's> Commands<'w, 's>
    - pub fn new(queue: &'s mut CommandQueue, world: &'w World) -> Commands<'w, 's>
    - pub fn new_from_entities( queue: &'s mut CommandQueue, entities: &'w Entities, ) -> Commands<'w, 's>
    - pub fn reborrow(&mut self) -> Commands<'w, '_>
      - §Example

A Command queue to perform structural changes to the World.

Since each command requires exclusive access to the World, all queued commands are automatically applied in sequence when the ApplyDeferred system runs (see ApplyDeferred documentation for more details).

Each command can be used to modify the World in arbitrary ways:

For a version of Commands that works in parallel contexts (such as within Query::par_iter) see ParallelCommands

Add mut commands: Commands as a function argument to your system to get a copy of this struct that will be applied the next time a copy of ApplyDeferred runs. Commands are almost always used as a SystemParam.

Each built-in command is implemented as a separate method, e.g. Commands::spawn. In addition to the pre-defined command methods, you can add commands with any arbitrary behavior using Commands::queue, which accepts any type implementing Command.

Since closures and other functions implement this trait automatically, this allows one-shot, anonymous custom commands.

A Command can return a Result, which will be passed to an error handler if the Result is an error.

The default error handler panics. It can be configured via the DefaultErrorHandler resource.

Alternatively, you can customize the error handler for a specific command by calling Commands::queue_handled.

The error module provides some simple error handlers for convenience.

Returns a new Commands instance from a CommandQueue and a World.

Returns a new Commands instance from a CommandQueue and an Entities reference.

Returns a Commands with a smaller lifetime.

This is useful if you have &mut Commands but need Commands.

Take all commands from other and append them to self, leaving other empty.

Spawns a new empty Entity and returns its corresponding EntityCommands.

Spawns a new Entity with the given components and returns the entity’s corresponding EntityCommands.

To spawn many entities with the same combination of components, spawn_batch can be used for better performance.

Returns the EntityCommands for the given Entity.

This method does not guarantee that commands queued by the returned EntityCommands will be successful, since the entity could be despawned before they are executed.

Returns the EntityCommands for the requested Entity if it exists.

This method does not guarantee that commands queued by the returned EntityCommands will be successful, since the entity could be despawned before they are executed.

Returns EntityDoesNotExistError if th

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Commands<'w, 's> { /* private fields */ }
```

Example 2 (unknown):
```unknown
fn my_system(mut commands: Commands) {
   // ...
}
```

Example 3 (unknown):
```unknown
// NOTE: type inference fails here, so annotations are required on the closure.
commands.queue(|w: &mut World| {
    // Mutate the world however you want...
});
```

Example 4 (unknown):
```unknown
fn my_system(mut commands: Commands) {
    // We do our initialization in a separate function,
    // which expects an owned `Commands`.
    do_initialization(commands.reborrow());

    // Since we only reborrowed the commands instead of moving them, we can still use them.
    commands.spawn_empty();
}
```

---

## Struct FilteredResources Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FilteredResources.html

**Contents:**
- Struct FilteredResources Copy item path
- §Examples
- Implementations§
  - impl<'w, 's> FilteredResources<'w, 's>
    - pub fn access(&self) -> &Access
    - pub fn has_read<R>(&self) -> boolwhere R: Resource,
    - pub fn get<R>(&self) -> Result<Ref<'w, R>, ResourceFetchError>where R: Resource,
    - pub fn get_by_id( &self, component_id: ComponentId, ) -> Result<Ptr<'w>, ResourceFetchError>
- Trait Implementations§
  - impl<'w, 's> Clone for FilteredResources<'w, 's>

Provides read-only access to a set of Resources defined by the contained Access.

Use FilteredResourcesMut if you need mutable access to some resources.

To be useful as a SystemParam, this must be configured using a FilteredResourcesParamBuilder to build the system using a SystemParamBuilder.

This can be used alongside ordinary Res and ResMut parameters if they do not conflict.

But it will conflict if it tries to read the same resource that another parameter writes.

Returns a reference to the underlying Access.

Returns true if the FilteredResources has access to the given resource. Note that Self::get() may still return Err if the resource does not exist.

Gets a reference to the resource of the given type if it exists and the FilteredResources has access to it.

Gets a pointer to the resource with the given ComponentId if it exists and the FilteredResources has access to it.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FilteredResources<'w, 's> { /* private fields */ }
```

Example 2 (javascript):
```javascript
// Use `FilteredResourcesParamBuilder` to declare access to resources.
let system = (FilteredResourcesParamBuilder::new(|builder| {
    builder.add_read::<B>().add_read::<C>();
}),)
    .build_state(&mut world)
    .build_system(resource_system);

world.init_resource::<A>();
world.init_resource::<C>();

fn resource_system(res: FilteredResources) {
    // The resource exists, but we have no access, so we can't read it.
    assert!(res.get::<A>().is_err());
    // The resource doesn't exist, so we can't read it.
    assert!(res.get::<B>().is_err());
    // The resource exists and we have access,
...
```

Example 3 (javascript):
```javascript
let system = (
    FilteredResourcesParamBuilder::new(|builder| {
        builder.add_read::<A>();
    }),
    ParamBuilder,
    ParamBuilder,
)
    .build_state(&mut world)
    .build_system(resource_system);

// Read access to A does not conflict with read access to A or write access to B.
fn resource_system(filtered: FilteredResources, res_a: Res<A>, res_mut_b: ResMut<B>) {
    let res_a_2: Ref<A> = filtered.get::<A>().unwrap();
}
```

Example 4 (javascript):
```javascript
let system = (
    FilteredResourcesParamBuilder::new(|builder| {
        builder.add_read::<A>();
    }),
    ParamBuilder,
)
    .build_state(&mut world)
    .build_system(invalid_resource_system);

// Read access to A conflicts with write access to A.
fn invalid_resource_system(filtered: FilteredResources, res_mut_a: ResMut<A>) { }
```

---

## Struct UVec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UVec2.html

**Contents:**
- Struct UVec2 Copy item path
- Fields§
- Implementations§
  - impl UVec2
    - pub const ZERO: UVec2
    - pub const ONE: UVec2
    - pub const MIN: UVec2
    - pub const MAX: UVec2
    - pub const X: UVec2
    - pub const Y: UVec2

A 2-dimensional vector.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y]

Creates a vector from the first 2 values in slice.

Panics if slice is less than 2 elements long.

Writes the elements of self to the first 2 elements in slice.

Panics if slice is less than 2 elements long.

Creates a 3D vector from self and the given z value.

Creates a 2D vector from self with the given value of x.

Creates a 2D vector from self with the given value of y.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

Component-wise clamping of values, similar to u32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

Returns the index of the first minimum element of self.

Returns the index of the first maximum element of self.

Returns the sum of all elements of self.

In other words, this computes self.x + self.y + ...

Returns the product of all elements of self.

In other words, this computes self.x * self.y * ...

Returns a vector mask containing the result of a == comparison for each element of self and rhs.

In other words, this computes [self.x == rhs.x, self.y == rhs.y, ..] for all elements.

Returns a vector mask containing the result of a != comparison for each element of self and rhs.

In other words this computes [self.x != rhs.x, self.y != rhs.y, ..] for all elements.

Returns a vector mask containing the result of a >= comparison for

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct UVec2 {
    pub x: u32,
    pub y: u32,
}
```

Example 2 (javascript):
```javascript
29const SIZE: UVec2 = UVec2::new(1280 / DISPLAY_FACTOR, 720 / DISPLAY_FACTOR);
```

Example 3 (javascript):
```javascript
195    const SECTIONS: [Option<URect>; 5] = [
196        Some(URect {
197            min: UVec2::ZERO,
198            max: UVec2::splat(RECT_SIZE),
199        }),
200        Some(URect {
201            min: UVec2::new(RECT_SIZE, 0),
202            max: UVec2::new(2 * RECT_SIZE, RECT_SIZE),
203        }),
204        Some(URect {
205            min: UVec2::new(0, RECT_SIZE),
206            max: UVec2::new(RECT_SIZE, 2 * RECT_SIZE),
207        }),
208        Some(URect {
209            min: UVec2::new(RECT_SIZE, RECT_SIZE),
210            max: UVec2::splat(2 * RECT_SIZE),
211        }),
212      
...
```

Example 4 (javascript):
```javascript
65fn spawn_fake_player(
66    mut commands: Commands,
67    mut meshes: ResMut<Assets<Mesh>>,
68    mut materials: ResMut<Assets<ColorMaterial>>,
69    chunk: Single<&TilemapChunk>,
70) {
71    let mut transform = chunk.calculate_tile_transform(UVec2::new(0, 0));
72    transform.translation.z = 1.;
73
74    commands.spawn((
75        Mesh2d(meshes.add(Rectangle::new(8., 8.))),
76        MeshMaterial2d(materials.add(Color::from(RED_400))),
77        transform,
78        MovePlayer,
79    ));
80
81    let mut transform = chunk.calculate_tile_transform(UVec2::new(5, 6));
82    transform.translati
...
```

---

## Trait Message Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Message.html

**Contents:**
- Trait Message Copy item path
- §Usage
- Implementors§
  - impl Message for GamepadEventwhere GamepadEvent: Send + Sync + 'static,
  - impl Message for GamepadRumbleRequestwhere GamepadRumbleRequest: Send + Sync + 'static,
  - impl Message for RawGamepadEventwhere RawGamepadEvent: Send + Sync + 'static,
  - impl Message for AppLifecyclewhere AppLifecycle: Send + Sync + 'static,
  - impl Message for WindowEventwhere WindowEvent: Send + Sync + 'static,
  - impl Message for AppExitwhere AppExit: Send + Sync + 'static,
  - impl Message for FileDragAndDropwhere FileDragAndDrop: Send + Sync + 'static,

A buffered message for pull-based event handling.

Messages can be written with MessageWriter and read using the MessageReader system parameter. Messages are stored in the Messages<M> resource, and require periodically polling the world for new messages, typically in a system that runs as part of a schedule.

While the polling imposes a small overhead, messages are useful for efficiently batch processing a large number of messages at once. For cases like these, messages can be more efficient than Events (which are handled via Observers).

Unlike Events triggered for observers, messages are evaluated at fixed points in the schedule rather than immediately when they are sent. This allows for more predictable scheduling, and deferring message processing to a later point in time.

Messages must be thread-safe.

The Message trait can be derived:

The message can then be written to the message buffer using a MessageWriter:

Messages can be efficiently read using a MessageReader:

**Examples:**

Example 1 (unknown):
```unknown
pub trait Message:
    Send
    + Sync
    + 'static { }
```

Example 2 (unknown):
```unknown
#[derive(Message)]
struct Greeting(String);
```

Example 3 (unknown):
```unknown
fn write_hello(mut writer: MessageWriter<Greeting>) {
    writer.write(Greeting("Hello!".to_string()));
}
```

Example 4 (unknown):
```unknown
fn read_messages(mut reader: MessageReader<Greeting>) {
    // Process all messages of type `Greeting`.
    for Greeting(greeting) in reader.read() {
        println!("{greeting}");
    }
}
```

---

## Struct DefaultPickingPlugins Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DefaultPickingPlugins.html

**Contents:**
- Struct DefaultPickingPlugins Copy item path
- Trait Implementations§
  - impl Default for DefaultPickingPlugins
    - fn default() -> DefaultPickingPlugins
  - impl PluginGroup for DefaultPickingPlugins
    - fn build(self) -> PluginGroupBuilder
    - fn name() -> String
    - fn set<T>(self, plugin: T) -> PluginGroupBuilderwhere T: Plugin,
- Auto Trait Implementations§
  - impl Freeze for DefaultPickingPlugins

One plugin that contains the PointerInputPlugin, PickingPlugin and the InteractionPlugin, this is probably the plugin that will be most used.

Note: for any of these plugins to work, they require a picking backend to be active, The picking backend is responsible to turn an input, into a PointerHits that PickingPlugin and InteractionPlugin will refine into bevy_ecs::observer::Ons.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DefaultPickingPlugins;
```

---

## Macro trace_span Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.trace_span.html

**Contents:**
- Macro trace_span Copy item path
- §Examples

Constructs a span at the trace level.

Fields and attributes are set using the same syntax as the span! macro.

See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! trace_span {
    (target: $target:expr, parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, parent: $parent:expr, $name:expr) => { ... };
    (parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (parent: $parent:expr, $name:expr) => { ... };
    (target: $target:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, $name:expr) => { ... };
    ($name:expr, $($field:tt)*) => { ... };
    ($name:expr) => { ... };
}
```

Example 2 (unknown):
```unknown
trace_span!("my_span");
// is equivalent to:
span!(Level::TRACE, "my_span");
```

Example 3 (javascript):
```javascript
let span = trace_span!("my span");
span.in_scope(|| {
    // do work inside the span...
});
```

---

## Struct DirectionalLight Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DirectionalLight.html

**Contents:**
- Struct DirectionalLight Copy item path
  - §Shadows
- Fields§
- Implementations§
  - impl DirectionalLight
    - pub const DEFAULT_SHADOW_DEPTH_BIAS: f32 = 0.0199999996f32
    - pub const DEFAULT_SHADOW_NORMAL_BIAS: f32 = 1.79999995f32
- Trait Implementations§
  - impl Clone for DirectionalLight
    - fn clone(&self) -> DirectionalLight

Directional lights don’t exist in reality but they are a good approximation for light sources VERY far away, like the sun or the moon.

The light shines along the forward direction of the entity’s transform. With a default transform this would be along the negative-Z axis.

Valid values for illuminance are:

To enable shadows, set the shadows_enabled property to true.

Shadows are produced via cascaded shadow maps.

To modify the cascade setup, such as the number of cascades or the maximum shadow distance, change the CascadeShadowConfig component of the entity with the DirectionalLight.

To control the resolution of the shadow maps, use the DirectionalLightShadowMap resource.

The color of the light.

By default, this is white.

Illuminance in lux (lumens per square meter), representing the amount of light projected onto surfaces by this light source. Lux is used here instead of lumens because a directional light illuminates all surfaces more-or-less the same way (depending on the angle of incidence). Lumens can only be specified for light sources which emit light from a specific area.

Whether this light casts shadows.

Note that shadows are rather expensive and become more so with every light that casts them. In general, it’s best to aggressively limit the number of lights with shadows enabled to one or two at most.

Whether soft shadows are enabled, and if so, the size of the light.

Soft shadows, also known as percentage-closer soft shadows or PCSS, cause shadows to become blurrier (i.e. their penumbra increases in radius) as they extend away from objects. The blurriness of the shadow depends on the size of the light; larger lights result in larger penumbras and therefore blurrier shadows.

Currently, soft shadows are rather noisy if not using the temporal mode. If you enable soft shadows, consider choosing ShadowFilteringMethod::Temporal and enabling temporal antialiasing (TAA) to smooth the noise out over time.

Note that soft shadows are significantly more expensive to render than hard shadows.

Whether this directional light contributes diffuse lighting to meshes with lightmaps.

Set this to false if your lightmap baking tool bakes the direct diffuse light from this directional light into the lightmaps in order to avoid counting the radiance from this light twice. Note that the specular portion of the light is always considered, because Bevy currently has no means to bake specular light.

By default, this is set to true.

A value that adjusts the t

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct DirectionalLight {
    pub color: Color,
    pub illuminance: f32,
    pub shadows_enabled: bool,
    pub soft_shadow_size: Option<f32>,
    pub affects_lightmapped_mesh_diffuse: bool,
    pub shadow_depth_bias: f32,
    pub shadow_normal_bias: f32,
}
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/color/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct ReflectComponent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectComponent.html

**Contents:**
- Struct ReflectComponent Copy item path
- Implementations§
  - impl ReflectComponent
    - pub fn insert( &self, entity: &mut EntityWorldMut<'_>, component: &(dyn PartialReflect + 'static), registry: &TypeRegistry, )
    - pub fn apply<'a>( &self, entity: impl Into<EntityMut<'a>>, component: &(dyn PartialReflect + 'static), )
      - §Panics
    - pub fn apply_or_insert_mapped( &self, entity: &mut EntityWorldMut<'_>, component: &(dyn PartialReflect + 'static), registry: &TypeRegistry, map: &mut dyn EntityMapper, relationship_hook_mode: RelationshipHookMode, )
      - §Panics
    - pub fn remove(&self, entity: &mut EntityWorldMut<'_>)
    - pub fn contains<'w, 's>( &self, entity: impl Into<FilteredEntityRef<'w, 's>>, ) -> bool

A struct used to operate on reflected Component trait of a type.

A ReflectComponent for type T can be obtained via bevy_reflect::TypeRegistration::data.

Insert a reflected Component into the entity like insert().

Uses reflection to set the value of this Component type in the entity to the given value.

Panics if there is no Component of the given type.

Will also panic if Component is immutable.

Uses reflection to set the value of this Component type in the entity to the given value or insert a new one if it does not exist.

Panics if Component is immutable.

Removes this Component type from the entity. Does nothing if it doesn’t exist.

Returns whether entity contains this Component

Gets the value of this Component type from the entity as a reflected reference.

Gets the value of this Component type from the entity as a mutable reflected reference.

Panics if Component is immutable.

This method does not prevent you from having two mutable pointers to the same data, violating Rust’s aliasing rules. To avoid this:

Panics if Component is immutable.

Gets the value of this Component type from entity from source_world and applies it to the value of this Component type in entity in destination_world.

Panics if there is no Component of the given type or either entity does not exist.

Register the type of this Component in World, returning its ComponentId.

Create a custom implementation of ReflectComponent.

This is an advanced feature, useful for scripting implementations, that should not be used by most users unless you know what you are doing.

Usually you should derive Reflect and add the #[reflect(Component)] component to generate a ReflectComponent implementation automatically.

See ReflectComponentFns for more information.

The underlying function pointers implementing methods on ReflectComponent.

This is useful when you want to keep track locally of an individual function pointer.

Calling TypeRegistry::get followed by TypeRegistration::data::<ReflectComponent> can be costly if done several times per frame. Consider cloning ReflectComponent and keeping it between frames, cloning a ReflectComponent is very cheap.

If you only need a subset of the methods on ReflectComponent, use fn_pointers to get the underlying ReflectComponentFns and copy the subset of function pointers you care about.

Calls a dynamic version of Component::map_entities.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U c

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectComponent(/* private fields */);
```

---

## Struct FixedPostUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedPostUpdate.html

**Contents:**
- Struct FixedPostUpdate Copy item path
- Trait Implementations§
  - impl Clone for FixedPostUpdate
    - fn clone(&self) -> FixedPostUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedPostUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedPostUpdate
    - fn default() -> FixedPostUpdate
  - impl Hash for FixedPostUpdate

The schedule that runs after the FixedUpdate schedule, for reacting to changes made in the main update logic.

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedPostUpdate;
```

---

## Struct TextFont Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextFont.html

**Contents:**
- Struct TextFont Copy item path
- Fields§
- Implementations§
  - impl TextFont
    - pub fn from_font_size(font_size: f32) -> TextFont
      - Examples found in repository?
    - pub fn with_font(self, font: Handle<Font>) -> TextFont
    - pub const fn with_font_size(self, font_size: f32) -> TextFont
    - pub const fn with_font_smoothing( self, font_smoothing: FontSmoothing, ) -> TextFont
      - Examples found in repository?

TextFont determines the style of a text span within a ComputedTextBlock, specifically the font face, the font size, the line height, and the antialiasing method.

The specific font face to use, as a Handle to a Font asset.

If the font is not specified, then

The vertical height of rasterized glyphs in the font atlas in pixels.

This is multiplied by the window scale factor and UiScale, but not the text entity transform or camera projection.

A new font atlas is generated for every combination of font handle and scaled font size which can have a strong performance impact.

The vertical height of a line of text, from the top of one line to the top of the next.

Defaults to LineHeight::RelativeToFont(1.2)

The antialiasing method to use when rendering text.

Returns a new TextFont with the specified font size.

Returns this TextFont with the specified font face handle.

Returns this TextFont with the specified font size.

Returns this TextFont with the specified FontSmoothing.

Returns this TextFont with the specified LineHeight.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextFont {
    pub font: Handle<Font>,
    pub font_size: f32,
    pub line_height: LineHeight,
    pub font_smoothing: FontSmoothing,
}
```

Example 2 (javascript):
```javascript
193    fn spawn_anchored_text(
194        commands: &mut Commands,
195        dest: Vec3,
196        justify: Justify,
197        bounds: Option<TextBounds>,
198    ) {
199        commands.spawn((
200            Sprite {
201                color: palettes::css::YELLOW.into(),
202                custom_size: Some(5. * Vec2::ONE),
203                ..Default::default()
204            },
205            Transform::from_translation(dest),
206            DespawnOnExit(super::Scene::Text),
207        ));
208
209        for anchor in [
210            Anchor::TOP_LEFT,
211            Anchor::TOP_RIGHT
...
```

Example 3 (javascript):
```javascript
24fn setup(mut commands: Commands) {
25    // Root UI node displaying instructions.
26    // Has no `UiTargetCamera`; the highest-order camera rendering to the primary window will be chosen automatically.
27    commands.spawn((
28        Node {
29                align_self: AlignSelf::Center,
30                justify_self: JustifySelf::Center,
31                justify_content: JustifyContent::Center,
32                bottom: px(2. * BOX_SIZE),
33                ..default()
34            },
35            Text::new("Each box is rendered by a different camera\n* left-click: increase the camera
...
```

Example 4 (javascript):
```javascript
27fn setup_scene(mut commands: Commands) {
28    // The first camera; no render target is specified, its render target will be set to the primary window automatically.
29    // This camera has no `RenderLayers` component, so it only renders entities belonging to render layer `0`.
30    commands.spawn(Camera2d);
31
32    // Spawn a second window
33    let secondary_window = commands
34        .spawn(Window {
35            title: "Secondary Window".to_owned(),
36            // Override the secondary window's scale factor and set it to double that of the primary window.
37            // This mean
...
```

---

## Struct Gizmo Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Gizmo.html

**Contents:**
- Struct Gizmo Copy item path
  - §Example
- Fields§
- Trait Implementations§
  - impl Clone for Gizmo
    - fn clone(&self) -> Gizmo
    - fn clone_from(&mut self, source: &Self)
  - impl Component for Gizmowhere Gizmo: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable

A component that draws the gizmos of a GizmoAsset.

When drawing a greater number of static lines a Gizmo component can have far better performance than the Gizmos system parameter, but the system parameter will perform better for smaller lines that update often.

The handle to the gizmo to draw.

The line specific configuration for this gizmo.

How closer to the camera than real geometry the gizmo should be.

In 2D this setting has no effect and is effectively always -1.

Value between -1 and 1 (inclusive).

This is typically useful if you are drawing wireframes on top of polygons and your wireframe is z-fighting (flickering on/off) with your main model. You would set this value to a negative number close to 0.

Required Components: Transform.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Gizmo {
    pub handle: Handle<GizmoAsset>,
    pub line_config: GizmoLineConfig,
    pub depth_bias: f32,
}
```

Example 2 (javascript):
```javascript
fn system(
    mut commands: Commands,
    mut gizmo_assets: ResMut<Assets<GizmoAsset>>,
) {
    let mut gizmo = GizmoAsset::default();

    gizmo.sphere(Vec3::ZERO, 1., RED);

    commands.spawn(Gizmo {
        handle: gizmo_assets.add(gizmo),
        line_config: GizmoLineConfig {
            width: 4.,
            ..default()
        },
        ..default()
    });
}
```

---

## Struct BackInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BackInOutCurve.html

**Contents:**
- Struct BackInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for BackInOutCurve
    - fn clone(&self) -> BackInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for BackInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as BackIn for t < 0.5 and as BackOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BackInOutCurve;
```

---

## Struct PreUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PreUpdate.html

**Contents:**
- Struct PreUpdate Copy item path
- Trait Implementations§
  - impl Clone for PreUpdate
    - fn clone(&self) -> PreUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PreUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PreUpdate
    - fn default() -> PreUpdate
  - impl Hash for PreUpdate

The schedule that contains logic that must run before Update. For example, a system that reads raw keyboard input OS events into a Messages resource. This enables systems in Update to consume the messages from the Messages resource without actually knowing about (or taking a direct scheduler dependency on) the “os-level keyboard event system”.

PreUpdate exists to do “engine/plugin preparation work” that ensures the APIs consumed in Update are “ready”. PreUpdate abstracts out “pre work implementation details”.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PreUpdate;
```

---

## Struct PostStartup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PostStartup.html

**Contents:**
- Struct PostStartup Copy item path
- Trait Implementations§
  - impl Clone for PostStartup
    - fn clone(&self) -> PostStartup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PostStartup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PostStartup
    - fn default() -> PostStartup
  - impl Hash for PostStartup

The schedule that runs once after Startup.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PostStartup;
```

---

## Struct UiDebugOptions Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiDebugOptions.html

**Contents:**
- Struct UiDebugOptions Copy item path
- Fields§
- Implementations§
  - impl UiDebugOptions
    - pub fn toggle(&mut self)
      - Examples found in repository?
- Trait Implementations§
  - impl Default for UiDebugOptions
    - fn default() -> UiDebugOptions
  - impl FromArg for UiDebugOptions

Configuration for the UI debug overlay

Set to true to enable the UI debug overlay

Width of the overlay’s lines in logical pixels

Show outlines for non-visible UI nodes

Show outlines for clipped sections of UI nodes

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiDebugOptions {
    pub enabled: bool,
    pub line_width: f32,
    pub show_hidden: bool,
    pub show_clipped: bool,
}
```

Example 2 (unknown):
```unknown
408fn toggle_debug_overlay(
409    input: Res<ButtonInput<KeyCode>>,
410    mut debug_options: ResMut<UiDebugOptions>,
411    mut root_node_query: Query<&mut Visibility, (With<Node>, Without<ChildOf>)>,
412) {
413    info_once!("The debug outlines are enabled, press Space to turn them on/off");
414    if input.just_pressed(KeyCode::Space) {
415        // The toggle method will enable the debug overlay if disabled and disable if enabled
416        debug_options.toggle();
417    }
418
419    if input.just_pressed(KeyCode::KeyS) {
420        // Toggle debug outlines for nodes with `ViewVisibility
...
```

---

## Struct Pointer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Pointer.html

**Contents:**
- Struct Pointer Copy item path
- Fields§
- Implementations§
  - impl<E> Pointer<E>where E: Debug + Clone + Reflect,
    - pub fn new( id: PointerId, location: Location, event: E, entity: Entity, ) -> Pointer<E>
- Trait Implementations§
  - impl<E> Clone for Pointer<E>where E: Clone + Debug + Reflect,
    - fn clone(&self) -> Pointer<E>
    - fn clone_from(&mut self, source: &Self)
  - impl<E> Component for Pointer<E>where E: Debug + Clone + Reflect, Pointer<E>: Send + Sync + 'static,

Stores the common data needed for all pointer events.

The documentation for the pointer_events explains the events this module exposes and the order in which they fire.

The entity this pointer event happened for.

The pointer that triggered this event

The location of the pointer during this event

Additional event-specific data. DragDrop for example, has an additional field to describe the Entity that is being dropped on the target.

Construct a new Pointer<E> event.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Pointer<E>where
    E: Debug + Clone + Reflect,{
    pub entity: Entity,
    pub pointer_id: PointerId,
    pub pointer_location: Location,
    pub event: E,
}
```

---

## Struct PropagateOver Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PropagateOver.html

**Contents:**
- Struct PropagateOver Copy item path
- Trait Implementations§
  - impl<C> Component for PropagateOver<C>where PropagateOver<C>: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior
    - fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_replace() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>

Stops the output component being added to this entity. Relationship targets will still inherit the component from this entity or its parents.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PropagateOver<C>(/* private fields */);
```

---

## Trait _ Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait._.html

**Contents:**
- Trait _ Copy item path
- Required Methods§
    - fn get_texture_view<'a>( &self, windows: &'a ExtractedWindows, images: &'a RenderAssets<GpuImage>, manual_texture_views: &'a ManualTextureViews, ) -> Option<&'a TextureView>
    - fn get_texture_format<'a>( &self, windows: &'a ExtractedWindows, images: &'a RenderAssets<GpuImage>, manual_texture_views: &'a ManualTextureViews, ) -> Option<TextureFormat>
    - fn get_render_target_info<'a>( &self, resolutions: impl IntoIterator<Item = (Entity, &'a Window)>, images: &Assets<Image>, manual_texture_views: &ManualTextureViews, ) -> Result<RenderTargetInfo, MissingRenderTargetInfoError>
    - fn is_changed( &self, changed_window_ids: &HashSet<Entity>, changed_image_handles: &HashSet<&AssetId<Image>>, ) -> bool
- Dyn Compatibility§
- Implementors§
  - impl NormalizedRenderTargetExt for NormalizedRenderTarget

Retrieves the TextureFormat of this render target, if it exists.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait _ {
    // Required methods
    fn get_texture_view<'a>(
        &self,
        windows: &'a ExtractedWindows,
        images: &'a RenderAssets<GpuImage>,
        manual_texture_views: &'a ManualTextureViews,
    ) -> Option<&'a TextureView>;
    fn get_texture_format<'a>(
        &self,
        windows: &'a ExtractedWindows,
        images: &'a RenderAssets<GpuImage>,
        manual_texture_views: &'a ManualTextureViews,
    ) -> Option<TextureFormat>;
    fn get_render_target_info<'a>(
        &self,
        resolutions: impl IntoIterator<Item = (Entity, &'a Window)>,
        image
...
```

---

## Struct PreUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PreUpdate.html

**Contents:**
- Struct PreUpdate Copy item path
- Trait Implementations§
  - impl Clone for PreUpdate
    - fn clone(&self) -> PreUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PreUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PreUpdate
    - fn default() -> PreUpdate
  - impl Hash for PreUpdate

The schedule that contains logic that must run before Update. For example, a system that reads raw keyboard input OS events into a Messages resource. This enables systems in Update to consume the messages from the Messages resource without actually knowing about (or taking a direct scheduler dependency on) the “os-level keyboard event system”.

PreUpdate exists to do “engine/plugin preparation work” that ensures the APIs consumed in Update are “ready”. PreUpdate abstracts out “pre work implementation details”.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PreUpdate;
```

---

## Struct Mesh2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mesh2d.html

**Contents:**
- Struct Mesh2d Copy item path
- §Example
- Tuple Fields§
- Methods from Deref<Target = Handle<Mesh>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§

A component for 2D meshes. Requires a MeshMaterial2d to be rendered, commonly using a ColorMaterial.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Required Components: Transform.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Mesh2d(pub Handle<Mesh>);
```

Example 2 (unknown):
```unknown
// Spawn an entity with a mesh using `ColorMaterial`.
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    commands.spawn((
        Mesh2d(meshes.add(Circle::new(50.0))),
        MeshMaterial2d(materials.add(ColorMaterial::from_color(RED))),
    ));
}
```

Example 3 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 4 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

---

## Struct DistanceFog Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DistanceFog.html

**Contents:**
- Struct DistanceFog Copy item path
  - §Falloff
  - §Example
  - §Material Override
- Fields§
- Trait Implementations§
  - impl Clone for DistanceFog
    - fn clone(&self) -> DistanceFog
    - fn clone_from(&mut self, source: &Self)
  - impl Component for DistanceFogwhere DistanceFog: Send + Sync + 'static,

Configures the “classic” computer graphics distance fog effect, in which objects appear progressively more covered in atmospheric haze the further away they are from the camera. Affects meshes rendered via the PBR StandardMaterial.

The rate at which fog intensity increases with distance is controlled by the falloff mode. Currently, the following fog falloff modes are supported:

Once enabled for a specific camera, the fog effect can also be disabled for individual StandardMaterial instances via the fog_enabled flag.

The color of the fog effect.

Tip: The alpha channel of the color can be used to “modulate” the fog effect without changing the fog falloff mode or parameters.

Color used to modulate the influence of directional light colors on the fog, where the view direction aligns with each directional light direction, producing a “glow” or light dispersion effect. (e.g. around the sun)

Use Color::NONE to disable the effect.

The exponent applied to the directional light alignment calculation. A higher value means a more concentrated “glow”.

Determines which falloff mode to use, and its parameters.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DistanceFog {
    pub color: Color,
    pub directional_light_color: Color,
    pub directional_light_exponent: f32,
    pub falloff: FogFalloff,
}
```

Example 2 (unknown):
```unknown
commands.spawn((
    // Setup your camera as usual
    Camera3d::default(),
    // Add fog to the same entity
    DistanceFog {
        color: Color::WHITE,
        falloff: FogFalloff::Exponential { density: 1e-3 },
        ..Default::default()
    },
));
```

---

## Function state_changed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.state_changed.html

**Contents:**
- Function state_changed Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the state machine changed state.

To do things on transitions to/from specific states, use their respective OnEnter/OnExit schedules. Use this run condition if you want to detect any change, regardless of the value.

Returns false if the state does not exist or the state has not changed.

**Examples:**

Example 1 (unknown):
```unknown
pub fn state_changed<S>(current_state: Option<Res<'_, State<S>>>) -> boolwhere
    S: States,
```

Example 2 (unknown):
```unknown
#[derive(States, Clone, Copy, Default, Eq, PartialEq, Hash, Debug)]
enum GameState {
    #[default]
    Playing,
    Paused,
}

app
    .init_state::<GameState>()
    .add_systems(Update,
        // `state_changed` will only return true if the
        // given states value has just been updated or
        // the state has just been added
        my_system.run_if(state_changed::<GameState>),
    );

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `GameState` has just been added so `my_system` will run
app.update();
assert_eq!(app.world().resource::<Counter>().0, 1);

// `
...
```

---

## Struct QueryState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QueryState.html

**Contents:**
- Struct QueryState Copy item path
- Implementations§
  - impl<D, F> QueryState<D, F>where D: QueryData, F: QueryFilter,
    - pub fn as_readonly(&self) -> &QueryState<<D as QueryData>::ReadOnly, F>
    - pub fn component_access(&self) -> &FilteredAccess
    - pub fn matched_tables(&self) -> impl Iterator<Item = TableId>
    - pub fn matched_archetypes(&self) -> impl Iterator<Item = ArchetypeId>
    - pub fn new(world: &mut World) -> QueryState<D, F>
    - pub fn try_new(world: &World) -> Option<QueryState<D, F>>
    - pub fn from_builder(builder: &mut QueryBuilder<'_, D, F>) -> QueryState<D, F>

Provides scoped access to a World state according to a given QueryData and QueryFilter.

This data is cached between system runs, and is used to:

Converts this QueryState reference to a QueryState that does not access anything mutably.

Returns the components accessed by this query.

Returns the tables matched by this query.

Returns the archetypes matched by this query.

Creates a new QueryState from a given World and inherits the result of world.id().

Creates a new QueryState from an immutable World reference and inherits the result of world.id().

This function may fail if, for example, the components that make up this query have not been registered into the world.

Creates a new QueryState from a given QueryBuilder and inherits its FilteredAccess.

Creates a Query from the given QueryState and World.

This will create read-only queries, see Self::query_mut for mutable queries.

Creates a Query from the given QueryState and World.

This method is slightly more efficient than QueryState::query in some situations, since it does not update this instance’s internal cache. The resulting query may skip an entity that belongs to an archetype that has not been cached.

To ensure that the cache is up to date, call QueryState::update_archetypes before this method. The cache is also updated in QueryState::new, QueryState::get, or any method with mutable access to self.

This will create read-only queries, see Self::query_mut for mutable queries.

Creates a Query from the given QueryState and World.

Creates a Query from the given QueryState and World.

This does not check for mutable query correctness. To be safe, make sure mutable queries have unique access to the components they query.

Creates a Query from the given QueryState and World.

This method is slightly more efficient than QueryState::query_unchecked in some situations, since it does not update this instance’s internal cache. The resulting query may skip an entity that belongs to an archetype that has not been cached.

To ensure that the cache is up to date, call QueryState::update_archetypes before this method. The cache is also updated in QueryState::new, QueryState::get, or any method with mutable access to self.

This does not check for mutable query correctness. To be safe, make sure mutable queries have unique access to the components they query. This does not validate that world.id() matches self.world_id. Calling this on a world with a mismatched WorldId is unsound.

Creates a Query from the 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct QueryState<D, F = ()>where
    D: QueryData,
    F: QueryFilter,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
use bevy_ecs::prelude::*;
use bevy_ecs::query::QueryEntityError;

#[derive(Component, PartialEq, Debug)]
struct A(usize);

let mut world = World::new();
let entity_vec: Vec<Entity> = (0..3).map(|i|world.spawn(A(i)).id()).collect();
let entities: [Entity; 3] = entity_vec.try_into().unwrap();

world.spawn(A(73));

let mut query_state = world.query::<&A>();

let component_values = query_state.get_many(&world, entities).unwrap();

assert_eq!(component_values, [&A(0), &A(1), &A(2)]);

let wrong_entity = Entity::from_raw_u32(365).unwrap();

assert_eq!(match query_state.get_many(&mut world, [wrong_en
...
```

Example 3 (javascript):
```javascript
use bevy_ecs::{prelude::*, query::QueryEntityError, entity::{EntitySetIterator, UniqueEntityArray, UniqueEntityVec}};

#[derive(Component, PartialEq, Debug)]
struct A(usize);

let mut world = World::new();
let entity_set: UniqueEntityVec = world.spawn_batch((0..3).map(A)).collect_set();
let entity_set: UniqueEntityArray<3> = entity_set.try_into().unwrap();

world.spawn(A(73));

let mut query_state = world.query::<&A>();

let component_values = query_state.get_many_unique(&world, entity_set).unwrap();

assert_eq!(component_values, [&A(0), &A(1), &A(2)]);

let wrong_entity = Entity::from_raw_u32
...
```

Example 4 (javascript):
```javascript
use bevy_ecs::prelude::*;
use bevy_ecs::query::QueryEntityError;

#[derive(Component, PartialEq, Debug)]
struct A(usize);

let mut world = World::new();

let entities: Vec<Entity> = (0..3).map(|i|world.spawn(A(i)).id()).collect();
let entities: [Entity; 3] = entities.try_into().unwrap();

world.spawn(A(73));

let mut query_state = world.query::<&mut A>();

let mut mutable_component_values = query_state.get_many_mut(&mut world, entities).unwrap();

for mut a in &mut mutable_component_values {
    a.0 += 5;
}

let component_values = query_state.get_many(&world, entities).unwrap();

assert_eq!(co
...
```

---

## Macro info Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.info.html

**Contents:**
- Macro info Copy item path
- §Examples

Constructs an event at the info level.

This functions similarly to the event! macro. See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! info {
    (name: $name:expr, target: $target:expr, parent: $parent:expr, { $($field:tt)* }, $($arg:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, ?$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, %$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($arg:tt)+ ) => { ... };
    (name: $name:expr, target: $target:expr, {
...
```

Example 2 (javascript):
```javascript
use tracing::info;
use tracing::field;

let addr = Ipv4Addr::new(127, 0, 0, 1);
let conn = Connection { port: 40, speed: 3.20 };

info!(conn.port, "connected to {:?}", addr);
info!(
    target: "connection_events",
    ip = ?addr,
    conn.port,
    ?conn.speed,
);
info!(name: "completed", "completed connection to {:?}", addr);
```

---

## Struct RationalCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RationalCurve.html

**Contents:**
- Struct RationalCurve Copy item path
- Implementations§
  - impl<P> RationalCurve<P>where P: VectorSpace<Scalar = f32>,
    - pub fn from_segments( segments: impl IntoIterator<Item = RationalSegment<P>>, ) -> Option<RationalCurve<P>>
    - pub fn position(&self, t: f32) -> P
    - pub fn velocity(&self, t: f32) -> P
    - pub fn acceleration(&self, t: f32) -> P
    - pub fn iter_samples<'a, 'b>( &'b self, subdivisions: usize, sample_function: impl FnMut(&RationalCurve<P>, f32) -> P + 'a, ) -> impl Iterator<Item = P> + 'awhere 'b: 'a,
    - pub fn segments(&self) -> &[RationalSegment<P>]
    - pub fn iter_positions(&self, subdivisions: usize) -> impl Iterator<Item = P>

A collection of RationalSegments chained into a single parametric curve. It is a Curve with domain [0, N], where N is the number of segments.

Use any struct that implements the RationalGenerator trait to create a new curve, such as CubicNurbs, or convert CubicCurve using into/from.

Create a new curve from a collection of segments. If the collection of segments is empty, a curve cannot be built and None will be returned instead.

Compute the position of a point on the curve at the parametric value t.

Note that t varies from 0 to self.length().

Compute the first derivative with respect to t at t. This is the instantaneous velocity of a point on the curve at t.

Note that t varies from 0 to self.length().

Compute the second derivative with respect to t at t. This is the instantaneous acceleration of a point on the curve at t.

Note that t varies from 0 to self.length().

A flexible iterator used to sample curves with arbitrary functions.

This splits the curve into subdivisions of evenly spaced t values across the length of the curve from start (t = 0) to end (t = n), where n = self.segment_count(), returning an iterator evaluating the curve with the supplied sample_function at each t.

For subdivisions = 2, this will split the curve into two lines, or three points, and return an iterator with 3 items, the three points, one at the start, middle, and end.

The list of segments contained in this RationalCurve.

This spline’s global t value is equal to how many segments it has.

All method accepting t on RationalCurve depends on the global t. When sampling over the entire curve, you should either use one of the iter_* methods or account for the segment count using curve.segments().len().

Iterate over the curve split into subdivisions, sampling the position at each step.

Iterate over the curve split into subdivisions, sampling the velocity at each step.

Iterate over the curve split into subdivisions, sampling the acceleration at each step.

Adds a segment to the curve.

Returns the length of the domain of the parametric curve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RationalCurve<P>where
    P: VectorSpace,{ /* private fields */ }
```

---

## Trait TupleStruct Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.TupleStruct.html

**Contents:**
- Trait TupleStruct Copy item path
- §Example
- Required Methods§
    - fn field(&self, index: usize) -> Option<&(dyn PartialReflect + 'static)>
    - fn field_mut( &mut self, index: usize, ) -> Option<&mut (dyn PartialReflect + 'static)>
    - fn field_len(&self) -> usize
    - fn iter_fields(&self) -> TupleStructFieldIter<'_> ⓘ
- Provided Methods§
    - fn to_dynamic_tuple_struct(&self) -> DynamicTupleStruct
    - fn get_represented_tuple_struct_info(&self) -> Option<&'static TupleStructInfo>

A trait used to power tuple struct-like operations via reflection.

This trait uses the Reflect trait to allow implementors to have their fields be dynamically addressed by index.

When using #[derive(Reflect)] on a tuple struct, this trait will be automatically implemented.

Returns a reference to the value of the field with index index as a &dyn Reflect.

Returns a mutable reference to the value of the field with index index as a &mut dyn Reflect.

Returns the number of fields in the tuple struct.

Returns an iterator over the values of the tuple struct’s fields.

Creates a new DynamicTupleStruct from this tuple struct.

Will return None if TypeInfo is not available.

**Examples:**

Example 1 (unknown):
```unknown
pub trait TupleStruct: PartialReflect {
    // Required methods
    fn field(&self, index: usize) -> Option<&(dyn PartialReflect + 'static)>;
    fn field_mut(
        &mut self,
        index: usize,
    ) -> Option<&mut (dyn PartialReflect + 'static)>;
    fn field_len(&self) -> usize;
    fn iter_fields(&self) -> TupleStructFieldIter<'_> ⓘ;

    // Provided methods
    fn to_dynamic_tuple_struct(&self) -> DynamicTupleStruct { ... }
    fn get_represented_tuple_struct_info(
        &self,
    ) -> Option<&'static TupleStructInfo> { ... }
}
```

Example 2 (javascript):
```javascript
use bevy_reflect::{PartialReflect, Reflect, TupleStruct};

#[derive(Reflect)]
struct Foo(u32);

let foo = Foo(123);

assert_eq!(foo.field_len(), 1);

let field: &dyn PartialReflect = foo.field(0).unwrap();
assert_eq!(field.try_downcast_ref::<u32>(), Some(&123));
```

---

## Struct QuinticOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuinticOutCurve.html

**Contents:**
- Struct QuinticOutCurve Copy item path
- Trait Implementations§
  - impl Clone for QuinticOutCurve
    - fn clone(&self) -> QuinticOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuinticOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = (t - 1.0)⁵ + 1.0

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuinticOutCurve;
```

---

## Struct DefaultPlugins Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DefaultPlugins.html

**Contents:**
- Struct DefaultPlugins Copy item path
- Trait Implementations§
  - impl PluginGroup for DefaultPlugins
    - fn build(self) -> PluginGroupBuilder
    - fn name() -> String
    - fn set<T>(self, plugin: T) -> PluginGroupBuilderwhere T: Plugin,
- Auto Trait Implementations§
  - impl Freeze for DefaultPlugins
  - impl RefUnwindSafe for DefaultPlugins
  - impl Send for DefaultPlugins

This plugin group will add all the default plugins for a Bevy application:

DefaultPlugins obeys Cargo feature flags. Users may exert control over this plugin group by disabling default-features in their Cargo.toml and enabling only those features that they wish to use.

DefaultPlugins contains all the plugins typically required to build a Bevy application which includes a window and presentation components. For the absolute minimum number of plugins needed to run a Bevy application, see MinimalPlugins.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DefaultPlugins;
```

---

## Derive Macro FromWorld Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.FromWorld.html

**Contents:**
- Derive Macro FromWorld Copy item path

Implement the FromWorld trait.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(FromWorld)]
{
    // Attributes available to this derive:
    #[from_world]
}
```

---

## Struct ManualTextureViews Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ManualTextureViews.html

**Contents:**
- Struct ManualTextureViews Copy item path
- Methods from Deref<Target = HashMap<ManualTextureViewHandle, ManualTextureView>>§
    - pub fn hasher(&self) -> &S
    - pub fn capacity(&self) -> usize
      - §Examples
    - pub fn keys(&self) -> Keys<'_, K, V> ⓘ
      - §Examples
      - Examples found in repository?
    - pub fn values(&self) -> Values<'_, K, V> ⓘ
      - §Examples

Resource that stores manually managed ManualTextureViews for use as a RenderTarget. This type dereferences to a HashMap<ManualTextureViewHandle, ManualTextureView>. To add a new texture view, pick a new ManualTextureViewHandle and insert it into the map. Then, to render to the view, set a Cameras target to RenderTarget::TextureView(handle).

Bevy will then use the ManualTextureViews resource to find your texture view and render to it.

Returns a reference to the map’s BuildHasher, or S parameter.

Refer to hasher for further details.

Returns the number of elements the map can hold without reallocating.

Refer to capacity for further details.

An iterator visiting all keys in arbitrary order. The iterator element type is &'a K.

Refer to keys for further details.

An iterator visiting all values in arbitrary order. The iterator element type is &'a V.

Refer to values for further details.

An iterator visiting all values mutably in arbitrary order. The iterator element type is &'a mut V.

Refer to values for further details.

An iterator visiting all key-value pairs in arbitrary order. The iterator element type is (&'a K, &'a V).

Refer to iter for further details.

An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values. The iterator element type is (&'a K, &'a mut V).

Refer to iter_mut for further details.

Returns the number of elements in the map.

Refer to len for further details.

Returns true if the map contains no elements.

Refer to is_empty for further details.

Clears the map, returning all key-value pairs as an iterator. Keeps the allocated memory for reuse.

Refer to drain for further details.

Retains only the elements specified by the predicate. Keeps the allocated memory for reuse.

Refer to retain for further details.

Drains elements which are true under the given predicate, and returns an iterator over the removed items.

Refer to extract_if for further details.

Clears the map, removing all key-value pairs. Keeps the allocated memory for reuse.

Refer to clear for further details.

Reserves capacity for at least additional more elements to be inserted in the HashMap. The collection may reserve more space to avoid frequent reallocations.

Refer to reserve for further details.

Tries to reserve capacity for at least additional more elements to be inserted in the given HashMap<K,V>. The collection may reserve more space to avoid frequent reallocations.

Refer to try_reserve for further details.

S

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct ManualTextureViews(/* private fields */);
```

Example 2 (javascript):
```javascript
let manual_views = world.resource_mut::<ManualTextureViews>();
let manual_view = ManualTextureView::with_default_format(texture_view, UVec2::new(1024, 1024));

// Choose an unused handle value; it's likely only you are inserting manual views.
const MANUAL_VIEW_HANDLE: ManualTextureViewHandle = ManualTextureViewHandle::new(42);
manual_views.insert(MANUAL_VIEW_HANDLE, manual_view);

// Now you can spawn a Cemera that renders to the manual view:
world.spawn(Camera {
    target: RenderTarget::TextureView(MANUAL_VIEW_HANDLE),
    ..Default::default()
});
```

Example 3 (javascript):
```javascript
let map = HashMap::with_capacity(5);

assert!(map.capacity() >= 5);
```

Example 4 (javascript):
```javascript
let mut map = HashMap::new();

map.insert("foo", 0);
map.insert("bar", 1);
map.insert("baz", 2);

for key in map.keys() {
    // foo, bar, baz
    // Note that the above order is not guaranteed
}
```

---

## Struct ParallelCommands Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ParallelCommands.html

**Contents:**
- Struct ParallelCommands Copy item path
- §Note
- §Example
- Implementations§
  - impl<'w, 's> ParallelCommands<'w, 's>
    - pub fn command_scope<R>(&self, f: impl FnOnce(Commands<'_, '_>) -> R) -> R
- Trait Implementations§
  - impl SystemParam for ParallelCommands<'_, '_>
    - type State = FetchState
    - type Item<'w, 's> = ParallelCommands<'w, 's>

An alternative to Commands that can be used in parallel contexts, such as those in Query::par_iter.

For cases where multiple non-computation-heavy (lightweight) bundles of the same Bundle type need to be spawned, consider using Commands::spawn_batch for better performance.

Because command application order will depend on how many threads are ran, non-commutative commands may result in non-deterministic results.

Temporarily provides access to the Commands for the current thread.

For an example, see the type-level documentation for ParallelCommands.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ParallelCommands<'w, 's> { /* private fields */ }
```

Example 2 (unknown):
```unknown
fn parallel_command_system(
    mut query: Query<(Entity, &Velocity)>,
    par_commands: ParallelCommands
) {
    query.par_iter().for_each(|(entity, velocity)| {
        if velocity.magnitude() > 10.0 {
            par_commands.command_scope(|mut commands| {
                commands.entity(entity).despawn();
            });
        }
    });
}
```

---

## Struct ConvexPolygon Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ConvexPolygon.html

**Contents:**
- Struct ConvexPolygon Copy item path
- Implementations§
  - impl ConvexPolygon
    - pub fn new( vertices: impl IntoIterator<Item = Vec2>, ) -> Result<ConvexPolygon, ConvexPolygonError>
      - §Errors
    - pub fn new_unchecked(vertices: impl IntoIterator<Item = Vec2>) -> ConvexPolygon
    - pub fn vertices(&self) -> &[Vec2]
- Trait Implementations§
  - impl Bounded2d for ConvexPolygon
    - fn aabb_2d(&self, isometry: impl Into<Isometry2d>) -> Aabb2d

A convex polygon with N vertices.

Create a ConvexPolygon from its vertices.

Returns ConvexPolygonError::Concave if the vertices do not form a convex polygon.

Create a ConvexPolygon from its vertices, without checks. Use this version only if you know that the vertices make up a convex polygon.

Get the vertices of this polygon

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ConvexPolygon { /* private fields */ }
```

---

## Struct Local Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Local.html

**Contents:**
- Struct Local Copy item path
- §Examples
- Trait Implementations§
  - impl<'s, T> Debug for Local<'s, T>where T: Debug + FromWorld + Send + 'static,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'s, T> Deref for Local<'s, T>where T: FromWorld + Send + 'static,
    - type Target = T
    - fn deref(&self) -> &<Local<'s, T> as Deref>::Target
  - impl<'s, T> DerefMut for Local<'s, T>where T: FromWorld + Send + 'static,
    - fn deref_mut(&mut self) -> &mut <Local<'s, T> as Deref>::Target

A system local SystemParam.

A local may only be accessed by the system itself and is therefore not visible to other systems. If two or more systems specify the same local type each will have their own unique local. If multiple SystemParams within the same system each specify the same local type each will get their own distinct data storage.

The supplied lifetime parameter is the SystemParams 's lifetime.

A simple way to set a different default value for a local is by wrapping the value with an Option.

N.B. A Locals value cannot be read or written to outside of the containing system. To add configuration to a system, convert a capturing closure into the system instead:

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Local<'s, T>(/* private fields */)
where
    T: FromWorld + Send + 'static;
```

Example 2 (javascript):
```javascript
fn write_to_local(mut local: Local<usize>) {
    *local = 42;
}
fn read_from_local(local: Local<usize>) -> usize {
    *local
}
let mut write_system = IntoSystem::into_system(write_to_local);
let mut read_system = IntoSystem::into_system(read_from_local);
write_system.initialize(world);
read_system.initialize(world);

assert_eq!(read_system.run((), world).unwrap(), 0);
write_system.run((), world);
// Note how the read local is still 0 due to the locals not being shared.
assert_eq!(read_system.run((), world).unwrap(), 0);
```

Example 3 (javascript):
```javascript
fn counter_from_10(mut count: Local<Option<usize>>) -> usize {
    let count = count.get_or_insert(10);
    *count += 1;
    *count
}
let mut counter_system = IntoSystem::into_system(counter_from_10);
counter_system.initialize(world);

// Counter is initialized at 10, and increases to 11 on first run.
assert_eq!(counter_system.run((), world).unwrap(), 11);
// Counter is only increased by 1 on subsequent runs.
assert_eq!(counter_system.run((), world).unwrap(), 12);
```

Example 4 (unknown):
```unknown
struct Config(u32);
#[derive(Resource)]
struct MyU32Wrapper(u32);
fn reset_to_system(value: Config) -> impl FnMut(ResMut<MyU32Wrapper>) {
    move |mut val| val.0 = value.0
}

// .add_systems(reset_to_system(my_config))
```

---

## Struct Add Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Add.html

**Contents:**
- Struct Add Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Add
    - fn clone(&self) -> Add
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Add
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl EntityEvent for Addwhere Add: Send + Sync + 'static,
    - fn event_target(&self) -> Entity

Trigger emitted when a component is inserted onto an entity that does not already have that component. Runs before Insert. See ComponentHooks::on_add for more information.

The entity this component was added to.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Add {
    pub entity: Entity,
}
```

---

## Struct TaskPoolOptions Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.TaskPoolOptions.html

**Contents:**
- Struct TaskPoolOptions Copy item path
- Fields§
- Implementations§
  - impl TaskPoolOptions
    - pub fn with_num_threads(thread_count: usize) -> TaskPoolOptions
      - Examples found in repository?
    - pub fn create_default_pools(&self)
- Trait Implementations§
  - impl Clone for TaskPoolOptions
    - fn clone(&self) -> TaskPoolOptions

Helper for configuring and creating the default task pools. For end-users who want full control, set up TaskPoolPlugin

If the number of physical cores is less than min_total_threads, force using min_total_threads

If the number of physical cores is greater than max_total_threads, force using max_total_threads

Used to determine number of IO threads to allocate

Used to determine number of async compute threads to allocate

Used to determine number of compute threads to allocate

Create a configuration that forces using the given number of threads.

Inserts the default thread pools into the given resource map based on the configured values

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TaskPoolOptions {
    pub min_total_threads: usize,
    pub max_total_threads: usize,
    pub io: TaskPoolThreadAssignmentPolicy,
    pub async_compute: TaskPoolThreadAssignmentPolicy,
    pub compute: TaskPoolThreadAssignmentPolicy,
}
```

Example 2 (unknown):
```unknown
6fn main() {
7    App::new()
8        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
9            task_pool_options: TaskPoolOptions::with_num_threads(4),
10        }))
11        .run();
12}
```

---

## Enum FlexWrap Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.FlexWrap.html

**Contents:**
- Enum FlexWrap Copy item path
- Variants§
  - NoWrap
  - Wrap
  - WrapReverse
- Implementations§
  - impl FlexWrap
    - pub const DEFAULT: FlexWrap = Self::NoWrap
- Trait Implementations§
  - impl Clone for FlexWrap

Defines if flexbox items appear on a single line or on multiple lines

Single line, will overflow if needed.

Multiple lines, if needed.

Same as FlexWrap::Wrap but new lines will appear before the previous one.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum FlexWrap {
    NoWrap,
    Wrap,
    WrapReverse,
}
```

---

## Struct GizmoAsset Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GizmoAsset.html

**Contents:**
- Struct GizmoAsset Copy item path
- Implementations§
  - impl GizmoAsset
    - pub fn new() -> GizmoAsset
      - Examples found in repository?
    - pub fn config_typeid(&self) -> TypeId
- Methods from Deref<Target = GizmoBuffer<ErasedGizmoConfigGroup, ()>>§
    - pub fn arc_2d( &mut self, isometry: impl Into<Isometry2d>, arc_angle: f32, radius: f32, color: impl Into<Color>, ) -> Arc2dBuilder<'_, Config, Clear>
      - §Arguments
      - §Example

A collection of gizmos.

Has the same gizmo drawing API as Gizmos.

Create a new GizmoAsset.

The type of the gizmo’s configuration group.

Draw an arc, which is a part of the circumference of a circle, in 2D.

This should be called for each frame the arc needs to be rendered.

Draw an arc, which is a part of the circumference of a circle, in 3D. For default values this is drawing a standard arc. A standard arc is defined as

This should be called for each frame the arc needs to be rendered.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the shortest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the longest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the shortest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the longest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draw an arrow in 3D, from start to end. Has four tips for convenient viewing from any direction.

This should be called for each frame the arrow needs to be rendered.

Draw an arrow in 2D (on the xy plane), from start to end.

This should be called for each frame the arrow needs to be rendered.

Draw a set of axes local to the given transform (transform), with length scaled by a factor of base_length.

This should be called for each frame the axes need to be rendered.

Draw a set of axes local to the given transform (transform), with length scaled by a factor of base_length.

This should be called for each frame the axes need to be rendered.

Draw an ellipse in 3D with the given isometry applied.

If isometry == Isometry3d::IDENTITY then

This should be called for each frame the ellipse needs to be rendered.

Draw an ellipse in 2D with the given isometry applied.

If isometry == Isometry2d::IDENTITY then

This should be called for each frame the ellipse needs to be rendered.

Draw a circle in 3D with the given isometry applied.

If isometry == Isometry3d::IDENTITY then

Draw a circle in 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct GizmoAsset { /* private fields */ }
```

Example 2 (javascript):
```javascript
23fn setup(
24    mut commands: Commands,
25    mut gizmo_assets: ResMut<Assets<GizmoAsset>>,
26    mut meshes: ResMut<Assets<Mesh>>,
27    mut materials: ResMut<Assets<StandardMaterial>>,
28) {
29    let mut gizmo = GizmoAsset::new();
30
31    // When drawing a lot of static lines a Gizmo component can have
32    // far better performance than the Gizmos system parameter,
33    // but the system parameter will perform better for smaller lines that update often.
34
35    // A sphere made out of 30_000 lines!
36    gizmo
37        .sphere(Isometry3d::IDENTITY, 0.5, CRIMSON)
38        .resolutio
...
```

Example 3 (unknown):
```unknown
fn system(mut gizmos: Gizmos) {
    gizmos.arc_2d(Isometry2d::IDENTITY, FRAC_PI_4, 1., GREEN);

    // Arcs have 32 line-segments by default.
    // You may want to increase this for larger arcs.
    gizmos
        .arc_2d(Isometry2d::IDENTITY, FRAC_PI_4, 5., RED)
        .resolution(64);
}
```

Example 4 (javascript):
```javascript
40fn draw_example_collection(
41    mut gizmos: Gizmos,
42    mut my_gizmos: Gizmos<MyRoundGizmos>,
43    time: Res<Time>,
44) {
45    let sin_t_scaled = ops::sin(time.elapsed_secs()) * 50.;
46    gizmos.line_2d(Vec2::Y * -sin_t_scaled, Vec2::splat(-80.), RED);
47    gizmos.ray_2d(Vec2::Y * sin_t_scaled, Vec2::splat(80.), LIME);
48
49    gizmos
50        .grid_2d(
51            Isometry2d::IDENTITY,
52            UVec2::new(16, 9),
53            Vec2::new(80., 80.),
54            // Dark gray
55            LinearRgba::gray(0.05),
56        )
57        .outer_edges();
58
59    // Triangle
60   
...
```

---

## Enum ClearColorConfig Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ClearColorConfig.html

**Contents:**
- Enum ClearColorConfig Copy item path
- Variants§
  - Default
  - Custom(Color)
  - None
- Trait Implementations§
  - impl Clone for ClearColorConfig
    - fn clone(&self) -> ClearColorConfig
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ClearColorConfig

For a camera, specifies the color used to clear the viewport before rendering or when writing to the final render target texture.

The clear color is taken from the world’s ClearColor resource.

The given clear color is used, overriding the ClearColor resource defined in the world.

No clear color is used: the camera will simply draw on top of anything already in the viewport.

This can be useful when multiple cameras are rendering to the same viewport.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ClearColorConfig {
    Default,
    Custom(Color),
    None,
}
```

---

## Struct ReflectFromReflect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectFromReflect.html

**Contents:**
- Struct ReflectFromReflect Copy item path
- §Example
- Implementations§
  - impl ReflectFromReflect
    - pub fn from_reflect( &self, reflect_value: &(dyn PartialReflect + 'static), ) -> Option<Box<dyn Reflect>>
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for ReflectFromReflect
    - fn clone(&self) -> ReflectFromReflect
    - fn clone_from(&mut self, source: &Self)

Type data that represents the FromReflect trait and allows it to be used dynamically.

FromReflect allows dynamic types (e.g. DynamicStruct, DynamicEnum, etc.) to be converted to their full, concrete types. This is most important when it comes to deserialization where it isn’t guaranteed that every field exists when trying to construct the final output.

However, to do this, you normally need to specify the exact concrete type:

In a dynamic context where the type might not be known at compile-time, this is nearly impossible to do. That is why this type data struct exists— it allows us to construct the full type without knowing what the actual type is.

Perform a FromReflect::from_reflect conversion on the given reflection object.

This will convert the object to a concrete type if it wasn’t already, and return the value as Box<dyn Reflect>.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectFromReflect { /* private fields */ }
```

Example 2 (javascript):
```javascript
#[derive(Reflect, PartialEq, Eq, Debug)]
struct Foo(#[reflect(default = "default_value")] usize);

fn default_value() -> usize { 123 }

let reflected = DynamicTupleStruct::default();

let concrete: Foo = <Foo as FromReflect>::from_reflect(&reflected).unwrap();

assert_eq!(Foo(123), concrete);
```

Example 3 (javascript):
```javascript
let mut reflected = DynamicTupleStruct::default();
reflected.set_represented_type(Some(<Foo as Typed>::type_info()));

let registration = registry.get_with_type_path(<Foo as TypePath>::type_path()).unwrap();
let rfr = registration.data::<ReflectFromReflect>().unwrap();

let concrete: Box<dyn Reflect> = rfr.from_reflect(&reflected).unwrap();

assert_eq!(Foo(123), concrete.take::<Foo>().unwrap());
```

Example 4 (javascript):
```javascript
12fn main() {
13    #[derive(Reflect, Default, PartialEq, Debug)]
14    #[reflect(Identifiable, Default)]
15    struct Player {
16        id: u32,
17    }
18
19    #[reflect_trait]
20    trait Identifiable {
21        fn id(&self) -> u32;
22    }
23
24    impl Identifiable for Player {
25        fn id(&self) -> u32 {
26            self.id
27        }
28    }
29
30    // Normally, when instantiating a type, you get back exactly that type.
31    // This is because the type is known at compile time.
32    // We call this the "concrete" or "canonical" type.
33    let player: Player = Player { id: 
...
```

---

## Struct RemovedComponents Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RemovedComponents.html

**Contents:**
- Struct RemovedComponents Copy item path
- §Examples
- Implementations§
  - impl<'w, 's, T> RemovedComponents<'w, 's, T>where T: Component,
    - pub fn reader(&self) -> &MessageCursor<RemovedComponentEntity>
    - pub fn reader_mut(&mut self) -> &mut MessageCursor<RemovedComponentEntity>
    - pub fn events(&self) -> Option<&Messages<RemovedComponentEntity>>
    - pub fn messages(&self) -> Option<&Messages<RemovedComponentEntity>>
    - pub fn reader_mut_with_messages( &mut self, ) -> Option<(&mut RemovedComponentReader<T>, &Messages<RemovedComponentEntity>)>
    - pub fn reader_mut_with_events( &mut self, ) -> Option<(&mut RemovedComponentReader<T>, &Messages<RemovedComponentEntity>)>

A SystemParam that yields entities that had their T Component removed or have been despawned with it.

This acts effectively the same as a MessageReader.

Unlike hooks or observers (see the lifecycle module docs), this does not allow you to see which data existed before removal.

If you are using bevy_ecs as a standalone crate, note that the RemovedComponents list will not be automatically cleared for you, and will need to be manually flushed using World::clear_trackers.

For users of bevy and bevy_app, World::clear_trackers is automatically called by bevy_app::App::update and bevy_app::SubApp::update. For the main world, this is delayed until after all SubApps have run.

Fetch underlying MessageCursor.

Fetch underlying MessageCursor mutably.

Fetch underlying Messages.

Fetch underlying Messages.

Destructures to get a mutable reference to the MessageCursor and a reference to Messages.

This is necessary since Rust can’t detect destructuring through methods and most usecases of the reader uses the Messages as well.

Destructures to get a reference to the MessageCursor and a reference to Messages.

Iterates over the messages this RemovedComponents has not seen yet. This updates the RemovedComponents’s message counter, which means subsequent message reads will not include messages that happened before now.

Like read, except also returning the MessageId of the messages.

Determines the number of removal messages available to be read from this RemovedComponents without consuming any.

Returns true if there are no messages available to read.

Consumes all available messages.

This means these messages will not appear in calls to RemovedComponents::read() or RemovedComponents::read_with_id() and RemovedComponents::is_empty() will return true.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RemovedComponents<'w, 's, T>where
    T: Component,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
fn react_on_removal(mut removed: RemovedComponents<MyComponent>) {
    removed.read().for_each(|removed_entity| println!("{}", removed_entity));
}
```

Example 3 (javascript):
```javascript
245fn update_button_style2(
246    mut buttons: Query<
247        (
248            Has<Pressed>,
249            &Hovered,
250            Has<InteractionDisabled>,
251            &mut BackgroundColor,
252            &mut BorderColor,
253            &Children,
254        ),
255        With<DemoButton>,
256    >,
257    mut removed_depressed: RemovedComponents<Pressed>,
258    mut removed_disabled: RemovedComponents<InteractionDisabled>,
259    mut text_query: Query<&mut Text>,
260) {
261    removed_depressed
262        .read()
263        .chain(removed_disabled.read())
264        .for_each(|enti
...
```

Example 4 (javascript):
```javascript
283fn extract_image_materials_needing_specialization(
284    entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<ImageMaterial>>>,
285    mut entity_specialization_ticks: ResMut<EntitySpecializationTicks>,
286    mut removed_mesh_material_components: Extract<RemovedComponents<ImageMaterial3d>>,
287    mut specialized_material_pipeline_cache: ResMut<SpecializedMaterialPipelineCache>,
288    views: Query<&ExtractedView>,
289    ticks: SystemChangeTick,
290) {
291    // Clean up any despawned entities, we do this first in case the removed material was re-added
292    // the
...
```

---

## Enum AlphaMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AlphaMode.html

**Contents:**
- Enum AlphaMode Copy item path
- Variants§
  - Opaque
  - Mask(f32)
  - Blend
  - Premultiplied
  - AlphaToCoverage
  - Add
  - Multiply
- Trait Implementations§

Sets how a material’s base color alpha channel is used for transparency.

Base color alpha values are overridden to be fully opaque (1.0).

Reduce transparency to fully opaque or fully transparent based on a threshold.

Compares the base color alpha value to the specified threshold. If the value is below the threshold, considers the color to be fully transparent (alpha is set to 0.0). If it is equal to or above the threshold, considers the color to be fully opaque (alpha is set to 1.0).

The base color alpha value defines the opacity of the color. Standard alpha-blending is used to blend the fragment’s color with the color behind it.

Similar to AlphaMode::Blend, however assumes RGB channel values are premultiplied.

For otherwise constant RGB values, behaves more like AlphaMode::Blend for alpha values closer to 1.0, and more like AlphaMode::Add for alpha values closer to 0.0.

Can be used to avoid “border” or “outline” artifacts that can occur when using plain alpha-blended textures.

Spreads the fragment out over a hardware-dependent number of sample locations proportional to the alpha value. This requires multisample antialiasing; if MSAA isn’t on, this is identical to AlphaMode::Mask with a value of 0.5.

Alpha to coverage provides improved performance and better visual fidelity over AlphaMode::Blend, as Bevy doesn’t have to sort objects when it’s in use. It’s especially useful for complex transparent objects like foliage.

Combines the color of the fragments with the colors behind them in an additive process, (i.e. like light) producing lighter results.

Black produces no effect. Alpha values can be used to modulate the result.

Useful for effects like holograms, ghosts, lasers and other energy beams.

Combines the color of the fragments with the colors behind them in a multiplicative process, (i.e. like pigments) producing darker results.

White produces no effect. Alpha values can be used to modulate the result.

Useful for effects like stained glass, window tint film and some colored liquids.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AlphaMode {
    Opaque,
    Mask(f32),
    Blend,
    Premultiplied,
    AlphaToCoverage,
    Add,
    Multiply,
}
```

---

## Struct BVec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BVec2.html

**Contents:**
- Struct BVec2 Copy item path
- Fields§
- Implementations§
  - impl BVec2
    - pub const FALSE: BVec2
    - pub const TRUE: BVec2
    - pub const fn new(x: bool, y: bool) -> BVec2
    - pub const fn splat(v: bool) -> BVec2
    - pub const fn from_array(a: [bool; 2]) -> BVec2
    - pub fn bitmask(self) -> u32

A 2-dimensional bool vector mask.

Creates a new vector mask.

Creates a vector mask with all elements set to v.

Creates a new vector mask from a bool array.

Returns a bitmask with the lowest 2 bits set from the elements of self.

A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc.

Returns true if any of the elements are true, false otherwise.

Returns true if all the elements are true, false otherwise.

Tests the value at index.

Panics if index is greater than 1.

Sets the element at index.

Panics if index is greater than 1.

Deserialize expects a sequence of 2 values.

Serialize as a sequence of 2 values.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C, align(1))]pub struct BVec2 {
    pub x: bool,
    pub y: bool,
}
```

---

## Struct Scene Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Scene.html

**Contents:**
- Struct Scene Copy item path
- Fields§
- Implementations§
  - impl Scene
    - pub fn new(world: World) -> Scene
    - pub fn from_dynamic_scene( dynamic_scene: &DynamicScene, type_registry: &AppTypeRegistry, ) -> Result<Scene, SceneSpawnError>
    - pub fn clone_with( &self, type_registry: &AppTypeRegistry, ) -> Result<Scene, SceneSpawnError>
    - pub fn write_to_world_with( &self, world: &mut World, entity_map: &mut EntityHashMap<Entity>, type_registry: &AppTypeRegistry, ) -> Result<(), SceneSpawnError>
- Trait Implementations§
  - impl Debug for Scene

A composition of World objects.

To spawn a scene, you can use either:

The world of the scene, containing its entities and resources.

Creates a new scene with the given world.

Create a new scene from a given dynamic scene.

This method will return a SceneSpawnError if a type either is not registered in the provided AppTypeRegistry or doesn’t reflect the Component trait.

Write the entities and their corresponding components to the given world.

This method will return a SceneSpawnError if a type either is not registered in the provided AppTypeRegistry or doesn’t reflect the Component trait.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Scene {
    pub world: World,
}
```

---

## Struct Out Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Out.html

**Contents:**
- Struct Out Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Out
    - fn clone(&self) -> Out
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Out
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Out
    - type This<'from_arg> = Out

Fires when a pointer crosses out of the bounds of the target entity.

Information about the latest prior picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Out {
    pub hit: HitData,
}
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/gltf/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§

This includes the most common types in this crate, re-exported for your convenience.

---

## Derive Macro Message Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Message.html

**Contents:**
- Derive Macro Message Copy item path

Implement the Message trait.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Message)]
```

---

## Struct TextColor Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextColor.html

**Contents:**
- Struct TextColor Copy item path
- Tuple Fields§
- Implementations§
  - impl TextColor
    - pub const BLACK: TextColor
    - pub const WHITE: TextColor
- Methods from Deref<Target = Color>§
    - pub const WHITE: Color
    - pub const BLACK: Color
    - pub const NONE: Color

The color of the text for this section.

Return the color as a linear RGBA color.

Return the color as an SRGBA color.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextColor(pub Color);
```

Example 2 (javascript):
```javascript
90fn animate(
91    mut materials: ResMut<Assets<CustomUiMaterial>>,
92    q: Query<&MaterialNode<CustomUiMaterial>>,
93    time: Res<Time>,
94) {
95    let duration = 2.0;
96    for handle in &q {
97        if let Some(material) = materials.get_mut(handle) {
98            // rainbow color effect
99            let new_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 1., 0.5);
100            let border_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 0.75, 0.75);
101            material.color = new_color.to_linear().to_vec4();
102            material.slider.x =
103              
...
```

Example 3 (unknown):
```unknown
228fn spawn_light_textures(
229    commands: &mut Commands,
230    asset_server: &AssetServer,
231    meshes: &mut Assets<Mesh>,
232    materials: &mut Assets<StandardMaterial>,
233) {
234    commands.spawn((
235        SpotLight {
236            color: Color::srgb(1.0, 1.0, 0.8),
237            intensity: 10e6,
238            outer_angle: 0.25,
239            inner_angle: 0.25,
240            shadows_enabled: true,
241            ..default()
242        },
243        Transform::from_translation(Vec3::new(6.0, 1.0, 2.0)).looking_at(Vec3::ZERO, Vec3::Y),
244        SpotLightTexture {
245        
...
```

Example 4 (unknown):
```unknown
104fn update_colors(
105    keyboard_input: Res<ButtonInput<KeyCode>>,
106    mut config: ResMut<Wireframe2dConfig>,
107    mut wireframe_colors: Query<&mut Wireframe2dColor>,
108    mut text: Single<&mut Text>,
109) {
110    text.0 = format!(
111        "Controls
112---------------
113Z - Toggle global
114X - Change global color
115C - Change color of the circle wireframe
116
117Wireframe2dConfig
118-------------
119Global: {}
120Color: {:?}",
121        config.global,
122        config.default_color.to_srgba(),
123    );
124
125    // Toggle showing a wireframe on all meshes
126    if keyboa
...
```

---

## Crate bevy Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/

**Contents:**
- Crate bevy Copy item path
  - §Example
  - §This Crate
  - §Cargo Features
    - §Default Features
    - §Optional Features
- Modules§
- Structs§

Bevy is an open-source modular game engine built in Rust, with a focus on developer productivity and performance.

Check out the Bevy website for more information, read the Quick Start Guide for a step-by-step introduction, and engage with our community if you have any questions or ideas!

Here is a simple “Hello World” Bevy app:

Don’t let the simplicity of the example above fool you. Bevy is a fully featured game engine and it gets more powerful every day!

The bevy crate is just a container crate that makes it easier to consume Bevy subcrates. The defaults provide a “full” engine experience, but you can easily enable / disable features in your project’s Cargo.toml to meet your specific needs. See Bevy’s Cargo.toml for a full list of features available.

If you prefer, you can also consume the individual bevy crates directly. Each module in the root of this crate, except for the prelude, can be found on crates.io with bevy_ appended to the front, e.g. app -> bevy_app.

Bevy exposes many features to customize the engine. Enabling them add functionalities but often come at the cost of longer compilation times and extra dependencies.

The default feature set enables most of the expected features of a game engine, like rendering in both 2D and 3D, asset loading, audio and UI. To help reduce compilation time, consider disabling default features and enabling only those you need.

**Examples:**

Example 1 (unknown):
```unknown
use bevy::prelude::*;

fn main() {
   App::new()
       .add_systems(Update, hello_world_system)
       .run();
}

fn hello_world_system() {
   println!("hello world");
}
```

---

## Struct ReflectState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectState.html

**Contents:**
- Struct ReflectState Copy item path
- Implementations§
  - impl ReflectState
    - pub fn reflect<'a>( &self, world: &'a World, ) -> Option<&'a (dyn Reflect + 'static)>
- Trait Implementations§
  - impl Clone for ReflectState
    - fn clone(&self) -> ReflectState
    - fn clone_from(&mut self, source: &Self)
  - impl<S> FromType<S> for ReflectStatewhere S: States + Reflect,
    - fn from_type() -> ReflectState

A struct used to operate on the reflected States trait of a type.

A ReflectState for type T can be obtained via bevy_reflect::TypeRegistration::data.

Gets the value of this States type from the world as a reflected reference.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectState(/* private fields */);
```

---

## Struct RepeatCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RepeatCurve.html

**Contents:**
- Struct RepeatCurve Copy item path
- §Notes
- §Domain
- Trait Implementations§
  - impl<T, C> Clone for RepeatCurve<T, C>where T: Clone, C: Clone,
    - fn clone(&self) -> RepeatCurve<T, C>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C> Curve<T> for RepeatCurve<T, C>where C: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T

The curve that results from repeating a curve N times.

Curves of this type are produced by CurveExt::repeat.

The original curve’s domain must be bounded to get a valid RepeatCurve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RepeatCurve<T, C> { /* private fields */ }
```

---

## Macro trace_once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.trace_once.html

**Contents:**
- Macro trace_once Copy item path

Call trace! once per call site.

Useful for logging within systems which are called every frame.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! trace_once {
    ($($arg:tt)+) => { ... };
}
```

---

## Struct Replace Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Replace.html

**Contents:**
- Struct Replace Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Replace
    - fn clone(&self) -> Replace
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Replace
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl EntityEvent for Replacewhere Replace: Send + Sync + 'static,
    - fn event_target(&self) -> Entity

Trigger emitted when a component is removed from an entity, regardless of whether or not it is later replaced.

Runs before the value is replaced, so you can still access the original component data. See ComponentHooks::on_replace for more information.

The entity that held this component before it was replaced.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Replace {
    pub entity: Entity,
}
```

---

## Trait Measured2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Measured2d.html

**Contents:**
- Trait Measured2d Copy item path
- Required Methods§
    - fn perimeter(&self) -> f32
    - fn area(&self) -> f32
- Implementors§
  - impl Measured2d for Annulus
  - impl Measured2d for Capsule2d
  - impl Measured2d for Circle
  - impl Measured2d for CircularSector
  - impl Measured2d for CircularSegment

A trait for getting measurements of 2D shapes

Get the perimeter of the shape

Get the area of the shape

**Examples:**

Example 1 (unknown):
```unknown
pub trait Measured2d {
    // Required methods
    fn perimeter(&self) -> f32;
    fn area(&self) -> f32;
}
```

---

## Enum ImageFormat Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ImageFormat.html

**Contents:**
- Enum ImageFormat Copy item path
- Variants§
  - Basis
  - Bmp
  - Dds
  - Farbfeld
  - Gif
  - OpenExr
  - Hdr
  - Ico

Gets the file extensions for a given format.

Gets the MIME types for a given format.

If a format doesn’t have any dedicated MIME types, this list will be empty.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ImageFormat {
Show 16 variants    Basis,
    Bmp,
    Dds,
    Farbfeld,
    Gif,
    OpenExr,
    Hdr,
    Ico,
    Jpeg,
    Ktx2,
    Png,
    Pnm,
    Qoi,
    Tga,
    Tiff,
    WebP,
}
```

---

## Crate ctrlc Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/ctrlc/index.html

**Contents:**
- Crate ctrlc Copy item path
- §Example
- §Handling SIGTERM and SIGHUP
- Enums§
- Functions§
- Type Aliases§

Cross platform handling of Ctrl-C signals.

set_handler() allows setting a handler closure which is executed on Ctrl+C. On Unix, this corresponds to a SIGINT signal. On windows, Ctrl+C corresponds to CTRL_C_EVENT or CTRL_BREAK_EVENT.

Setting a handler will start a new dedicated signal handling thread where we execute the handler each time we receive a Ctrl+C signal. There can only be one handler, you would typically set one at the start of your program.

Handling of SIGTERM and SIGHUP can be enabled with termination feature. If this is enabled, the handler specified by set_handler() will be executed for SIGINT, SIGTERM and SIGHUP.

**Examples:**

Example 1 (javascript):
```javascript
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

fn main() {
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    ctrlc::set_handler(move || {
        r.store(false, Ordering::SeqCst);
    }).expect("Error setting Ctrl-C handler");

    println!("Waiting for Ctrl-C...");
    while running.load(Ordering::SeqCst) {}
    println!("Got it! Exiting...");
}
```

---

## Function vmin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vmin.html

**Contents:**
- Function vmin Copy item path
      - Examples found in repository?

Returns a Val::VMin representing a percentage of the viewport’s smaller dimension.

**Examples:**

Example 1 (unknown):
```unknown
pub fn vmin<T>(value: T) -> Valwhere
    T: ValNum,
```

Example 2 (javascript):
```javascript
152fn setup_flex(mut commands: Commands, asset_server: Res<AssetServer>, args: Res<Args>) {
153    let images = if 0 < args.image_freq {
154        Some(vec![
155            asset_server.load("branding/icon.png"),
156            asset_server.load("textures/Game Icons/wrench.png"),
157        ])
158    } else {
159        None
160    };
161
162    let buttons_f = args.buttons as f32;
163    let border = if args.no_borders {
164        UiRect::ZERO
165    } else {
166        UiRect::all(vmin(0.05 * 90. / buttons_f))
167    };
168
169    let as_rainbow = |i: usize| Color::hsl((i as f32 / buttons_
...
```

Example 3 (unknown):
```unknown
68fn spawn_with_viewport_coords(commands: &mut Commands) {
69    commands
70        .spawn((
71            Node {
72                width: vw(100),
73                height: vh(100),
74                border: UiRect::axes(vw(5), vh(5)),
75                flex_wrap: FlexWrap::Wrap,
76                ..default()
77            },
78            BorderColor::all(PALETTE[0]),
79            Coords::Viewport,
80        ))
81        .with_children(|builder| {
82            builder.spawn((
83                Node {
84                    width: vw(30),
85                    height: vh(30),
86             
...
```

Example 4 (javascript):
```javascript
31fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
32    // Camera
33    commands.spawn((Camera2d, IsDefaultUiCamera, BoxShadowSamples(6)));
34
35    // root node
36    commands
37        .spawn(Node {
38            width: percent(100),
39            height: percent(100),
40            justify_content: JustifyContent::SpaceBetween,
41            ..default()
42        })
43        .insert(Pickable::IGNORE)
44        .with_children(|parent| {
45            // left vertical fill (border)
46            parent
47                .spawn((
48                    Node {
49             
...
```

---

## Macro trace Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.trace.html

**Contents:**
- Macro trace Copy item path
- §Examples

Constructs an event at the trace level.

This functions similarly to the event! macro. See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! trace {
    (name: $name:expr, target: $target:expr, parent: $parent:expr, { $($field:tt)* }, $($arg:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, ?$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, %$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($arg:tt)+ ) => { ... };
    (name: $name:expr, target: $target:expr, 
...
```

Example 2 (javascript):
```javascript
use tracing::trace;
let pos = Position { x: 3.234, y: -1.223 };
let origin_dist = pos.dist(Position::ORIGIN);

trace!(position = ?pos, ?origin_dist);
trace!(
    target: "app_events",
    position = ?pos,
    "x is {} and y is {}",
    if pos.x >= 0.0 { "positive" } else { "negative" },
    if pos.y >= 0.0 { "positive" } else { "negative" }
);
trace!(name: "completed", position = ?pos);
```

---

## Struct AnimatableKeyframeCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimatableKeyframeCurve.html

**Contents:**
- Struct AnimatableKeyframeCurve Copy item path
- Implementations§
  - impl<T> AnimatableKeyframeCurve<T>where T: Animatable,
    - pub fn new( keyframes: impl IntoIterator<Item = (f32, T)>, ) -> Result<AnimatableKeyframeCurve<T>, UnevenCoreError>
      - Examples found in repository?
- Trait Implementations§
  - impl<T> Clone for AnimatableKeyframeCurve<T>where T: Clone,
    - fn clone(&self) -> AnimatableKeyframeCurve<T>
    - fn clone_from(&mut self, source: &Self)
  - impl<T> Curve<T> for AnimatableKeyframeCurve<T>where T: Animatable + Clone,

A curve defined by keyframes with values in an animatable type.

The keyframes are interpolated using the type’s Animatable::interpolate implementation.

Create a new AnimatableKeyframeCurve from the given keyframes. The values of this curve are interpolated from the keyframes using the output type’s implementation of Animatable::interpolate.

There must be at least two samples in order for this method to succeed.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimatableKeyframeCurve<T> { /* private fields */ }
```

Example 2 (javascript):
```javascript
36    fn create(
37        animation_graphs: &mut Assets<AnimationGraph>,
38        animation_clips: &mut Assets<AnimationClip>,
39    ) -> AnimationInfo {
40        // Create an ID that identifies the text node we're going to animate.
41        let animation_target_name = Name::new("Text");
42        let animation_target_id = AnimationTargetId::from_name(&animation_target_name);
43
44        // Allocate an animation clip.
45        let mut animation_clip = AnimationClip::default();
46
47        // Create a curve that animates font size.
48        animation_clip.add_curve_to_target(
49        
...
```

---

## Struct RawHandleWrapperHolder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/window/struct.RawHandleWrapperHolder.html

**Contents:**
- Struct RawHandleWrapperHolder Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for RawHandleWrapperHolder
    - fn clone(&self) -> RawHandleWrapperHolder
    - fn clone_from(&mut self, source: &Self)
  - impl Component for RawHandleWrapperHolderwhere RawHandleWrapperHolder: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Holder of the RawHandleWrapper with wrappers, to allow use in asynchronous context

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RawHandleWrapperHolder(pub Arc<Mutex<Option<RawHandleWrapper>>>);
```

---

## Struct QuarticOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuarticOutCurve.html

**Contents:**
- Struct QuarticOutCurve Copy item path
- Trait Implementations§
  - impl Clone for QuarticOutCurve
    - fn clone(&self) -> QuarticOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuarticOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = (t - 1.0)³ * (1.0 - t) + 1.0

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuarticOutCurve;
```

---

## Trait DetectChanges Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.DetectChanges.html

**Contents:**
- Trait DetectChanges Copy item path
  - §Example
- Required Methods§
    - fn is_added(&self) -> bool
    - fn is_changed(&self) -> bool
    - fn last_changed(&self) -> Tick
    - fn added(&self) -> Tick
    - fn changed_by(&self) -> MaybeLocation
- Implementors§
  - impl<'w> DetectChanges for MutUntyped<'w>

Types that can read change detection information. This change detection is controlled by DetectChangesMut types such as ResMut.

Using types that implement DetectChanges, such as Res, provide a way to query if a value has been mutated in another system.

Returns true if this value was added after the system last ran.

Returns true if this value was added or mutably dereferenced either since the last time the system ran or, if the system never ran, since the beginning of the program.

To check if the value was mutably dereferenced only, use this.is_changed() && !this.is_added().

Returns the change tick recording the time this data was most recently changed.

Note that components and resources are also marked as changed upon insertion.

For comparison, the previous change tick of a system can be read using the SystemChangeTick SystemParam.

Returns the change tick recording the time this data was added.

The location that last caused this to change.

**Examples:**

Example 1 (unknown):
```unknown
pub trait DetectChanges {
    // Required methods
    fn is_added(&self) -> bool;
    fn is_changed(&self) -> bool;
    fn last_changed(&self) -> Tick;
    fn added(&self) -> Tick;
    fn changed_by(&self) -> MaybeLocation;
}
```

Example 2 (unknown):
```unknown
use bevy_ecs::prelude::*;

#[derive(Resource)]
struct MyResource(u32);

fn my_system(mut resource: Res<MyResource>) {
    if resource.is_changed() {
        println!("My component was mutated!");
    }
}
```

---

## Struct SineOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SineOutCurve.html

**Contents:**
- Struct SineOutCurve Copy item path
- Trait Implementations§
  - impl Clone for SineOutCurve
    - fn clone(&self) -> SineOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SineOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = sin(t * π / 2.0)

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SineOutCurve;
```

---

## Struct ThreadedAnimationGraphs Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ThreadedAnimationGraphs.html

**Contents:**
- Struct ThreadedAnimationGraphs Copy item path
- Trait Implementations§
  - impl Default for ThreadedAnimationGraphs
    - fn default() -> ThreadedAnimationGraphs
  - impl FromArg for ThreadedAnimationGraphs
    - type This<'from_arg> = ThreadedAnimationGraphs
    - fn from_arg( arg: Arg<'_>, ) -> Result<<ThreadedAnimationGraphs as FromArg>::This<'_>, ArgError>
  - impl FromReflect for ThreadedAnimationGraphs
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<ThreadedAnimationGraphs>
    - fn take_from_reflect( reflect: Box<dyn PartialReflect>, ) -> Result<Self, Box<dyn PartialReflect>>

Acceleration structures for animation graphs that allows Bevy to evaluate them quickly.

These are kept up to date as AnimationGraph instances are added, modified, and removed.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ThreadedAnimationGraphs(/* private fields */);
```

---

## Trait Plugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/trait.Plugin.html

**Contents:**
- Trait Plugin Copy item path
  - §Lifecycle of a plugin
  - §Defining a plugin.
- Required Methods§
    - fn build(&self, app: &mut App)
- Provided Methods§
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

A collection of Bevy app logic and configuration.

Plugins configure an App. When an App registers a plugin, the plugin’s Plugin::build function is run. By default, a plugin can only be added once to an App.

If the plugin may need to be added twice or more, the function is_unique() should be overridden to return false. Plugins are considered duplicate if they have the same name(). The default name() implementation returns the type name, which means generic plugins with different type parameters will not be considered duplicates.

When adding a plugin to an App:

Most plugins are simply functions that add configuration to an App.

For more advanced use cases, the Plugin trait can be implemented manually for a type.

Configures the App to which this plugin is added.

Has the plugin finished its setup? This can be useful for plugins that need something asynchronous to happen before they can finish their setup, like the initialization of a renderer. Once the plugin is ready, finish should be called.

Finish adding this plugin to the App, once all plugins registered are ready. This can be useful for plugins that depends on another plugin asynchronous setup, like the renderer.

Runs after all plugins are built and finished, but before the app schedule is executed. This can be useful if you have some resource that other plugins need during their build step, but after build you want to remove it and send it to another thread.

Configures a name for the Plugin which is primarily used for checking plugin uniqueness and debugging.

If the plugin can be meaningfully instantiated several times in an App, override this method to return false.

Returns true if the trait object wraps an object of type __T.

Returns a boxed object from a boxed trait object if the underlying object is of type __T. Returns the original boxed trait if it isn’t.

Returns an Rc-ed object from an Rc-ed trait object if the underlying object is of type __T. Returns the original Rc-ed trait if it isn’t.

Returns a reference to the object within the trait object if it is of type __T, or None if it isn’t.

Returns a mutable reference to the object within the trait object if it is of type __T, or None if it isn’t.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Plugin:
    Downcast
    + Any
    + Send
    + Sync {
    // Required method
    fn build(&self, app: &mut App);

    // Provided methods
    fn ready(&self, _app: &App) -> bool { ... }
    fn finish(&self, _app: &mut App) { ... }
    fn cleanup(&self, _app: &mut App) { ... }
    fn name(&self) -> &str { ... }
    fn is_unique(&self) -> bool { ... }
}
```

Example 2 (unknown):
```unknown
App::new().add_plugins(my_plugin).run();

// This function implements `Plugin`, along with every other `fn(&mut App)`.
pub fn my_plugin(app: &mut App) {
    app.add_systems(Update, hello_world);
}
```

Example 3 (unknown):
```unknown
pub struct AccessibilityPlugin {
    pub flicker_damping: bool,
    // ...
}

impl Plugin for AccessibilityPlugin {
    fn build(&self, app: &mut App) {
        if self.flicker_damping {
            app.add_systems(PostUpdate, damp_flickering);
        }
    }
}
```

---

## Struct ExtractSchedule Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ExtractSchedule.html

**Contents:**
- Struct ExtractSchedule Copy item path
- Trait Implementations§
  - impl Clone for ExtractSchedule
    - fn clone(&self) -> ExtractSchedule
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ExtractSchedule
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for ExtractSchedule
    - fn default() -> ExtractSchedule
  - impl Hash for ExtractSchedule

Schedule which extract data from the main world and inserts it into the render world.

This step should be kept as short as possible to increase the “pipelining potential” for running the next frame while rendering the current frame.

This schedule is run on the main world, but its buffers are not applied until it is returned to the render world.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ExtractSchedule;
```

---

## Struct ButtonInput Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ButtonInput.html

**Contents:**
- Struct ButtonInput Copy item path
  - §Usage
  - §Multiple systems
  - §Performance
  - §Window focus
  - §Examples
  - §Note
- Implementations§
  - impl<T> ButtonInput<T>where T: Clone + Eq + Hash + Send + Sync + 'static,
    - pub fn press(&mut self, input: T)

A “press-able” input of type T.

This type can be used as a resource to keep the current state of an input, by reacting to events from the input. For a given input value:

In case multiple systems are checking for ButtonInput::just_pressed or ButtonInput::just_released but only one should react, for example when modifying a Resource, you should consider clearing the input state, either by:

For all operations, the following conventions are used:

See Rust’s std::collections doc on performance for more details on the conventions used here.

ButtonInput<KeyCode> is tied to window focus. For example, if the user holds a button while the window loses focus, ButtonInput::just_released will be triggered. Similarly if the window regains focus, ButtonInput::just_pressed will be triggered.

ButtonInput<GamepadButton> is independent of window focus.

Reading and checking against the current set of pressed buttons:

When adding this resource for a new input type, you should:

Note: Calling clear from a ResMut will trigger change detection. It may be preferable to use DetectChangesMut::bypass_change_detection to avoid causing the resource to always be marked as changed.

Registers a press for the given input.

Returns true if the input has been pressed.

Returns true if any item in inputs has been pressed.

Returns true if all items in inputs have been pressed.

Registers a release for the given input.

Registers a release for all currently pressed inputs.

Returns true if the input has been pressed during the current frame.

Note: This function does not imply information regarding the current state of ButtonInput::pressed or ButtonInput::just_released.

Returns true if any item in inputs has been pressed during the current frame.

Clears the just_pressed state of the input and returns true if the input has just been pressed.

Future calls to ButtonInput::just_pressed for the given input will return false until a new press event occurs.

Returns true if the input has been released during the current frame.

Note: This function does not imply information regarding the current state of ButtonInput::pressed or ButtonInput::just_pressed.

Returns true if any item in inputs has just been released.

Returns true if all items in inputs have just been released.

Returns true if all items in inputs have been just pressed.

Clears the just_released state of the input and returns true if the input has just been released.

Future calls to ButtonInput::just_released for the given 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct ButtonInput<T>where
    T: Clone + Eq + Hash + Send + Sync + 'static,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(
            Update,
            print_mouse.run_if(resource_changed::<ButtonInput<MouseButton>>),
        )
        .add_systems(
            Update,
            print_keyboard.run_if(resource_changed::<ButtonInput<KeyCode>>),
        )
        .run();
}

fn print_mouse(mouse: Res<ButtonInput<MouseButton>>) {
    println!("Mouse: {:?}", mouse.get_pressed().collect::<Vec<_>>());
}

fn print_keyboard(keyboard: Res<ButtonInput<KeyCode>>) {
    if keyboard.any_pressed([KeyCode::ControlLeft, KeyCode::ControlRight]
...
```

Example 3 (unknown):
```unknown
74fn transition_to_in_game_system(
75    mut next_state: ResMut<NextState<AppState>>,
76    keyboard_input: Res<ButtonInput<KeyCode>>,
77) {
78    if keyboard_input.pressed(KeyCode::Space) {
79        next_state.set(AppState::InGame);
80    }
81}
```

Example 4 (unknown):
```unknown
136fn trigger_hooks(
137    mut commands: Commands,
138    keys: Res<ButtonInput<KeyCode>>,
139    index: Res<MyComponentIndex>,
140) {
141    for (key, entity) in index.iter() {
142        if !keys.pressed(*key) {
143            commands.entity(*entity).remove::<MyComponent>();
144        }
145    }
146    for key in keys.get_just_pressed() {
147        commands.spawn(MyComponent(*key));
148    }
149}
```

---

## Type Alias OnDespawn Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.OnDespawn.html

**Contents:**
- Type Alias OnDespawn Copy item path
- Aliased Type§
- Fields§

Deprecated in favor of Despawn.

The entity that held this component before it was despawned.

**Examples:**

Example 1 (unknown):
```unknown
pub type OnDespawn = Despawn;
```

Example 2 (unknown):
```unknown
pub struct OnDespawn {
    pub entity: Entity,
}
```

---

## Trait GetField Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.GetField.html

**Contents:**
- Trait GetField Copy item path
- §Example
- Required Methods§
    - fn get_field<T>(&self, name: &str) -> Option<&T>where T: Reflect,
    - fn get_field_mut<T>(&mut self, name: &str) -> Option<&mut T>where T: Reflect,
- Dyn Compatibility§
- Implementors§
  - impl GetField for dyn Struct
  - impl<S> GetField for Swhere S: Struct,

A convenience trait which combines fetching and downcasting of struct fields.

Returns a reference to the value of the field named name, downcast to T.

Returns a mutable reference to the value of the field named name, downcast to T.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait GetField {
    // Required methods
    fn get_field<T>(&self, name: &str) -> Option<&T>
       where T: Reflect;
    fn get_field_mut<T>(&mut self, name: &str) -> Option<&mut T>
       where T: Reflect;
}
```

Example 2 (javascript):
```javascript
use bevy_reflect::{GetField, Reflect};

#[derive(Reflect)]
struct Foo {
    bar: String,
}

let mut foo = Foo { bar: "Hello, world!".to_string() };

foo.get_field_mut::<String>("bar").unwrap().truncate(5);
assert_eq!(foo.get_field::<String>("bar"), Some(&"Hello".to_string()));
```

---

## Module light_consts Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/light_consts/index.html

**Contents:**
- Module light_consts Copy item path
- Modules§

Constants for operating with the light units: lumens, and lux.

---

## Struct FixedUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedUpdate.html

**Contents:**
- Struct FixedUpdate Copy item path
- Trait Implementations§
  - impl Clone for FixedUpdate
    - fn clone(&self) -> FixedUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedUpdate
    - fn default() -> FixedUpdate
  - impl Hash for FixedUpdate

The schedule that contains most gameplay logic, which runs at a fixed rate rather than every render frame. For logic that should run once per render frame, use the Update schedule instead.

Examples of systems that should run at a fixed rate include (but are not limited to):

See the Update schedule for examples of systems that should not use this schedule. See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedUpdate;
```

---

## Struct RegularPolygon Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RegularPolygon.html

**Contents:**
- Struct RegularPolygon Copy item path
- Fields§
- Implementations§
  - impl RegularPolygon
    - pub const fn new(circumradius: f32, sides: u32) -> RegularPolygon
      - §Panics
      - Examples found in repository?
    - pub const fn circumradius(&self) -> f32
    - pub fn inradius(&self) -> f32
    - pub fn side_length(&self) -> f32

A polygon centered on the origin where all vertices lie on a circle, equally far apart.

The circumcircle on which all vertices lie

Create a new RegularPolygon from the radius of the circumcircle and a number of sides

Panics if circumradius is negative

Get the radius of the circumcircle on which all vertices of the regular polygon lie

Get the inradius or apothem of the regular polygon. This is the radius of the largest circle that can be drawn within the polygon

Get the length of one side of the regular polygon

Get the internal angle of the regular polygon in degrees.

This is the angle formed by two adjacent sides with points within the angle being in the interior of the polygon

Get the internal angle of the regular polygon in radians.

This is the angle formed by two adjacent sides with points within the angle being in the interior of the polygon

Get the external angle of the regular polygon in degrees.

This is the angle formed by two adjacent sides with points within the angle being in the exterior of the polygon

Get the external angle of the regular polygon in radians.

This is the angle formed by two adjacent sides with points within the angle being in the exterior of the polygon

Returns an iterator over the vertices of the regular polygon, rotated counterclockwise by the given angle in radians.

With a rotation of 0, a vertex will be placed at the top (0.0, circumradius).

Returns the default RegularPolygon with six sides (a hexagon) and a circumradius of 0.5.

Get the area of the regular polygon

Get the perimeter of the regular polygon. This is the sum of its sides

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RegularPolygon {
    pub circumcircle: Circle,
    pub sides: u32,
}
```

Example 2 (javascript):
```javascript
104fn setup_scene(
105    mut commands: Commands,
106    mut meshes: ResMut<Assets<Mesh>>,
107    mut materials: ResMut<Assets<ColorMaterial>>,
108) {
109    commands.spawn(Camera2d);
110
111    let named_shapes = [
112        (Name::new("Annulus"), meshes.add(Annulus::new(25.0, 50.0))),
113        (
114            Name::new("Bestagon"),
115            meshes.add(RegularPolygon::new(50.0, 6)),
116        ),
117        (Name::new("Rhombus"), meshes.add(Rhombus::new(75.0, 100.0))),
118    ];
119    let num_shapes = named_shapes.len();
120
121    for (i, (name, shape)) in named_shapes.into_iter()
...
```

Example 3 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 4 (unknown):
```unknown
202fn setup(mut commands: Commands) {
203    commands.spawn(Camera2d);
204
205    commands.spawn((
206        Transform::from_xyz(-OFFSET_X, OFFSET_Y, 0.),
207        Shape::Circle(Circle::new(45.)),
208        DesiredVolume::Aabb,
209        Intersects::default(),
210    ));
211
212    commands.spawn((
213        Transform::from_xyz(0., OFFSET_Y, 0.),
214        Shape::Rectangle(Rectangle::new(80., 80.)),
215        Spin,
216        DesiredVolume::Circle,
217        Intersects::default(),
218    ));
219
220    commands.spawn((
221        Transform::from_xyz(OFFSET_X, OFFSET_Y, 0.),
222       
...
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct DespawnOnEnter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DespawnOnEnter.html

**Contents:**
- Struct DespawnOnEnter Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<S> Clone for DespawnOnEnter<S>where S: Clone + States,
    - fn clone(&self) -> DespawnOnEnter<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Component for DespawnOnEnter<S>where S: States, DespawnOnEnter<S>: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Entities marked with this component will be despawned upon entering the given state.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DespawnOnEnter<S>(pub S)
where
    S: States;
```

Example 2 (unknown):
```unknown
use bevy_state::prelude::*;
use bevy_ecs::{prelude::*, system::ScheduleSystem};

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Default, States)]
enum GameState {
    #[default]
    MainMenu,
    SettingsMenu,
    InGame,
}


fn spawn_player(mut commands: Commands) {
    commands.spawn((
        DespawnOnEnter(GameState::MainMenu),
        Player
    ));
}


app.init_state::<GameState>();
app.add_systems(OnEnter(GameState::InGame), spawn_player);
```

---

## Struct In Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.In.html

**Contents:**
- Struct In Copy item path
- §Examples
- Tuple Fields§
- Trait Implementations§
  - impl<T> Debug for In<T>where T: Debug,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<T> Deref for In<T>
    - type Target = T
    - fn deref(&self) -> &<In<T> as Deref>::Target
  - impl<T> DerefMut for In<T>

A SystemInput type which denotes that a System receives an input value of type T from its caller.

Systems may take an optional input which they require to be passed to them when they are being run. For FunctionSystems the input may be marked with this In type, but only the first param of a function may be tagged as an input. This also means a system can only have one or zero input parameters.

See SystemInput to learn more about system inputs in general.

Here is a simple example of a system that takes a usize and returns the square of it.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct In<T>(pub T);
```

Example 2 (javascript):
```javascript
fn square(In(input): In<usize>) -> usize {
    input * input
}

let mut world = World::new();
let mut square_system = IntoSystem::into_system(square);
square_system.initialize(&mut world);

assert_eq!(square_system.run(12, &mut world).unwrap(), 144);
```

---

## Function uvec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.uvec3.html

**Contents:**
- Function uvec3 Copy item path
      - Examples found in repository?

Creates a 3-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn uvec3(x: u32, y: u32, z: u32) -> UVec3
```

Example 2 (javascript):
```javascript
525fn create_cubes(
526    image_assets: Res<Assets<Image>>,
527    mut commands: Commands,
528    irradiance_volumes: Query<(&IrradianceVolume, &GlobalTransform)>,
529    voxel_cube_parents: Query<Entity, With<VoxelCubeParent>>,
530    voxel_cubes: Query<Entity, With<VoxelCube>>,
531    example_assets: Res<ExampleAssets>,
532    mut voxel_visualization_material_assets: ResMut<Assets<VoxelVisualizationMaterial>>,
533) {
534    // If voxel cubes have already been spawned, don't do anything.
535    if !voxel_cubes.is_empty() {
536        return;
537    }
538
539    let Some(voxel_cube_parent) = 
...
```

---

## Derive Macro TypePath Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.TypePath.html

**Contents:**
- Derive Macro TypePath Copy item path
- §Container Attributes
  - §#[type_path = "my_crate::foo"]
  - §#[type_name = "RenamedType"]

Derives the TypePath trait, providing a stable alternative to [std::any::type_name].

Optionally specifies a custom module path to use instead of [module_path].

This path does not include the final identifier.

Optionally specifies a new terminating identifier for TypePath.

To use this attribute, #[type_path = "..."] must also be specified.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(TypePath)]
{
    // Attributes available to this derive:
    #[type_path]
    #[type_name]
}
```

---

## Trait Alpha Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Alpha.html

**Contents:**
- Trait Alpha Copy item path
- Required Methods§
    - fn with_alpha(&self, alpha: f32) -> Self
    - fn alpha(&self) -> f32
    - fn set_alpha(&mut self, alpha: f32)
- Provided Methods§
    - fn is_fully_transparent(&self) -> bool
    - fn is_fully_opaque(&self) -> bool
- Dyn Compatibility§
- Implementations on Foreign Types§

Methods for manipulating alpha values.

Return a new version of this color with the given alpha value.

Return the alpha component of this color.

Sets the alpha component of this color.

Is the alpha component of this color less than or equal to 0.0?

Is the alpha component of this color greater than or equal to 1.0?

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Alpha: Sized {
    // Required methods
    fn with_alpha(&self, alpha: f32) -> Self;
    fn alpha(&self) -> f32;
    fn set_alpha(&mut self, alpha: f32);

    // Provided methods
    fn is_fully_transparent(&self) -> bool { ... }
    fn is_fully_opaque(&self) -> bool { ... }
}
```

---

## Struct WindowMoved Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.WindowMoved.html

**Contents:**
- Struct WindowMoved Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for WindowMoved
    - fn clone(&self) -> WindowMoved
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for WindowMoved
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'de> Deserialize<'de> for WindowMoved
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<WindowMoved, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,

An event that is sent when a window is repositioned in physical pixels.

Where the window moved to in physical pixels.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WindowMoved {
    pub window: Entity,
    pub position: IVec2,
}
```

---

## Struct TextureAtlasLayout Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/image/struct.TextureAtlasLayout.html

**Contents:**
- Struct TextureAtlasLayout Copy item path
- Fields§
- Implementations§
  - impl TextureAtlasLayout
    - pub fn new_empty(dimensions: UVec2) -> TextureAtlasLayout
    - pub fn from_grid( tile_size: UVec2, columns: u32, rows: u32, padding: Option<UVec2>, offset: Option<UVec2>, ) -> TextureAtlasLayout
      - §Arguments
      - Examples found in repository?
    - pub fn add_texture(&mut self, rect: URect) -> usize
      - §Arguments

Stores a map used to lookup the position of a texture in a TextureAtlas. This can be used to either use and look up a specific section of a texture, or animate frame-by-frame as a sprite sheet.

Optionally it can store a mapping from sub texture handles to the related area index (see TextureAtlasBuilder).

Example usage animating sprite. Example usage animating sprite in response to an event. Example usage loading sprite sheet.

Total size of texture atlas.

The specific areas of the atlas where each texture can be found

Create a new empty layout with custom dimensions

Generate a TextureAtlasLayout as a grid where each tile_size by tile_size grid-cell is one of the section in the atlas. Grid cells are separated by some padding, and the grid starts at offset pixels from the top left corner. Resulting layout is indexed left to right, top to bottom.

Add a section to the list in the layout and returns its index which can be used with TextureAtlas

The number of textures in the TextureAtlasLayout

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureAtlasLayout {
    pub size: UVec2,
    pub textures: Vec<URect>,
}
```

Example 2 (javascript):
```javascript
42fn setup(
43    mut commands: Commands,
44    asset_server: Res<AssetServer>,
45    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
46) {
47    let texture = asset_server.load("textures/rpg/chars/gabe/gabe-idle-run.png");
48    let layout = TextureAtlasLayout::from_grid(UVec2::splat(24), 7, 1, None, None);
49    let texture_atlas_layout = texture_atlas_layouts.add(layout);
50    // Use only the subset of sprites in the sheet that make up the run animation
51    let animation_indices = AnimationIndices { first: 1, last: 6 };
52
53    commands.spawn(Camera2d);
54
55    commands.
...
```

Example 3 (javascript):
```javascript
122fn setup_atlas(
123    mut commands: Commands,
124    asset_server: Res<AssetServer>,
125    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
126) {
127    let texture_handle = asset_server.load("textures/rpg/chars/gabe/gabe-idle-run.png");
128    let layout = TextureAtlasLayout::from_grid(UVec2::new(24, 24), 7, 1, None, None);
129    let texture_atlas_layout_handle = texture_atlas_layouts.add(layout);
130    // Use only the subset of sprites in the sheet that make up the run animation
131    let animation_indices = AnimationIndices { first: 1, last: 6 };
132    commands
133  
...
```

Example 4 (javascript):
```javascript
31fn setup_cursor_icon(
32    mut commands: Commands,
33    asset_server: Res<AssetServer>,
34    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
35    window: Single<Entity, With<Window>>,
36) {
37    let layout =
38        TextureAtlasLayout::from_grid(UVec2::splat(64), 20, 10, Some(UVec2::splat(5)), None);
39    let texture_atlas_layout = texture_atlas_layouts.add(layout);
40
41    let animation_config = AnimationConfig::new(0, 199, 1, 4);
42
43    commands.entity(*window).insert((
44        CursorIcon::Custom(CustomCursor::Image(CustomCursorImage {
45            // Image to 
...
```

---

## Trait FromRng Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.FromRng.html

**Contents:**
- Trait FromRng Copy item path
- Provided Methods§
    - fn from_rng<R>(rng: &mut R) -> Selfwhere R: Rng + ?Sized,
- Dyn Compatibility§
- Implementors§
  - impl FromRng for Dir2
  - impl FromRng for Dir3
  - impl FromRng for Dir3A
  - impl FromRng for Quat
  - impl FromRng for Rot2

Ergonomics trait for a type with a StandardUniform distribution, allowing values to be generated uniformly from an Rng by a method in its own namespace.

Construct a value of this type uniformly at random using rng as the source of randomness.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait FromRng: Sizedwhere
    StandardUniform: Distribution<Self>,{
    // Provided method
    fn from_rng<R>(rng: &mut R) -> Self
       where R: Rng + ?Sized { ... }
}
```

Example 2 (javascript):
```javascript
let mut rng = StdRng::seed_from_u64(451);
let random_dir = Dir3::from_rng(&mut rng);
```

---

## Struct Ray2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Ray2d.html

**Contents:**
- Struct Ray2d Copy item path
- Fields§
- Implementations§
  - impl Ray2d
    - pub const fn new(origin: Vec2, direction: Dir2) -> Ray2d
    - pub fn get_point(&self, distance: f32) -> Vec2
    - pub fn intersect_plane(&self, plane_origin: Vec2, plane: Plane2d) -> Option<f32>
- Trait Implementations§
  - impl Clone for Ray2d
    - fn clone(&self) -> Ray2d

An infinite half-line starting at origin and going in direction in 2D space.

The origin of the ray.

The direction of the ray.

Create a new Ray2d from a given origin and direction

Get a point at a given distance along the ray

Get the distance to a plane if the ray intersects it

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Ray2d {
    pub origin: Vec2,
    pub direction: Dir2,
}
```

---

## Struct GridPlacement Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GridPlacement.html

**Contents:**
- Struct GridPlacement Copy item path
- Implementations§
  - impl GridPlacement
    - pub const DEFAULT: GridPlacement
    - pub fn auto() -> GridPlacement
    - pub fn span(span: u16) -> GridPlacement
      - §Panics
      - Examples found in repository?
    - pub fn start(start: i16) -> GridPlacement
      - §Panics

Represents the position of a grid item in a single axis.

There are 3 fields which may be set:

The default span is 1. If neither start or end is set then the item will be placed automatically.

Generally, at most two fields should be set. If all three fields are specified then span will be ignored. If end specifies an earlier grid line than start then end will be ignored and the item will have a span of 1.

https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid

Place the grid item automatically (letting the span default to 1).

Place the grid item automatically, specifying how many tracks it should span.

Place the grid item specifying the start grid line (letting the span default to 1).

Panics if start is 0.

Place the grid item specifying the end grid line (letting the span default to 1).

Place the grid item specifying the start grid line and how many tracks it should span.

Panics if start or span is 0.

Place the grid item specifying start and end grid lines (span will be inferred)

Panics if start or end is 0.

Place the grid item specifying the end grid line and how many tracks it should span.

Panics if end or span is 0.

Mutate the item, setting the start grid line

Panics if start is 0.

Mutate the item, setting the end grid line

Mutate the item, setting the number of tracks the item should span

Returns the grid line at which the item should start, or None if not set.

Returns the grid line at which the item should end, or None if not set.

Returns span for this grid item, or None if not set.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GridPlacement { /* private fields */ }
```

Example 2 (unknown):
```unknown
218    pub fn setup(mut commands: Commands) {
219        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Grid)));
220        // Top-level grid (app frame)
221        commands.spawn((
222            Node {
223                display: Display::Grid,
224                width: percent(100),
225                height: percent(100),
226                grid_template_columns: vec![GridTrack::min_content(), GridTrack::flex(1.0)],
227                grid_template_rows: vec![
228                    GridTrack::auto(),
229                    GridTrack::flex(1.0),
230                    GridTrack::px(
...
```

Example 3 (javascript):
```javascript
18fn spawn_layout(mut commands: Commands, asset_server: Res<AssetServer>) {
19    let font = asset_server.load("fonts/FiraSans-Bold.ttf");
20    commands.spawn(Camera2d);
21
22    // Top-level grid (app frame)
23    commands
24        .spawn((
25            Node {
26                // Use the CSS Grid algorithm for laying out this node
27                display: Display::Grid,
28                // Make node fill the entirety of its parent (in this case the window)
29                width: percent(100),
30                height: percent(100),
31                // Set the grid to have 2 columns 
...
```

Example 4 (javascript):
```javascript
22fn setup(mut commands: Commands) {
23    let w = 60;
24    let h = 40;
25
26    commands.spawn(Camera2d);
27    commands.insert_resource(UiScale(0.5));
28
29    commands
30        .spawn((
31            Node {
32                width: percent(100),
33                height: percent(100),
34                overflow: Overflow::scroll(),
35                ..Default::default()
36            },
37            ScrollPosition(Vec2::ZERO),
38            ScrollableNode,
39            ScrollStart(Vec2::ZERO),
40        ))
41        .observe(
42            |drag: On<Pointer<Drag>>,
43             ui_sca
...
```

---

## Struct MainScheduleOrder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.MainScheduleOrder.html

**Contents:**
- Struct MainScheduleOrder Copy item path
- Fields§
- Implementations§
  - impl MainScheduleOrder
    - pub fn insert_after( &mut self, after: impl ScheduleLabel, schedule: impl ScheduleLabel, )
      - Examples found in repository?
    - pub fn insert_before( &mut self, before: impl ScheduleLabel, schedule: impl ScheduleLabel, )
    - pub fn insert_startup_after( &mut self, after: impl ScheduleLabel, schedule: impl ScheduleLabel, )
      - Examples found in repository?
    - pub fn insert_startup_before( &mut self, before: impl ScheduleLabel, schedule: impl ScheduleLabel, )

Defines the schedules to be run for the Main schedule, including their order.

The labels to run for the main phase of the Main schedule (in the order they will be run).

The labels to run for the startup phase of the Main schedule (in the order they will be run).

Adds the given schedule after the after schedule in the main list of schedules.

Adds the given schedule before the before schedule in the main list of schedules.

Adds the given schedule after the after schedule in the list of startup schedules.

Adds the given schedule before the before schedule in the list of startup schedules.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MainScheduleOrder {
    pub labels: Vec<Interned<dyn ScheduleLabel>>,
    pub startup_labels: Vec<Interned<dyn ScheduleLabel>>,
}
```

Example 2 (javascript):
```javascript
34    fn build(&self, app: &mut App) {
35        app.add_systems(Startup, build_stepping_hint);
36        if cfg!(not(feature = "bevy_debug_stepping")) {
37            return;
38        }
39
40        // create and insert our debug schedule into the main schedule order.
41        // We need an independent schedule so we have access to all other
42        // schedules through the `Stepping` resource
43        app.init_schedule(DebugSchedule);
44        let mut order = app.world_mut().resource_mut::<MainScheduleOrder>();
45        order.insert_after(Update, DebugSchedule);
46
47        // create
...
```

Example 3 (javascript):
```javascript
16fn main() {
17    let mut app = App::new();
18
19    // Create a new [`Schedule`]. For demonstration purposes, we configure it to use a single threaded executor so that
20    // systems in this schedule are never run in parallel. However, this is not a requirement for custom schedules in
21    // general.
22    let mut custom_update_schedule = Schedule::new(SingleThreadedUpdate);
23    custom_update_schedule.set_executor_kind(ExecutorKind::SingleThreaded);
24
25    // Adding the schedule to the app does not automatically run the schedule. This merely registers the schedule so
26    // that s
...
```

Example 4 (javascript):
```javascript
16fn main() {
17    let mut app = App::new();
18
19    // Create a new [`Schedule`]. For demonstration purposes, we configure it to use a single threaded executor so that
20    // systems in this schedule are never run in parallel. However, this is not a requirement for custom schedules in
21    // general.
22    let mut custom_update_schedule = Schedule::new(SingleThreadedUpdate);
23    custom_update_schedule.set_executor_kind(ExecutorKind::SingleThreaded);
24
25    // Adding the schedule to the app does not automatically run the schedule. This merely registers the schedule so
26    // that s
...
```

---

## Struct SpawnScene Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.SpawnScene.html

**Contents:**
- Struct SpawnScene Copy item path
- Trait Implementations§
  - impl Clone for SpawnScene
    - fn clone(&self) -> SpawnScene
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for SpawnScene
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for SpawnScene
    - fn default() -> SpawnScene
  - impl Hash for SpawnScene

The schedule that contains scene spawning.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpawnScene;
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/image/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§

bevy::imageModule prelude Copy item pathSource Structs§DynamicTextureAtlasBuilderHelper utility to update TextureAtlasLayout on the fly.ImageAn image, optimized for usage in rendering.ImagePluginAdds the Image as an asset and makes sure that they are extracted and prepared for the GPU.TextureAtlasAn index into a TextureAtlasLayout, which corresponds to a specific section of a texture.TextureAtlasBuilderA builder which is used to create a texture atlas from many individual sprites.TextureAtlasLayoutStores a map used to lookup the position of a texture in a TextureAtlas. This can be used to either use and look up a specific section of a texture, or animate frame-by-frame as a sprite sheet.TextureAtlasSourcesStores a mapping from sub texture handles to the related area index.Enums§ImageFormatTextureErrorAn error that occurs when loading a texture.Traits§_Trait used to provide default values for Bevy-external types that do not implement Default.

---

## Enum TransformSystems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.TransformSystems.html

**Contents:**
- Enum TransformSystems Copy item path
- Variants§
  - Propagate
- Trait Implementations§
  - impl Clone for TransformSystems
    - fn clone(&self) -> TransformSystems
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for TransformSystems
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Hash for TransformSystems

Set enum for the systems relating to transform propagation

Propagates changes in transform to children’s GlobalTransform

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum TransformSystems {
    Propagate,
}
```

---

## Struct Pickable Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Pickable.html

**Contents:**
- Struct Pickable Copy item path
- Fields§
- Implementations§
  - impl Pickable
    - pub const IGNORE: Pickable
- Trait Implementations§
  - impl Clone for Pickable
    - fn clone(&self) -> Pickable
    - fn clone_from(&mut self, source: &Self)
  - impl Component for Pickablewhere Pickable: Send + Sync + 'static,

An optional component that marks an entity as usable by a backend, and overrides default picking behavior for an entity.

This allows you to make an entity non-hoverable, or allow items below it to be hovered.

See the documentation on the fields for more details.

Should this entity block entities below it from being picked?

This is useful if you want picking to continue hitting entities below this one. Normally, only the topmost entity under a pointer can be hovered, but this setting allows the pointer to hover multiple entities, from nearest to farthest, stopping as soon as it hits an entity that blocks lower entities.

Note that the word “lower” here refers to entities that have been reported as hit by any picking backend, but are at a lower depth than the current one. This is different from the concept of event bubbling, as it works irrespective of the entity hierarchy.

For example, if a pointer is over a UI element, as well as a 3d mesh, backends will report hits for both of these entities. Additionally, the hits will be sorted by the camera order, so if the UI is drawing on top of the 3d mesh, the UI will be “above” the mesh. When hovering is computed, the UI element will be checked first to see if it this field is set to block lower entities. If it does (default), the hovering system will stop there, and only the UI element will be marked as hovered. However, if this field is set to false, both the UI element and the mesh will be marked as hovered.

Entities without the Pickable component will block by default.

If this is set to false and should_block_lower is set to true, this entity will block lower entities from being interacted and at the same time will itself not emit any events.

Note that the word “lower” here refers to entities that have been reported as hit by any picking backend, but are at a lower depth than the current one. This is different from the concept of event bubbling, as it works irrespective of the entity hierarchy.

For example, if a pointer is over a UI element, and this field is set to false, it will not be marked as hovered, and consequently will not emit events nor will any picking components mark it as hovered. This can be combined with the other field Self::should_block_lower, which is orthogonal to this one.

Entities without the Pickable component are hoverable by default.

This entity will not block entities beneath it, nor will it emit events.

If a backend reports this entity as being hit, the picking plugin wil

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Pickable {
    pub should_block_lower: bool,
    pub is_hoverable: bool,
}
```

---

## Macro warn_span Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.warn_span.html

**Contents:**
- Macro warn_span Copy item path
- §Examples

Constructs a span at the warn level.

Fields and attributes are set using the same syntax as the span! macro.

See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! warn_span {
    (target: $target:expr, parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, parent: $parent:expr, $name:expr) => { ... };
    (parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (parent: $parent:expr, $name:expr) => { ... };
    (target: $target:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, $name:expr) => { ... };
    ($name:expr, $($field:tt)*) => { ... };
    ($name:expr) => { ... };
}
```

Example 2 (unknown):
```unknown
warn_span!("my_span");
// is equivalent to:
span!(Level::WARN, "my_span");
```

Example 3 (javascript):
```javascript
use tracing::warn_span;
let span = warn_span!("my span");
span.in_scope(|| {
    // do work inside the span...
});
```

---

## Struct IVec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.IVec2.html

**Contents:**
- Struct IVec2 Copy item path
- Fields§
- Implementations§
  - impl IVec2
    - pub const ZERO: IVec2
    - pub const ONE: IVec2
    - pub const NEG_ONE: IVec2
    - pub const MIN: IVec2
    - pub const MAX: IVec2
    - pub const X: IVec2

A 2-dimensional vector.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y]

Creates a vector from the first 2 values in slice.

Panics if slice is less than 2 elements long.

Writes the elements of self to the first 2 elements in slice.

Panics if slice is less than 2 elements long.

Creates a 3D vector from self and the given z value.

Creates a 2D vector from self with the given value of x.

Creates a 2D vector from self with the given value of y.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

Component-wise clamping of values, similar to i32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

Returns the index of the first minimum element of self.

Returns the index of the first maximum element of self.

Returns the sum of all elements of self.

In other words, this computes self.x + self.y + ...

Returns the product of all elements of self.

In other words, this computes self.x * self.y * ...

Returns a vector mask containing the result of a == comparison for each element of self and rhs.

In other words, this computes [self.x == rhs.x, self.y == rhs.y, ..] for all elements.

Returns a vector mask containing the result of a != comparison for each element of self and rhs.

In other words this computes [self.x != rhs.x, self

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct IVec2 {
    pub x: i32,
    pub y: i32,
}
```

---

## Struct Vec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Vec2.html

**Contents:**
- Struct Vec2 Copy item path
- Fields§
- Implementations§
  - impl Vec2
    - pub const ZERO: Vec2
    - pub const ONE: Vec2
    - pub const NEG_ONE: Vec2
    - pub const MIN: Vec2
    - pub const MAX: Vec2
    - pub const NAN: Vec2

A 2-dimensional vector.

All f32::NEG_INFINITY.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

Vec2 uses Rust Portable SIMD

Vec2 uses scalar math

Vec2 uses WebAssembly 128-bit SIMD

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y]

Creates a vector from the first 2 values in slice.

Panics if slice is less than 2 elements long.

Writes the elements of self to the first 2 elements in slice.

Panics if slice is less than 2 elements long.

Creates a 3D vector from self and the given z value.

Creates a 2D vector from self with the given value of x.

Creates a 2D vector from self with the given value of y.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for minNum and may differ on different SIMD architectures.

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for maxNum and may differ on different SIMD architectures.

Component-wise clamping of values, similar to f32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

NaN propogation does not follow IEEE 754-2008 semantics and may differ on different SIMD architectures.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

NaN propogation does not follow IEEE 754-2008 semantics and may differ on different SIMD architectures.

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

NaN propogation does not follow IEEE 754-2008 semantics and may differ on different SIMD

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct Vec2 {
    pub x: f32,
    pub y: f32,
}
```

Example 2 (javascript):
```javascript
5const BOUNDS: Vec2 = Vec2::new(1200.0, 640.0);
```

Example 3 (javascript):
```javascript
18const EXTENT: Vec2 = Vec2::new(1172.0, 520.0);
19const PLOT_SIZE: Vec2 = Vec2::splat(80.0);
20
21fn setup(mut commands: Commands) {
22    commands.spawn(Camera2d);
23
24    let text_font = TextFont {
25        font_size: 10.0,
26        ..default()
27    };
28
29    let chunks = [
30        // "In" row
31        EaseFunction::SineIn,
32        EaseFunction::QuadraticIn,
33        EaseFunction::CubicIn,
34        EaseFunction::QuarticIn,
35        EaseFunction::QuinticIn,
36        EaseFunction::SmoothStepIn,
37        EaseFunction::SmootherStepIn,
38        EaseFunction::CircularIn,
39      
...
```

Example 4 (javascript):
```javascript
14const PADDLE_SIZE: Vec2 = Vec2::new(120.0, 20.0);
15const GAP_BETWEEN_PADDLE_AND_FLOOR: f32 = 60.0;
16const PADDLE_SPEED: f32 = 500.0;
17// How close can the paddle get to the wall
18const PADDLE_PADDING: f32 = 10.0;
19
20// We set the z-value of the ball to 1 so it renders on top in the case of overlapping sprites.
21const BALL_STARTING_POSITION: Vec3 = Vec3::new(0.0, -50.0, 1.0);
22const BALL_DIAMETER: f32 = 30.;
23const BALL_SPEED: f32 = 400.0;
24const INITIAL_BALL_DIRECTION: Vec2 = Vec2::new(0.5, -0.5);
25
26const WALL_THICKNESS: f32 = 10.0;
27// x coordinates
28const LEFT_WALL: f32 = -4
...
```

---

## Struct GltfExtras Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GltfExtras.html

**Contents:**
- Struct GltfExtras Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for GltfExtras
    - fn clone(&self) -> GltfExtras
    - fn clone_from(&mut self, source: &Self)
  - impl Component for GltfExtraswhere GltfExtras: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Additional untyped data that can be present on most glTF types at the primitive level.

See the relevant glTF specification section.

Content of the extra data.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GltfExtras {
    pub value: String,
}
```

---

## Struct ShortName Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ShortName.html

**Contents:**
- Struct ShortName Copy item path
- §Examples
- Tuple Fields§
- Implementations§
  - impl ShortName<'static>
    - pub fn of<T>() -> ShortName<'static>where T: ?Sized,
  - impl<'a> ShortName<'a>
    - pub const fn original(&self) -> &'a str
- Trait Implementations§
  - impl<'a> Clone for ShortName<'a>

Lazily shortens a type name to remove all module paths.

The short name of a type is its full name as returned by core::any::type_name, but with the prefix of all paths removed. For example, the short name of alloc::vec::Vec<core::option::Option<u32>> would be Vec<Option<u32>>.

Shortening is performed lazily without allocation. To get a String from this type, use the to_string method.

Gets a shortened version of the name of the type T.

Gets the original name before shortening.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ShortName<'a>(pub &'a str);
```

Example 2 (javascript):
```javascript
// Baz
let short_name = ShortName::of::<foo::bar::Baz>();
```

---

## Enum FlexDirection Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.FlexDirection.html

**Contents:**
- Enum FlexDirection Copy item path
- Variants§
  - Row
  - Column
  - RowReverse
  - ColumnReverse
- Implementations§
  - impl FlexDirection
    - pub const DEFAULT: FlexDirection = Self::Row
- Trait Implementations§

Defines how flexbox items are ordered within a flexbox

Same way as text direction along the main axis.

Flex from top to bottom.

Opposite way as text direction along the main axis.

Flex from bottom to top.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum FlexDirection {
    Row,
    Column,
    RowReverse,
    ColumnReverse,
}
```

---

## Function condition_changed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.condition_changed.html

**Contents:**
- Function condition_changed Copy item path
- §Example

Generates a SystemCondition that returns true when the passed one changes.

The first time this is called, the passed condition is assumed to have been previously false.

**Examples:**

Example 1 (unknown):
```unknown
pub fn condition_changed<Marker, CIn, C>(
    condition: C,
) -> impl SystemCondition<(), CIn>where
    CIn: SystemInput,
    C: SystemCondition<Marker, CIn>,
```

Example 2 (unknown):
```unknown
app.add_systems(
    my_system.run_if(condition_changed(resource_exists::<MyResource>)),
);

#[derive(Resource)]
struct MyResource;

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `MyResource` is initially there, the inner condition is true, the system runs once
world.insert_resource(MyResource);
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);

// We remove `MyResource`, the inner condition is now false, the system runs one more time.
world.remove_resource::<MyResource>();
app.run(&mut
...
```

---

## Struct CubicSegment Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicSegment.html

**Contents:**
- Struct CubicSegment Copy item path
- Fields§
- Implementations§
  - impl<P> CubicSegment<P>where P: VectorSpace<Scalar = f32>,
    - pub fn position(&self, t: f32) -> P
    - pub fn velocity(&self, t: f32) -> P
    - pub fn acceleration(&self, t: f32) -> P
    - pub fn new_bezier(points: [P; 4]) -> CubicSegment<P>
    - pub fn iter_samples<'a, 'b>( &'b self, subdivisions: usize, sample_function: impl FnMut(&CubicSegment<P>, f32) -> P + 'a, ) -> impl Iterator<Item = P> + 'awhere 'b: 'a,
    - pub fn iter_uniformly(&self, subdivisions: usize) -> impl Iterator<Item = f32>

A segment of a cubic curve, used to hold precomputed coefficients for fast interpolation. It is a Curve with domain [0, 1].

Segments can be chained together to form a longer compound curve.

Polynomial coefficients for the segment.

Instantaneous position of a point at parametric value t.

Instantaneous velocity of a point at parametric value t.

Instantaneous acceleration of a point at parametric value t.

Creates a cubic segment from four points, representing a Bezier curve.

A flexible iterator used to sample curves with arbitrary functions.

This splits the curve into subdivisions of evenly spaced t values across the length of the curve from start (t = 0) to end (t = n), where n = self.segment_count(), returning an iterator evaluating the curve with the supplied sample_function at each t.

For subdivisions = 2, this will split the curve into two lines, or three points, and return an iterator with 3 items, the three points, one at the start, middle, and end.

An iterator that returns values of t uniformly spaced over 0..=subdivisions.

Iterate over the curve split into subdivisions, sampling the position at each step.

Iterate over the curve split into subdivisions, sampling the velocity at each step.

Iterate over the curve split into subdivisions, sampling the acceleration at each step.

The CubicSegment<Vec2> can be used as a 2-dimensional easing curve for animation.

The x-axis of the curve is time, and the y-axis is the output value. This struct provides methods for extremely fast solves for y given x.

Construct a cubic Bezier curve for animation easing, with control points p1 and p2. A cubic Bezier easing curve has control point p0 at (0, 0) and p3 at (1, 1), leaving only p1 and p2 as the remaining degrees of freedom. The first and last control points are fixed to ensure the animation begins at 0, and ends at 1.

This is a very common tool for UI animations that accelerate and decelerate smoothly. For example, the ubiquitous “ease-in-out” is defined as (0.25, 0.1), (0.25, 1.0).

Given a time within 0..=1, returns an eased value that follows the cubic curve instead of a straight line. This eased result may be outside the range 0..=1, however it will always start at 0 and end at 1: ease(0) = 0 and ease(1) = 1.

Easing is generally accomplished with the help of “shaping functions”. These are curves that start at (0,0) and end at (1,1). The x-axis of this plot is the current time of the animation, from 0 to 1. The y-axis is how far along the animati

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicSegment<P>where
    P: VectorSpace,{
    pub coeff: [P; 4],
}
```

Example 2 (javascript):
```javascript
let cubic_bezier = CubicSegment::new_bezier_easing((0.25, 0.1), (0.25, 1.0));
assert_eq!(cubic_bezier.ease(0.0), 0.0);
assert_eq!(cubic_bezier.ease(1.0), 1.0);
```

Example 3 (text):
```text
y
│         ●
│       ⬈
│     ⬈
│   ⬈
│ ⬈
●─────────── x (time)
```

Example 4 (text):
```text
y
         ⬈➔●
│      ⬈
│     ↑
│     ↑
│    ⬈
●➔⬈───────── x (time)
```

---

## Enum UntypedHandle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.UntypedHandle.html

**Contents:**
- Enum UntypedHandle Copy item path
- Variants§
  - Strong(Arc<StrongHandle>)
  - Uuid
    - Fields
- Implementations§
  - impl UntypedHandle
    - pub fn id(&self) -> UntypedAssetId
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>

An untyped variant of Handle, which internally stores the Asset type information at runtime as a TypeId instead of encoding it in the compile-time type. This allows handles across Asset types to be stored together and compared.

See Handle for more information.

A strong handle, which will keep the referenced Asset alive until all strong handles are dropped.

A UUID handle, which does not keep the referenced Asset alive.

An identifier that records the underlying asset type.

The UUID provided during asset registration.

Returns the UntypedAssetId for the referenced asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns the TypeId of the referenced Asset.

Converts to a typed Handle. This will not check if the target Handle type matches.

Converts to a typed Handle. This will check the type when compiled with debug asserts, but it will not check if the target Handle type matches in release builds. Use this as an optimization when you want some degree of validation at dev-time, but you are also very certain that the type actually matches.

Converts to a typed Handle. This will panic if the internal TypeId does not match the given asset type A

Converts to a typed Handle. This will panic if the internal TypeId does not match the given asset type A

The “meta transform” for the strong handle. This will only be Some if the handle is strong and there is a meta transform associated with it.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum UntypedHandle {
    Strong(Arc<StrongHandle>),
    Uuid {
        type_id: TypeId,
        uuid: Uuid,
    },
}
```

Example 2 (javascript):
```javascript
217fn create_texture_atlas(
218    folder: &LoadedFolder,
219    padding: Option<UVec2>,
220    sampling: Option<ImageSampler>,
221    textures: &mut ResMut<Assets<Image>>,
222) -> (TextureAtlasLayout, TextureAtlasSources, Handle<Image>) {
223    // Build a texture atlas using the individual sprites
224    let mut texture_atlas_builder = TextureAtlasBuilder::default();
225    texture_atlas_builder.padding(padding.unwrap_or_default());
226    for handle in folder.handles.iter() {
227        let id = handle.id().typed_unchecked::<Image>();
228        let Some(texture) = textures.get(id) else {
2
...
```

Example 3 (javascript):
```javascript
217fn create_texture_atlas(
218    folder: &LoadedFolder,
219    padding: Option<UVec2>,
220    sampling: Option<ImageSampler>,
221    textures: &mut ResMut<Assets<Image>>,
222) -> (TextureAtlasLayout, TextureAtlasSources, Handle<Image>) {
223    // Build a texture atlas using the individual sprites
224    let mut texture_atlas_builder = TextureAtlasBuilder::default();
225    texture_atlas_builder.padding(padding.unwrap_or_default());
226    for handle in folder.handles.iter() {
227        let id = handle.id().typed_unchecked::<Image>();
228        let Some(texture) = textures.get(id) else {
2
...
```

---

## Enum MouseButton Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.MouseButton.html

**Contents:**
- Enum MouseButton Copy item path
  - §Usage
  - §Updating
- Variants§
  - Left
  - Right
  - Middle
  - Back
  - Forward
  - Other(u16)

A button on a mouse device.

It is used as the generic T value of an ButtonInput to create a bevy resource.

The resource is updated inside of the mouse_button_input_system.

The left mouse button.

The right mouse button.

The middle mouse button.

The back mouse button.

The forward mouse button.

Another mouse button with the associated number.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum MouseButton {
    Left,
    Right,
    Middle,
    Back,
    Forward,
    Other(u16),
}
```

---

## Type Alias Text2dReader Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.Text2dReader.html

**Contents:**
- Type Alias Text2dReader Copy item path
- Aliased Type§

2d alias for TextReader.

**Examples:**

Example 1 (unknown):
```unknown
pub type Text2dReader<'w, 's> = TextReader<'w, 's, Text2d>;
```

Example 2 (unknown):
```unknown
pub struct Text2dReader<'w, 's> { /* private fields */ }
```

---

## Function px Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.px.html

**Contents:**
- Function px Copy item path
      - Examples found in repository?

Returns a Val::Px representing a value in logical pixels.

**Examples:**

Example 1 (unknown):
```unknown
pub fn px<T>(value: T) -> Valwhere
    T: ValNum,
```

Example 2 (javascript):
```javascript
47pub fn main_ui_node() -> Node {
48    Node {
49        flex_direction: FlexDirection::Column,
50        position_type: PositionType::Absolute,
51        row_gap: px(6),
52        left: px(10),
53        bottom: px(10),
54        ..default()
55    }
56}
57
58/// Spawns a single radio button that allows configuration of a setting.
59///
60/// The type parameter specifies the value that will be packaged up and sent in
61/// a [`WidgetClickEvent`] when the radio button is clicked.
62pub fn option_button<T>(
63    option_value: T,
64    option_name: &str,
65    is_selected: bool,
66    is_first: 
...
```

Example 3 (unknown):
```unknown
403fn spawn_help_text(commands: &mut Commands) {
404    commands.spawn((
405        Text::new(""),
406        Node {
407            position_type: PositionType::Absolute,
408            top: px(12),
409            left: px(12),
410            ..default()
411        },
412    ));
413}
```

Example 4 (unknown):
```unknown
125fn setup_instructions(mut commands: Commands) {
126    commands.spawn((
127        Text::default(),
128        Node {
129            position_type: PositionType::Absolute,
130            top: px(12),
131            left: px(12),
132            ..default()
133        },
134    ));
135}
```

---

## Struct MapCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MapCurve.html

**Contents:**
- Struct MapCurve Copy item path
- Trait Implementations§
  - impl<S, T, C, F> Clone for MapCurve<S, T, C, F>where S: Clone, T: Clone, C: Clone, F: Clone,
    - fn clone(&self) -> MapCurve<S, T, C, F>
    - fn clone_from(&mut self, source: &Self)
  - impl<S, T, C, F> Curve<T> for MapCurve<S, T, C, F>where C: Curve<S>, F: Fn(S) -> T,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

A curve whose samples are defined by mapping samples from another curve through a given function. Curves of this type are produced by CurveExt::map.

Note: This is not a fully stable implementation of TypePath due to usage of type_name for function members.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MapCurve<S, T, C, F> { /* private fields */ }
```

---

## Struct AudioPlayer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AudioPlayer.html

**Contents:**
- Struct AudioPlayer Copy item path
- Tuple Fields§
- Implementations§
  - impl AudioPlayer
    - pub fn new(source: Handle<AudioSource>) -> AudioPlayer
      - Examples found in repository?
- Trait Implementations§
  - impl<Source> Clone for AudioPlayer<Source>where Source: Asset + Decodable,
    - fn clone(&self) -> AudioPlayer<Source>
    - fn clone_from(&mut self, source: &Self)

A component for playing a sound.

Insert this component onto an entity to trigger an audio source to begin playing.

If the handle refers to an unavailable asset (such as if it has not finished loading yet), the audio will not begin playing immediately. The audio will play when the asset is ready.

When Bevy begins the audio playback, an AudioSink component will be added to the entity. You can use that component to control the audio settings during playback.

Playback can be configured using the PlaybackSettings component. Note that changes to the PlaybackSettings component will not affect already-playing audio.

Creates a new AudioPlayer with the given Handle<AudioSource>.

For convenience reasons, this hard-codes the AudioSource type. If you want to initialize an AudioPlayer with a different type, just initialize it directly using normal tuple struct syntax.

Required Components: PlaybackSettings.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AudioPlayer<Source = AudioSource>(pub Handle<Source>)
where
    Source: Asset + Decodable;
```

Example 2 (unknown):
```unknown
13fn setup(asset_server: Res<AssetServer>, mut commands: Commands) {
14    commands.spawn(AudioPlayer::new(
15        asset_server.load("sounds/Windless Slopes.ogg"),
16    ));
17}
```

Example 3 (unknown):
```unknown
16fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
17    commands.spawn((
18        AudioPlayer::new(asset_server.load("sounds/Windless Slopes.ogg")),
19        MyMusic,
20    ));
21
22    commands.spawn((
23        Text::new(""),
24        Node {
25            position_type: PositionType::Absolute,
26            top: px(12),
27            left: px(12),
28            ..default()
29        },
30        ProgressText,
31    ));
32
33    // example instructions
34    commands.spawn((
35        Text::new("-/=: Volume Down/Up\nSpace: Toggle Playback\nM: Toggle Mute"),
36        Nod
...
```

Example 4 (javascript):
```javascript
26fn setup(
27    mut commands: Commands,
28    mut meshes: ResMut<Assets<Mesh>>,
29    mut materials: ResMut<Assets<ColorMaterial>>,
30    asset_server: Res<AssetServer>,
31) {
32    // Space between the two ears
33    let gap = 400.0;
34
35    // sound emitter
36    commands.spawn((
37        Mesh2d(meshes.add(Circle::new(15.0))),
38        MeshMaterial2d(materials.add(Color::from(BLUE))),
39        Transform::from_translation(Vec3::new(0.0, 50.0, 0.0)),
40        Emitter::default(),
41        AudioPlayer::new(asset_server.load("sounds/Windless Slopes.ogg")),
42        PlaybackSettings::LOOP
...
```

---

## Struct ReverseCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReverseCurve.html

**Contents:**
- Struct ReverseCurve Copy item path
- §Domain
- Trait Implementations§
  - impl<T, C> Clone for ReverseCurve<T, C>where T: Clone, C: Clone,
    - fn clone(&self) -> ReverseCurve<T, C>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C> Curve<T> for ReverseCurve<T, C>where C: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>

The curve that results from reversing another.

Curves of this type are produced by CurveExt::reverse.

The original curve’s domain must be bounded to get a valid ReverseCurve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReverseCurve<T, C> { /* private fields */ }
```

---

## Struct Shader Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Shader.html

**Contents:**
- Struct Shader Copy item path
- Fields§
- Implementations§
  - impl Shader
    - pub fn from_wgsl( source: impl Into<Cow<'static, str>>, path: impl Into<String>, ) -> Shader
      - Examples found in repository?
    - pub fn from_wgsl_with_defs( source: impl Into<Cow<'static, str>>, path: impl Into<String>, shader_defs: Vec<ShaderDefVal>, ) -> Shader
    - pub fn from_glsl( source: impl Into<Cow<'static, str>>, stage: ShaderStage, path: impl Into<String>, ) -> Shader
    - pub fn from_spirv( source: impl Into<Cow<'static, [u8]>>, path: impl Into<String>, ) -> Shader
    - pub fn from_wesl( source: impl Into<Cow<'static, str>>, path: impl Into<String>, ) -> Shader

An “unprocessed” shader. It can contain preprocessor directives.

Enable or disable runtime shader validation, trading safety against speed.

Please read the ValidateShader docs for a discussion of the tradeoffs involved.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Shader {
    pub path: String,
    pub source: Source,
    pub import_path: ShaderImport,
    pub imports: Vec<ShaderImport>,
    pub additional_imports: Vec<ImportDefinition>,
    pub shader_defs: Vec<ShaderDefVal>,
    pub file_dependencies: Vec<Handle<Shader>>,
    pub validate_shader: ValidateShader,
}
```

Example 2 (javascript):
```javascript
298    fn build(&self, app: &mut App) {
299        // Load our custom shader
300        let mut shaders = app.world_mut().resource_mut::<Assets<Shader>>();
301        // Here, we construct and add the shader asset manually. There are many ways to load this
302        // shader, including `embedded_asset`/`load_embedded_asset`.
303        let shader = shaders.add(Shader::from_wgsl(COLORED_MESH2D_SHADER, file!()));
304
305        app.add_plugins(SyncComponentPlugin::<ColoredMesh2d>::default());
306
307        // Register our custom draw function, and add our render systems
308        app.get_sub
...
```

---

## Struct TextLayout Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextLayout.html

**Contents:**
- Struct TextLayout Copy item path
- Fields§
- Implementations§
  - impl TextLayout
    - pub const fn new(justify: Justify, linebreak: LineBreak) -> TextLayout
      - Examples found in repository?
    - pub fn new_with_justify(justify: Justify) -> TextLayout
      - Examples found in repository?
    - pub fn new_with_linebreak(linebreak: LineBreak) -> TextLayout
    - pub fn new_with_no_wrap() -> TextLayout

Component with text format settings for a block of text.

A block of text is composed of text spans, which each have a separate string value and TextFont. Text spans associated with a text block are collected into ComputedTextBlock for layout, and then inserted to TextLayoutInfo for rendering.

See Text2d in bevy_sprite for the core component of 2d text, and Text in bevy_ui for UI text.

The text’s internal alignment. Should not affect its position within a container.

How the text should linebreak when running out of the bounds determined by max_size.

Makes a new TextLayout.

Makes a new TextLayout with the specified Justify.

Makes a new TextLayout with the specified LineBreak.

Makes a new TextLayout with soft wrapping disabled. Hard wrapping, where text contains an explicit linebreak such as the escape sequence \n, will still occur.

Returns this TextLayout with the specified Justify.

Returns this TextLayout with the specified LineBreak.

Returns this TextLayout with soft wrapping disabled. Hard wrapping, where text contains an explicit linebreak such as the escape sequence \n, will still occur.

Required Components: ComputedTextBlock, TextLayoutInfo.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextLayout {
    pub justify: Justify,
    pub linebreak: LineBreak,
}
```

Example 2 (javascript):
```javascript
454    pub fn setup(mut commands: Commands) {
455        commands.spawn((Camera2d, DespawnOnExit(super::Scene::TextWrap)));
456
457        let root = commands
458            .spawn((
459                Node {
460                    flex_direction: FlexDirection::Column,
461                    width: px(200),
462                    height: percent(100),
463                    overflow: Overflow::clip_x(),
464                    ..default()
465                },
466                BackgroundColor(Color::BLACK),
467                DespawnOnExit(super::Scene::TextWrap),
468            ))
469      
...
```

Example 3 (javascript):
```javascript
44fn spawn(mut commands: Commands, asset_server: Res<AssetServer>) {
45    commands.spawn(Camera2d);
46
47    let text_font = TextFont {
48        font: asset_server.load("fonts/FiraSans-Bold.ttf"),
49        font_size: 12.0,
50        ..default()
51    };
52
53    let root = commands
54        .spawn((
55            Node {
56                width: percent(100),
57                height: percent(100),
58                flex_direction: FlexDirection::Column,
59                ..default()
60            },
61            BackgroundColor(Color::BLACK),
62        ))
63        .id();
64
65    for lin
...
```

Example 4 (javascript):
```javascript
36fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
37    let font = asset_server.load("fonts/FiraSans-Bold.ttf");
38    let text_font = TextFont {
39        font: font.clone(),
40        font_size: 50.0,
41        ..default()
42    };
43    let text_justification = Justify::Center;
44    commands.spawn(Camera2d);
45    // Demonstrate changing translation
46    commands.spawn((
47        Text2d::new(" translation "),
48        text_font.clone(),
49        TextLayout::new_with_justify(text_justification),
50        TextBackgroundColor(Color::BLACK.with_alpha(0.5)),
51        Te
...
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Modules§
- Macros§
- Structs§
- Enums§
- Traits§
- Functions§
- Type Aliases§
- Attribute Macros§
- Derive Macros§

use bevy::prelude::*; to import common components, bundles, and plugins.

---

## Enum SpriteImageMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.SpriteImageMode.html

**Contents:**
- Enum SpriteImageMode Copy item path
- Variants§
  - Auto
  - Scale(ScalingMode)
  - Sliced(TextureSlicer)
  - Tiled
    - Fields
- Implementations§
  - impl SpriteImageMode
    - pub fn uses_slices(&self) -> bool

Controls how the image is altered when scaled.

The sprite will take on the size of the image by default, and will be stretched or shrunk if Sprite::custom_size is set.

The texture will be scaled to fit the rect bounds defined in Sprite::custom_size. Otherwise no scaling will be applied.

The texture will be cut in 9 slices, keeping the texture in proportions on resize

The texture will be repeated if stretched beyond stretched_value

Should the image repeat horizontally

Should the image repeat vertically

The texture will repeat when the ratio between the drawing dimensions of texture and the original texture size are above this value.

Returns true if this mode uses slices internally (SpriteImageMode::Sliced or SpriteImageMode::Tiled)

Returns ScalingMode if scale is presented or Option::None otherwise.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum SpriteImageMode {
    Auto,
    Scale(ScalingMode),
    Sliced(TextureSlicer),
    Tiled {
        tile_x: bool,
        tile_y: bool,
        stretch_value: f32,
    },
}
```

---

## Struct SmoothStepInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SmoothStepInCurve.html

**Contents:**
- Struct SmoothStepInCurve Copy item path
- Trait Implementations§
  - impl Clone for SmoothStepInCurve
    - fn clone(&self) -> SmoothStepInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SmoothStepInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as the first half of SmoothStepCurve.

This has f″(1) = 0, unlike QuadraticInCurve which starts similarly.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SmoothStepInCurve;
```

---

## Function uvec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.uvec2.html

**Contents:**
- Function uvec2 Copy item path

Creates a 2-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn uvec2(x: u32, y: u32) -> UVec2
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/math/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§
- Functions§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct Populated Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Populated.html

**Contents:**
- Struct Populated Copy item path
- Implementations§
  - impl<'w, 's, D, F> Populated<'w, 's, D, F>where D: QueryData, F: QueryFilter,
    - pub fn into_inner(self) -> Query<'w, 's, D, F>
- Methods from Deref<Target = Query<'w, 's, D, F>>§
    - pub fn related<R>(&'w self, entity: Entity) -> Option<Entity>where R: Relationship, <D as QueryData>::ReadOnly: QueryData<Item<'w, 's> = &'w R>,
    - pub fn relationship_sources<S>( &'w self, entity: Entity, ) -> impl Iterator<Item = Entity> + 'wwhere S: RelationshipTarget, <D as QueryData>::ReadOnly: QueryData<Item<'w, 's> = &'w S>,
    - pub fn root_ancestor<R>(&'w self, entity: Entity) -> Entitywhere R: Relationship, <D as QueryData>::ReadOnly: QueryData<Item<'w, 's> = &'w R>,
      - §Warning
    - pub fn iter_leaves<S>( &'w self, entity: Entity, ) -> impl Iterator<Item = Entity> + use<'w, 's, S, D, F>where S: RelationshipTarget, <D as QueryData>::ReadOnly: QueryData<Item<'w, 's> = &'w S>, <<S as RelationshipTarget>::Collection as RelationshipSourceCollection>::SourceIter<'w>: DoubleEndedIterator,

System parameter that works very much like Query except it always contains at least one matching entity.

This SystemParam fails validation if no matching entities exist. This will cause the system to be skipped, according to the rules laid out in SystemParamValidationError.

Much like Query::is_empty the worst case runtime will be O(n) where n is the number of potential matches. This can be notably expensive for queries that rely on non-archetypal filters such as Added, Changed of Spawned which must individually check each query result for a match.

See Query for more details.

Returns the inner item with ownership.

If the given entity contains the R Relationship component, returns the target entity of that relationship.

If the given entity contains the S RelationshipTarget component, returns the source entities stored on that component.

Recursively walks up the tree defined by the given R Relationship until there are no more related entities, returning the “root entity” of the relationship hierarchy.

For relationship graphs that contain loops, this could loop infinitely. If your relationship is not a tree (like Bevy’s hierarchy), be sure to stop if you encounter a duplicate entity.

Iterates all “leaf entities” as defined by the RelationshipTarget hierarchy.

For relationship graphs that contain loops, this could loop infinitely. If your relationship is not a tree (like Bevy’s hierarchy), be sure to stop if you encounter a duplicate entity.

Iterates all sibling entities that also have the R Relationship with the same target entity.

Iterates all descendant entities as defined by the given entity’s RelationshipTarget and their recursive RelationshipTarget.

For relationship graphs that contain loops, this could loop infinitely. If your relationship is not a tree (like Bevy’s hierarchy), be sure to stop if you encounter a duplicate entity.

Iterates all descendant entities as defined by the given entity’s RelationshipTarget and their recursive RelationshipTarget in depth-first order.

For relationship graphs that contain loops, this could loop infinitely. If your relationship is not a tree (like Bevy’s hierarchy), be sure to stop if you encounter a duplicate entity.

Iterates all ancestors of the given entity as defined by the R Relationship.

For relationship graphs that contain loops, this could loop infinitely. If your relationship is not a tree (like Bevy’s hierarchy), be sure to stop if you encounter a duplicate entity.

Returns another Query fro

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Populated<'w, 's, D, F = ()>(/* private fields */)
where
    D: QueryData,
    F: QueryFilter;
```

Example 2 (javascript):
```javascript
57fn move_scene_entities(
58    time: Res<Time>,
59    moved_scene: Query<Entity, With<MovedScene>>,
60    children: Query<&Children>,
61    mut transforms: Query<&mut Transform>,
62) {
63    for moved_scene_entity in &moved_scene {
64        let mut offset = 0.;
65        for entity in children.iter_descendants(moved_scene_entity) {
66            if let Ok(mut transform) = transforms.get_mut(entity) {
67                transform.translation = Vec3::new(
68                    offset * ops::sin(time.elapsed_secs()) / 20.,
69                    0.,
70                    ops::cos(time.elapsed_sec
...
```

Example 3 (javascript):
```javascript
58fn play_animation_when_ready(
59    scene_ready: On<SceneInstanceReady>,
60    mut commands: Commands,
61    children: Query<&Children>,
62    animations_to_play: Query<&AnimationToPlay>,
63    mut players: Query<&mut AnimationPlayer>,
64) {
65    if let Ok(animation_to_play) = animations_to_play.get(scene_ready.entity) {
66        for child in children.iter_descendants(scene_ready.entity) {
67            if let Ok(mut player) = players.get_mut(child) {
68                player.play(animation_to_play.index).repeat();
69
70                commands
71                    .entity(child)
72      
...
```

Example 4 (javascript):
```javascript
230fn setup_scene_once_loaded(
231    scene_ready: On<SceneInstanceReady>,
232    animations: Res<Animations>,
233    foxes: Res<Foxes>,
234    mut commands: Commands,
235    children: Query<&Children>,
236    mut players: Query<&mut AnimationPlayer>,
237) {
238    for child in children.iter_descendants(scene_ready.entity) {
239        if let Ok(mut player) = players.get_mut(child) {
240            let playing_animation = player.play(animations.node_indices[0]).repeat();
241            if !foxes.sync {
242                playing_animation.seek_to(scene_ready.entity.index() as f32 / 10.0);
243 
...
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/log/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Macros§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct Move Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Move.html

**Contents:**
- Struct Move Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Move
    - fn clone(&self) -> Move
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Move
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Move
    - type This<'from_arg> = Move

Fires while a pointer is moving over the target entity.

Information about the picking intersection.

The change in position since the last move event.

This is stored in screen pixels, not world coordinates. Screen pixels go from top-left to bottom-right, whereas (in 2D) world coordinates go from bottom-left to top-right. Consider using methods on Camera to convert from screen-space to world-space.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Move {
    pub hit: HitData,
    pub delta: Vec2,
}
```

---

## Trait FloatExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.FloatExt.html

**Contents:**
- Trait FloatExt Copy item path
- Required Methods§
    - fn lerp(self, rhs: Self, s: Self) -> Self
    - fn inverse_lerp(a: Self, b: Self, v: Self) -> Self
    - fn remap( self, in_start: Self, in_end: Self, out_start: Self, out_end: Self, ) -> Self
    - fn fract_gl(self) -> Self
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl FloatExt for f32
    - fn lerp(self, rhs: f32, t: f32) -> f32

A trait for extending f32 and f64 with extra methods.

Performs a linear interpolation between self and rhs based on the value s.

When s is 0, the result will be self. When s is 1, the result will be rhs. When s is outside of the range [0, 1], the result is linearly extrapolated.

Returns v normalized to the range [a, b].

When v is equal to a the result will be 0. When v is equal to b will be 1.

When v is outside of the range [a, b], the result is linearly extrapolated.

a and b must not be equal, otherwise the result will be either infinite or NAN.

Remap self from the input range to the output range.

When self is equal to in_start this returns out_start. When self is equal to in_end this returns out_end.

When self is outside of the range [in_start, in_end], the result is linearly extrapolated.

in_start and in_end must not be equal, otherwise the result will be either infinite or NAN.

Returns the fractional part of the input as self - self.floor().

Note that this differs from the Rust implementation of fract which returns self - self.trunc().

Note that this is fast but not precise for large numbers.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait FloatExt {
    // Required methods
    fn lerp(self, rhs: Self, s: Self) -> Self;
    fn inverse_lerp(a: Self, b: Self, v: Self) -> Self;
    fn remap(
        self,
        in_start: Self,
        in_end: Self,
        out_start: Self,
        out_end: Self,
    ) -> Self;
    fn fract_gl(self) -> Self;
}
```

---

## Struct AppTypeRegistry Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AppTypeRegistry.html

**Contents:**
- Struct AppTypeRegistry Copy item path
- Tuple Fields§
- Implementations§
  - impl AppTypeRegistry
    - pub fn new_with_derived_types() -> AppTypeRegistry
- Methods from Deref<Target = TypeRegistryArc>§
    - pub fn read(&self) -> RwLockReadGuard<'_, TypeRegistry>
      - Examples found in repository?
    - pub fn write(&self) -> RwLockWriteGuard<'_, TypeRegistry>
- Trait Implementations§

A Resource storing TypeRegistry for type registrations relevant to a whole app.

Creates AppTypeRegistry and automatically registers all types deriving Reflect.

See TypeRegistry::register_derived_types for more details.

Takes a read lock on the underlying TypeRegistry.

Takes a write lock on the underlying TypeRegistry.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AppTypeRegistry(pub TypeRegistryArc);
```

Example 2 (javascript):
```javascript
22fn setup(type_registry: Res<AppTypeRegistry>) {
23    let type_registry = type_registry.read();
24
25    let registration = type_registry.get(TypeId::of::<MyType<u32>>()).unwrap();
26    info!(
27        "Registration for {} exists",
28        registration.type_info().type_path(),
29    );
30
31    // MyType<String> was not manually registered, so it does not exist
32    assert!(type_registry.get(TypeId::of::<MyType<String>>()).is_none());
33}
```

Example 3 (javascript):
```javascript
35fn deserialize(type_registry: Res<AppTypeRegistry>) {
36    let type_registry = type_registry.read();
37
38    // a serde_json::Value that might have come from an API
39    let value: serde_json::Value = serde_json::from_str(PLAYER_JSON).unwrap();
40
41    // alternatively, `TypedReflectDeserializer` can be used if the type
42    // is known.
43    let deserializer = ReflectDeserializer::new(&type_registry);
44    // deserialize
45    let reflect_value = deserializer.deserialize(value).unwrap();
46    // If Player implemented additional functionality, like Component,
47    // this reflect_va
...
```

Example 4 (javascript):
```javascript
157fn save_scene_system(world: &mut World) {
158    // Scenes can be created from any ECS World.
159    // You can either create a new one for the scene or use the current World.
160    // For demonstration purposes, we'll create a new one.
161    let mut scene_world = World::new();
162
163    // The `TypeRegistry` resource contains information about all registered types (including components).
164    // This is used to construct scenes, so we'll want to ensure that our previous type registrations
165    // exist in this new scene world as well.
166    // To do this, we can simply clone the `A
...
```

---

## Struct UiMaterialKey Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiMaterialKey.html

**Contents:**
- Struct UiMaterialKey Copy item path
- Fields§
- Trait Implementations§
  - impl<M> Clone for UiMaterialKey<M>where M: UiMaterial, <M as AsBindGroup>::Data: Clone,
    - fn clone(&self) -> UiMaterialKey<M>
    - fn clone_from(&mut self, source: &Self)
  - impl<M> Hash for UiMaterialKey<M>where M: UiMaterial, <M as AsBindGroup>::Data: Hash,
    - fn hash<H>(&self, state: &mut H)where H: Hasher,
    - fn hash_slice<H>(data: &[Self], state: &mut H)where H: Hasher, Self: Sized,
  - impl<M> PartialEq for UiMaterialKey<M>where M: UiMaterial, <M as AsBindGroup>::Data: PartialEq,

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiMaterialKey<M>where
    M: UiMaterial,{
    pub hdr: bool,
    pub bind_group_data: <M as AsBindGroup>::Data,
}
```

---

## Struct ReflectDeserialize Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectDeserialize.html

**Contents:**
- Struct ReflectDeserialize Copy item path
- Fields§
- Implementations§
  - impl ReflectDeserialize
    - pub fn deserialize<'de, D>( &self, deserializer: D, ) -> Result<Box<dyn Reflect>, <D as Deserializer<'de>>::Error>where D: Deserializer<'de>,
- Trait Implementations§
  - impl Clone for ReflectDeserialize
    - fn clone(&self) -> ReflectDeserialize
    - fn clone_from(&mut self, source: &Self)
  - impl<T> FromType<T> for ReflectDeserializewhere T: for<'a> Deserialize<'a> + Reflect,

A struct used to deserialize reflected instances of a type.

A ReflectDeserialize for type T can be obtained via FromType::from_type.

Function used by ReflectDeserialize::deserialize to perform deserialization.

Deserializes a reflected value.

The underlying type of the reflected value, and thus the expected structure of the serialized data, is determined by the type used to construct this ReflectDeserialize value.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectDeserialize {
    pub func: fn(&mut dyn Deserializer<'_>) -> Result<Box<dyn Reflect>, Error>,
}
```

---

## Struct Startup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Startup.html

**Contents:**
- Struct Startup Copy item path
- Trait Implementations§
  - impl Clone for Startup
    - fn clone(&self) -> Startup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Startup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Startup
    - fn default() -> Startup
  - impl Hash for Startup

The schedule that runs once when the app starts.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Startup;
```

---

## Struct UiTransform Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiTransform.html

**Contents:**
- Struct UiTransform Copy item path
- Fields§
- Implementations§
  - impl UiTransform
    - pub const IDENTITY: UiTransform
    - pub const fn from_rotation(rotation: Rot2) -> UiTransform
      - Examples found in repository?
    - pub const fn from_translation(translation: Val2) -> UiTransform
    - pub const fn from_scale(scale: Vec2) -> UiTransform
    - pub fn compute_affine( &self, scale_factor: f32, base_size: Vec2, target_size: Vec2, ) -> Affine2

Relative 2D transform for UI nodes

UiGlobalTransform is automatically inserted whenever UiTransform is inserted.

Scale the node. A negative value reflects the node in that axis.

Rotate the node clockwise.

Creates a UI transform representing a rotation.

Creates a UI transform representing a responsive translation.

Creates a UI transform representing a scaling.

Resolves the translation from the given scale_factor, base_value, and target_size and returns a 2d affine transform from the resolved translation, and the UiTransform’s rotation, and scale.

Required Components: UiGlobalTransform.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiTransform {
    pub translation: Val2,
    pub scale: Vec2,
    pub rotation: Rot2,
}
```

Example 2 (unknown):
```unknown
102fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
103    // UI camera
104    commands.spawn(Camera2d);
105
106    // Root node filling the whole screen
107    commands.spawn((
108        Node {
109            width: percent(100),
110            height: percent(100),
111            align_items: AlignItems::Center,
112            justify_content: JustifyContent::Center,
113            ..default()
114        },
115        BackgroundColor(Color::BLACK),
116        children![(
117            Node {
118                align_items: AlignItems::Center,
119                justify_co
...
```

---

## Type Alias EventReader Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.EventReader.html

**Contents:**
- Type Alias EventReader Copy item path
- Aliased Type§

This is deprecated. See MessageReader

**Examples:**

Example 1 (unknown):
```unknown
pub type EventReader<'w, 's, E> = MessageReader<'w, 's, E>;
```

Example 2 (unknown):
```unknown
pub struct EventReader<'w, 's, E> { /* private fields */ }
```

---

## Struct Main Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.Main.html

**Contents:**
- Struct Main Copy item path
- §Rendering
- Implementations§
  - impl Main
    - pub fn run_main(world: &mut World, run_at_least_once: Local<'_, bool>)
- Trait Implementations§
  - impl Clone for Main
    - fn clone(&self) -> Main
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Main

The schedule that contains the app logic that is evaluated each tick of App::update().

By default, it will run the following schedules in the given order:

On the first run of the schedule (and only on the first run), it will run:

Note rendering is not executed in the main schedule by default. Instead, rendering is performed in a separate SubApp which exchanges data with the main app in between the main schedule runs.

See RenderPlugin and PipelinedRenderingPlugin for more details.

StateTransition is inserted only if you have bevy_state feature enabled. It is enabled in default features. ↩ 1 2

A system that runs the “main schedule”

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Main;
```

---

## Struct TextureAtlasLayout Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextureAtlasLayout.html

**Contents:**
- Struct TextureAtlasLayout Copy item path
- Fields§
- Implementations§
  - impl TextureAtlasLayout
    - pub fn new_empty(dimensions: UVec2) -> TextureAtlasLayout
    - pub fn from_grid( tile_size: UVec2, columns: u32, rows: u32, padding: Option<UVec2>, offset: Option<UVec2>, ) -> TextureAtlasLayout
      - §Arguments
      - Examples found in repository?
    - pub fn add_texture(&mut self, rect: URect) -> usize
      - §Arguments

Stores a map used to lookup the position of a texture in a TextureAtlas. This can be used to either use and look up a specific section of a texture, or animate frame-by-frame as a sprite sheet.

Optionally it can store a mapping from sub texture handles to the related area index (see TextureAtlasBuilder).

Example usage animating sprite. Example usage animating sprite in response to an event. Example usage loading sprite sheet.

Total size of texture atlas.

The specific areas of the atlas where each texture can be found

Create a new empty layout with custom dimensions

Generate a TextureAtlasLayout as a grid where each tile_size by tile_size grid-cell is one of the section in the atlas. Grid cells are separated by some padding, and the grid starts at offset pixels from the top left corner. Resulting layout is indexed left to right, top to bottom.

Add a section to the list in the layout and returns its index which can be used with TextureAtlas

The number of textures in the TextureAtlasLayout

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureAtlasLayout {
    pub size: UVec2,
    pub textures: Vec<URect>,
}
```

Example 2 (javascript):
```javascript
42fn setup(
43    mut commands: Commands,
44    asset_server: Res<AssetServer>,
45    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
46) {
47    let texture = asset_server.load("textures/rpg/chars/gabe/gabe-idle-run.png");
48    let layout = TextureAtlasLayout::from_grid(UVec2::splat(24), 7, 1, None, None);
49    let texture_atlas_layout = texture_atlas_layouts.add(layout);
50    // Use only the subset of sprites in the sheet that make up the run animation
51    let animation_indices = AnimationIndices { first: 1, last: 6 };
52
53    commands.spawn(Camera2d);
54
55    commands.
...
```

Example 3 (javascript):
```javascript
122fn setup_atlas(
123    mut commands: Commands,
124    asset_server: Res<AssetServer>,
125    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
126) {
127    let texture_handle = asset_server.load("textures/rpg/chars/gabe/gabe-idle-run.png");
128    let layout = TextureAtlasLayout::from_grid(UVec2::new(24, 24), 7, 1, None, None);
129    let texture_atlas_layout_handle = texture_atlas_layouts.add(layout);
130    // Use only the subset of sprites in the sheet that make up the run animation
131    let animation_indices = AnimationIndices { first: 1, last: 6 };
132    commands
133  
...
```

Example 4 (javascript):
```javascript
31fn setup_cursor_icon(
32    mut commands: Commands,
33    asset_server: Res<AssetServer>,
34    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
35    window: Single<Entity, With<Window>>,
36) {
37    let layout =
38        TextureAtlasLayout::from_grid(UVec2::splat(64), 20, 10, Some(UVec2::splat(5)), None);
39    let texture_atlas_layout = texture_atlas_layouts.add(layout);
40
41    let animation_config = AnimationConfig::new(0, 199, 1, 4);
42
43    commands.entity(*window).insert((
44        CursorIcon::Custom(CustomCursor::Image(CustomCursorImage {
45            // Image to 
...
```

---

## Struct StateTransition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.StateTransition.html

**Contents:**
- Struct StateTransition Copy item path
- Trait Implementations§
  - impl Clone for StateTransition
    - fn clone(&self) -> StateTransition
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for StateTransition
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for StateTransition
    - fn default() -> StateTransition
  - impl Hash for StateTransition

Runs state transitions.

By default, it will be triggered once before PreStartup and then each frame after PreUpdate, but you can manually trigger it at arbitrary times by creating an exclusive system to run the schedule.

This schedule is split up into four phases, as described in StateTransitionSteps.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct StateTransition;
```

Example 2 (javascript):
```javascript
use bevy_state::prelude::*;
use bevy_ecs::prelude::*;

fn run_state_transitions(world: &mut World) {
    let _ = world.try_run_schedule(StateTransition);
}
```

---

## Type Alias OnInsert Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.OnInsert.html

**Contents:**
- Type Alias OnInsert Copy item path
- Aliased Type§
- Fields§

Deprecated in favor of Insert.

The entity this component was inserted into.

**Examples:**

Example 1 (unknown):
```unknown
pub type OnInsert = Insert;
```

Example 2 (unknown):
```unknown
pub struct OnInsert {
    pub entity: Entity,
}
```

---

## Struct CubicInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicInCurve.html

**Contents:**
- Struct CubicInCurve Copy item path
- Trait Implementations§
  - impl Clone for CubicInCurve
    - fn clone(&self) -> CubicInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for CubicInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

This is the Hermite interpolator for

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicInCurve;
```

---

## Trait Plugins Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/trait.Plugins.html

**Contents:**
- Trait Plugins Copy item path
- Implementors§
  - impl<Marker, T> Plugins<Marker> for Twhere T: Plugins<Marker>,

Types that represent a set of Plugins.

This is implemented for all types which implement Plugin, PluginGroup, and tuples over Plugins.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Plugins<Marker>: Plugins<Marker> { }
```

---

## Struct UVec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UVec3.html

**Contents:**
- Struct UVec3 Copy item path
- Fields§
- Implementations§
  - impl UVec3
    - pub const ZERO: UVec3
    - pub const ONE: UVec3
    - pub const MIN: UVec3
    - pub const MAX: UVec3
    - pub const X: UVec3
    - pub const Y: UVec3

A 3-dimensional vector.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z]

Creates a vector from the first 3 values in slice.

Panics if slice is less than 3 elements long.

Writes the elements of self to the first 3 elements in slice.

Panics if slice is less than 3 elements long.

Creates a 4D vector from self and the given w value.

Creates a 2D vector from the x and y elements of self, discarding z.

Truncation may also be performed by using self.xy().

Creates a 3D vector from self with the given value of x.

Creates a 3D vector from self with the given value of y.

Creates a 3D vector from self with the given value of z.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Computes the cross product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

Component-wise clamping of values, similar to u32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

Returns the index of the first minimum element of self.

Returns the index of the first maximum element of self.

Returns the sum of all elements of self.

In other words, this computes self.x + self.y + ...

Returns the product of all elements of self.

In other words, this computes self.x * self.y * ...

Returns a vector mask containing the result of a == comparison for each element of self and rhs.

In other words, this computes [self.x == rhs.x, self.y == 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct UVec3 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
```

Example 2 (javascript):
```javascript
320    pub fn draw_gizmos(mut gizmos: Gizmos) {
321        gizmos.cuboid(
322            Transform::from_translation(Vec3::X * -1.75).with_scale(Vec3::splat(1.25)),
323            RED,
324        );
325        gizmos
326            .sphere(Isometry3d::from_translation(Vec3::X * -3.5), 0.75, GREEN)
327            .resolution(30_000 / 3);
328
329        // 3d grids with all variations of outer edges on or off
330        for i in 0..8 {
331            let x = 1.5 * (i % 4) as f32;
332            let y = 1.0 * (0.5 - (i / 4) as f32);
333            let mut grid = gizmos.grid_3d(
334               
...
```

Example 3 (javascript):
```javascript
38fn setup(mut commands: Commands, mut images: ResMut<Assets<Image>>) {
39    commands.spawn(Camera2d);
40
41    // Create an image that we are going to draw into
42    let mut image = Image::new_fill(
43        // 2D image of size 256x256
44        Extent3d {
45            width: IMAGE_WIDTH,
46            height: IMAGE_HEIGHT,
47            depth_or_array_layers: 1,
48        },
49        TextureDimension::D2,
50        // Initialize it with a beige color
51        &(css::BEIGE.to_u8_array()),
52        // Use the same encoding as the color we set
53        TextureFormat::Rgba8UnormSrgb,
54 
...
```

Example 4 (javascript):
```javascript
525fn create_cubes(
526    image_assets: Res<Assets<Image>>,
527    mut commands: Commands,
528    irradiance_volumes: Query<(&IrradianceVolume, &GlobalTransform)>,
529    voxel_cube_parents: Query<Entity, With<VoxelCubeParent>>,
530    voxel_cubes: Query<Entity, With<VoxelCube>>,
531    example_assets: Res<ExampleAssets>,
532    mut voxel_visualization_material_assets: ResMut<Assets<VoxelVisualizationMaterial>>,
533) {
534    // If voxel cubes have already been spawned, don't do anything.
535    if !voxel_cubes.is_empty() {
536        return;
537    }
538
539    let Some(voxel_cube_parent) = 
...
```

---

## Struct BVec3A Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BVec3A.html

**Contents:**
- Struct BVec3A Copy item path
- Implementations§
  - impl BVec3A
    - pub const FALSE: BVec3A
    - pub const TRUE: BVec3A
    - pub const fn new(x: bool, y: bool, z: bool) -> BVec3A
    - pub const fn splat(v: bool) -> BVec3A
    - pub const fn from_array(a: [bool; 3]) -> BVec3A
    - pub fn bitmask(self) -> u32
    - pub fn any(self) -> bool

A 3-dimensional SIMD vector mask.

This type is 16 byte aligned.

Creates a new vector mask.

Creates a vector mask with all elements set to v.

Creates a new vector mask from a bool array.

Returns a bitmask with the lowest 3 bits set from the elements of self.

A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc.

Returns true if any of the elements are true, false otherwise.

Returns true if all the elements are true, false otherwise.

Tests the value at index.

Panics if index is greater than 2.

Sets the element at index.

Panics if index is greater than 2.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BVec3A(/* private fields */);
```

---

## Struct ScrollPosition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ScrollPosition.html

**Contents:**
- Struct ScrollPosition Copy item path
- Tuple Fields§
- Implementations§
  - impl ScrollPosition
    - pub const DEFAULT: ScrollPosition
- Methods from Deref<Target = Vec2>§
    - pub const ZERO: Vec2
    - pub const ONE: Vec2
    - pub const NEG_ONE: Vec2
    - pub const MIN: Vec2

The scroll position of the node. Values are in logical pixels, increasing from top-left to bottom-right.

Increasing the x-coordinate causes the scrolled content to visibly move left on the screen, while increasing the y-coordinate causes the scrolled content to move up. This might seem backwards, however what’s really happening is that the scroll position is moving the visible “window” in the local coordinate system of the scrolled content - moving the window down causes the content to move up.

Updating the values of ScrollPosition will reposition the children of the node by the offset amount in logical pixels. ScrollPosition may be updated by the layout system when a layout change makes a previously valid ScrollPosition invalid. Changing this does nothing on a Node without setting at least one OverflowAxis to OverflowAxis::Scroll.

Converts self to [x, y]

Moves towards rhs based on the value d.

When d is 0.0, the result will be equal to self. When d is equal to self.distance(rhs), the result will be equal to rhs. Will not go past rhs.

Rotates towards rhs up to max_angle (in radians).

When max_angle is 0.0, the result will be equal to self. When max_angle is equal to self.angle_between(rhs), the result will be parallel to rhs. If max_angle is negative, rotates towards the exact opposite of rhs. Will not go past the target.

Casts all elements of self to f64.

Casts all elements of self to i8.

Casts all elements of self to u8.

Casts all elements of self to i16.

Casts all elements of self to u16.

Casts all elements of self to i32.

Casts all elements of self to u32.

Casts all elements of self to i64.

Casts all elements of self to u64.

Casts all elements of self to usize.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ScrollPosition(pub Vec2);
```

Example 2 (javascript):
```javascript
121fn setup(
122    mut commands: Commands,
123    mut meshes: ResMut<Assets<Mesh>>,
124    mut materials: ResMut<Assets<ColorMaterial>>,
125    window: Single<&Window>,
126) {
127    let window_size = window.resolution.physical_size().as_vec2();
128
129    // Initialize centered, non-window-filling viewport
130    commands.spawn((
131        Camera2d,
132        Camera {
133            viewport: Some(Viewport {
134                physical_position: (window_size * 0.125).as_uvec2(),
135                physical_size: (window_size * 0.75).as_uvec2(),
136                ..default()
137           
...
```

---

## Struct TerminalCtrlCHandlerPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.TerminalCtrlCHandlerPlugin.html

**Contents:**
- Struct TerminalCtrlCHandlerPlugin Copy item path
- Implementations§
  - impl TerminalCtrlCHandlerPlugin
    - pub fn gracefully_exit()
    - pub fn exit_on_flag(app_exit_writer: MessageWriter<'_, AppExit>)
- Trait Implementations§
  - impl Default for TerminalCtrlCHandlerPlugin
    - fn default() -> TerminalCtrlCHandlerPlugin
  - impl Plugin for TerminalCtrlCHandlerPlugin
    - fn build(&self, app: &mut App)

Gracefully handles Ctrl+C by emitting a AppExit event. This plugin is part of the DefaultPlugins.

If you want to setup your own Ctrl+C handler, you should call the TerminalCtrlCHandlerPlugin::gracefully_exit function in your handler if you want bevy to gracefully exit.

Sends the AppExit event to all apps using this plugin to make them gracefully exit.

Sends a AppExit event when the user presses Ctrl+C on the terminal.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TerminalCtrlCHandlerPlugin;
```

Example 2 (unknown):
```unknown
fn main() {
    App::new()
        .add_plugins(MinimalPlugins)
        .add_plugins(TerminalCtrlCHandlerPlugin)
        .run();
}
```

Example 3 (unknown):
```unknown
fn main() {
    // Your own `Ctrl+C` handler
    ctrlc::set_handler(move || {
        // Other clean up code ...

        TerminalCtrlCHandlerPlugin::gracefully_exit();
    });

    App::new()
        .add_plugins(DefaultPlugins)
        .run();
}
```

---

## Struct Has Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Has.html

**Contents:**
- Struct Has Copy item path
- §Footguns
- §Examples
- Trait Implementations§
  - impl<T> Debug for Has<T>
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<T> QueryData for Has<T>where T: Component,
    - const IS_READ_ONLY: bool = true
    - type ReadOnly = Has<T>
    - type Item<'w, 's> = bool

Returns a bool that describes if an entity has the component T.

This can be used in a Query if you want to know whether or not entities have the component T but don’t actually care about the component’s value.

Note that a Query<Has<T>> will match all existing entities. Beware! Even if it matches all entities, it doesn’t mean that query.get(entity) will always return Ok(bool).

In the case of a non-existent entity, such as a despawned one, it will return Err. A workaround is to replace query.get(entity).unwrap() by query.get(entity).unwrap_or_default().

SAFETY: Self is the same as Self::ReadOnly

SAFETY: update_component_access does nothing. This is sound because fetch does not access components.

SAFETY: Has is read only

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Has<T>(/* private fields */);
```

Example 2 (unknown):
```unknown
fn food_entity_system(query: Query<(&Name, Has<IsHungry>) >) {
    for (name, is_hungry) in &query {
        if is_hungry{
            println!("{} would like some food.", name.name);
        } else {
            println!("{} has had sufficient.", name.name);
        }
    }
}
```

Example 3 (unknown):
```unknown
// Unlike `Option<&T>`, `Has<T>` is compatible with `&mut T`
// as it does not actually access any data.
fn alphabet_entity_system(mut alphas: Query<(&mut Alpha, Has<Beta>)>, mut betas: Query<(&mut Beta, Has<Alpha>)>) {
    for (mut alpha, has_beta) in alphas.iter_mut() {
        alpha.has_beta = has_beta;
    }
    for (mut beta, has_alpha) in betas.iter_mut() {
        beta.has_alpha = has_alpha;
    }
}
```

---

## Struct VertexAttribute Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/render/render_resource/struct.VertexAttribute.html

**Contents:**
- Struct VertexAttribute Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for VertexAttribute
    - fn clone(&self) -> VertexAttribute
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for VertexAttribute
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'de> Deserialize<'de> for VertexAttribute
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<VertexAttribute, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,

Vertex inputs (attributes) to shaders.

These are used to specify the individual attributes within a VertexBufferLayout. See its documentation for an example.

The vertex_attr_array! macro can help create these with appropriate offsets.

Corresponds to WebGPU GPUVertexAttribute.

Byte offset of the start of the input

Location for this input. Must match the location in the shader.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct VertexAttribute {
    pub format: VertexFormat,
    pub offset: u64,
    pub shader_location: u32,
}
```

---

## Function ivec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.ivec3.html

**Contents:**
- Function ivec3 Copy item path

Creates a 3-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn ivec3(x: i32, y: i32, z: i32) -> IVec3
```

---

## Struct QuadraticInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuadraticInOutCurve.html

**Contents:**
- Struct QuadraticInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for QuadraticInOutCurve
    - fn clone(&self) -> QuadraticInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuadraticInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as QuadraticIn for t < 0.5 and as QuadraticOut for t >= 0.5

A quadratic has too low of a degree to be both an InOut and C², so consider using at least a cubic (such as SmoothStepCurve) if you want the acceleration to be continuous.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuadraticInOutCurve;
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/window/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§

The windowing prelude.

This includes the most common types in this crate, re-exported for your convenience.

---

## Trait Reflect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Reflect.html

**Contents:**
- Trait Reflect Copy item path
- Required Methods§
    - fn into_any(self: Box<Self>) -> Box<dyn Any>
    - fn as_any(&self) -> &(dyn Any + 'static)
    - fn as_any_mut(&mut self) -> &mut (dyn Any + 'static)
    - fn into_reflect(self: Box<Self>) -> Box<dyn Reflect>
    - fn as_reflect(&self) -> &(dyn Reflect + 'static)
    - fn as_reflect_mut(&mut self) -> &mut (dyn Reflect + 'static)
    - fn set(&mut self, value: Box<dyn Reflect>) -> Result<(), Box<dyn Reflect>>
- Implementations§

A core trait of bevy_reflect, used for downcasting to concrete types.

This is a subtrait of PartialReflect, meaning any type which implements Reflect implements PartialReflect by definition.

It’s recommended to use the derive macro rather than manually implementing this trait. Doing so will automatically implement this trait, PartialReflect, and many other useful traits for reflection, including one of the appropriate subtraits: Struct, TupleStruct or Enum.

If you need to use this trait as a generic bound along with other reflection traits, for your convenience, consider using Reflectable instead.

See the crate-level documentation to see how this trait can be used.

Returns the value as a Box<dyn Any>.

For remote wrapper types, this will return the remote type instead.

Returns the value as a &dyn Any.

For remote wrapper types, this will return the remote type instead.

Returns the value as a &mut dyn Any.

For remote wrapper types, this will return the remote type instead.

Casts this type to a boxed, fully-reflected value.

Casts this type to a fully-reflected value.

Casts this type to a mutable, fully-reflected value.

Performs a type-checked assignment of a reflected value to this value.

If value does not contain a value of type T, returns an Err containing the trait object.

Downcasts the value to type T, consuming the trait object.

If the underlying value is not of type T, returns Err(self).

For remote types, T should be the type itself rather than the wrapper type.

Downcasts the value to type T, unboxing and consuming the trait object.

If the underlying value is not of type T, returns Err(self).

For remote types, T should be the type itself rather than the wrapper type.

Returns true if the underlying value is of type T, or false otherwise.

The underlying value is the concrete type that is stored in this dyn object; it can be downcast to. In the case that this underlying value “represents” a different type, like the Dynamic*** types do, you can call represents to determine what type they represent. Represented types cannot be downcast to, but you can use FromReflect to create a value of the represented type from them.

For remote types, T should be the type itself rather than the wrapper type.

Downcasts the value to type T by reference.

If the underlying value is not of type T, returns None.

For remote types, T should be the type itself rather than the wrapper type.

Downcasts the value to type T by mutable reference.

If the underl

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait Reflect:
    PartialReflect
    + DynamicTyped
    + Any {
    // Required methods
    fn into_any(self: Box<Self>) -> Box<dyn Any>;
    fn as_any(&self) -> &(dyn Any + 'static);
    fn as_any_mut(&mut self) -> &mut (dyn Any + 'static);
    fn into_reflect(self: Box<Self>) -> Box<dyn Reflect>;
    fn as_reflect(&self) -> &(dyn Reflect + 'static);
    fn as_reflect_mut(&mut self) -> &mut (dyn Reflect + 'static);
    fn set(&mut self, value: Box<dyn Reflect>) -> Result<(), Box<dyn Reflect>>;
}
```

Example 2 (javascript):
```javascript
67fn setup() {
68    let mut z = <HashMap<_, _>>::default();
69    z.insert("Hello".to_string(), 1.0);
70    let value: Box<dyn Reflect> = Box::new(A {
71        x: 1,
72        y: vec![1, 2],
73        z,
74    });
75
76    // There are a number of different "reflect traits", which each expose different operations on
77    // the underlying type
78    match value.reflect_ref() {
79        // `Struct` is a trait automatically implemented for structs that derive Reflect. This trait
80        // allows you to interact with fields via their string names or indices
81        ReflectRef::Struct(val
...
```

Example 3 (javascript):
```javascript
6fn main() {
7    // Bevy supports statically registering custom attribute data on reflected types,
8    // which can then be accessed at runtime via the type's `TypeInfo`.
9    // Attributes are registered using the `#[reflect(@...)]` syntax,
10    // where the `...` is any expression that resolves to a value which implements `Reflect`.
11    // Note that these attributes are stored based on their type:
12    // if two attributes have the same type, the second one will overwrite the first.
13
14    // Here is an example of registering custom attributes on a type:
15    #[derive(Reflect)]
16  
...
```

Example 4 (javascript):
```javascript
54fn setup(type_registry: Res<AppTypeRegistry>) {
55    let mut value = Foo {
56        a: 1,
57        _ignored: NonReflectedValue { _a: 10 },
58        nested: Bar { b: 8 },
59    };
60
61    // You can set field values like this. The type must match exactly or this will fail.
62    *value.get_field_mut("a").unwrap() = 2usize;
63    assert_eq!(value.a, 2);
64    assert_eq!(*value.get_field::<usize>("a").unwrap(), 2);
65
66    // You can also get the `&dyn PartialReflect` value of a field like this
67    let field = value.field("a").unwrap();
68
69    // But values introspected via `PartialRe
...
```

---

## Function bvec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.bvec4.html

**Contents:**
- Function bvec4 Copy item path

Creates a 4-dimensional bool vector mask.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn bvec4(x: bool, y: bool, z: bool, w: bool) -> BVec4
```

---

## Struct Children Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Children.html

**Contents:**
- Struct Children Copy item path
- §Usage
- Implementations§
  - impl Children
    - pub fn swap(&mut self, a_index: usize, b_index: usize)
    - pub fn sort_by<F>(&mut self, compare: F)where F: FnMut(&Entity, &Entity) -> Ordering,
    - pub fn sort_by_key<K, F>(&mut self, compare: F)where F: FnMut(&Entity) -> K, K: Ord,
    - pub fn sort_by_cached_key<K, F>(&mut self, compare: F)where F: FnMut(&Entity) -> K, K: Ord,
    - pub fn sort_unstable_by<F>(&mut self, compare: F)where F: FnMut(&Entity, &Entity) -> Ordering,
    - pub fn sort_unstable_by_key<K, F>(&mut self, compare: F)where F: FnMut(&Entity) -> K, K: Ord,

Tracks which entities are children of this parent entity.

A RelationshipTarget collection component that is populated with entities that “target” this entity with the ChildOf Relationship component.

Together, these components form the “canonical parent-child hierarchy”. See the ChildOf component for the full description of this relationship and instructions on how to use it.

Like all RelationshipTarget components, this data should not be directly manipulated to avoid desynchronization. Instead, modify the ChildOf components on the “source” entities.

To access the children of an entity, you can iterate over the Children component, using the IntoIterator trait. For more complex access patterns, see the RelationshipTarget trait.

Swaps the child at a_index with the child at b_index.

Sorts children stably in place using the provided comparator function.

For the underlying implementation, see slice::sort_by.

For the unstable version, see sort_unstable_by.

See also sort_by_key, sort_by_cached_key.

Sorts children stably in place using the provided key extraction function.

For the underlying implementation, see slice::sort_by_key.

For the unstable version, see sort_unstable_by_key.

See also sort_by, sort_by_cached_key.

Sorts children stably in place using the provided key extraction function. Only evaluates each key at most once per sort, caching the intermediate results in memory.

For the underlying implementation, see slice::sort_by_cached_key.

See also sort_by, sort_by_key.

Sorts children unstably in place using the provided comparator function.

For the underlying implementation, see slice::sort_unstable_by.

For the stable version, see sort_by.

See also sort_unstable_by_key.

Sorts children unstably in place using the provided key extraction function.

For the underlying implementation, see slice::sort_unstable_by_key.

For the stable version, see sort_by_key.

See also sort_unstable_by.

Returns the number of elements in the slice.

Returns true if the slice has a length of 0.

Returns the first element of the slice, or None if it is empty.

Returns the first and all the rest of the elements of the slice, or None if it is empty.

Returns the last and all the rest of the elements of the slice, or None if it is empty.

Returns the last element of the slice, or None if it is empty.

Returns an array reference to the first N items in the slice.

If the slice is not at least N in length, this will return None.

Returns an array reference to the f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Children(/* private fields */);
```

Example 2 (javascript):
```javascript
let a = [1, 2, 3];
assert_eq!(a.len(), 3);
```

Example 3 (javascript):
```javascript
let a = [1, 2, 3];
assert!(!a.is_empty());

let b: &[i32] = &[];
assert!(b.is_empty());
```

Example 4 (javascript):
```javascript
let v = [10, 40, 30];
assert_eq!(Some(&10), v.first());

let w: &[i32] = &[];
assert_eq!(None, w.first());
```

---

## Struct MeshMaterial2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshMaterial2d.html

**Contents:**
- Struct MeshMaterial2d Copy item path
- §Example
- Tuple Fields§
- Methods from Deref<Target = Handle<M>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§

A material used for rendering a Mesh2d.

See Material2d for general information about 2D materials and how to implement your own materials.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshMaterial2d<M>(pub Handle<M>)
where
    M: Material2d;
```

Example 2 (unknown):
```unknown
// Spawn an entity with a mesh using `ColorMaterial`.
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    commands.spawn((
        Mesh2d(meshes.add(Circle::new(50.0))),
        MeshMaterial2d(materials.add(ColorMaterial::from_color(RED))),
    ));
}
```

Example 3 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 4 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

---

## Struct Added Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Added.html

**Contents:**
- Struct Added Copy item path
- §Deferred
- §Time complexity
- §Examples
- Trait Implementations§
  - impl<T> QueryFilter for Added<T>where T: Component,
    - const IS_ARCHETYPAL: bool = false
    - unsafe fn filter_fetch( _state: &<Added<T> as WorldQuery>::State, fetch: &mut <Added<T> as WorldQuery>::Fetch<'_>, entity: Entity, table_row: TableRow, ) -> bool
  - impl<T> WorldQuery for Added<T>where T: Component,
    - const IS_DENSE: bool

A filter on a component that only retains results the first time after they have been added.

A common use for this filter is one-time initialization.

To retain all results without filtering but still check whether they were added after the system last ran, use Ref<T>.

Note that this includes changes that happened before the first time this Query was run.

Note, that entity modifications issued with Commands are visible only after deferred operations are applied, typically after the system that queued them.

Added is not ArchetypeFilter, which practically means that if the query (with T component filter) matches a million entities, Added<T> filter will iterate over all of them even if none of them were just added.

For example, these two systems are roughly equivalent in terms of performance:

SAFETY: QueryFilter::filter_fetch accesses a single component in a readonly way. This is sound because update_component_access adds read access for that component and panics when appropriate. update_component_access adds a With filter for a component. This is sound because matches_component_set returns whether the set contains that component.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Added<T>(/* private fields */);
```

Example 2 (unknown):
```unknown
fn system1(q: Query<&MyComponent, Added<Transform>>) {
    for item in &q { /* component added */ }
}

fn system2(q: Query<(&MyComponent, Ref<Transform>)>) {
    for item in &q {
        if item.1.is_added() { /* component added */ }
    }
}
```

Example 3 (unknown):
```unknown
fn print_add_name_component(query: Query<&Name, Added<Name>>) {
    for name in &query {
        println!("Named entity created: {:?}", name)
    }
}
```

---

## Struct SerializedAnimationGraphNode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SerializedAnimationGraphNode.html

**Contents:**
- Struct SerializedAnimationGraphNode Copy item path
- Fields§
- Trait Implementations§
  - impl<'de> Deserialize<'de> for SerializedAnimationGraphNode
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<SerializedAnimationGraphNode, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,
  - impl Serialize for SerializedAnimationGraphNode
    - fn serialize<__S>( &self, __serializer: __S, ) -> Result<<__S as Serializer>::Ok, <__S as Serializer>::Error>where __S: Serializer,
- Auto Trait Implementations§
  - impl Freeze for SerializedAnimationGraphNode
  - impl RefUnwindSafe for SerializedAnimationGraphNode

A version of AnimationGraphNode suitable for serializing as an asset.

See the comments in SerializedAnimationGraph for more information.

Corresponds to the node_type field on AnimationGraphNode.

Corresponds to the mask field on AnimationGraphNode.

Corresponds to the weight field on AnimationGraphNode.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SerializedAnimationGraphNode {
    pub node_type: SerializedAnimationNodeType,
    pub mask: u64,
    pub weight: f32,
}
```

---

## Macro error Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.error.html

**Contents:**
- Macro error Copy item path
- §Examples

Constructs an event at the error level.

This functions similarly to the event! macro. See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! error {
    (name: $name:expr, target: $target:expr, parent: $parent:expr, { $($field:tt)* }, $($arg:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, ?$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, %$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($arg:tt)+ ) => { ... };
    (name: $name:expr, target: $target:expr, 
...
```

Example 2 (javascript):
```javascript
use tracing::error;

let (err_info, port) = ("No connection", 22);

error!(port, error = %err_info);
error!(target: "app_events", "App Error: {}", err_info);
error!({ info = err_info }, "error on port: {}", port);
error!(name: "invalid_input", "Invalid input: {}", err_info);
```

---

## Enum AlignItems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AlignItems.html

**Contents:**
- Enum AlignItems Copy item path
- Variants§
  - Default
  - Start
  - End
  - FlexStart
  - FlexEnd
  - Center
  - Baseline
  - Stretch

Used to control how each individual item is aligned by default within the space they’re given.

https://developer.mozilla.org/en-US/docs/Web/CSS/align-items

The items are packed in their default position as if no alignment was applied.

The items are packed towards the start of the axis.

The items are packed towards the end of the axis.

The items are packed towards the start of the axis, unless the flex direction is reversed; then they are packed towards the end of the axis.

The items are packed towards the end of the axis, unless the flex direction is reversed; then they are packed towards the start of the axis.

The items are packed along the center of the axis.

The items are packed such that their baselines align.

The items are stretched to fill the space they’re given.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AlignItems {
    Default,
    Start,
    End,
    FlexStart,
    FlexEnd,
    Center,
    Baseline,
    Stretch,
}
```

---

## Trait EntityCommand Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.EntityCommand.html

**Contents:**
- Trait EntityCommand Copy item path
- §Examples
- Required Methods§
    - fn apply(self, entity: EntityWorldMut<'_>) -> Out
- Implementors§
  - impl<Out, F> EntityCommand<Out> for Fwhere F: FnOnce(EntityWorldMut<'_>) -> Out + Send + 'static,

A command which gets executed for a given Entity.

Should be used with EntityCommands::queue.

The Out generic parameter is the returned “output” of the command.

Executes this command for the given Entity.

**Examples:**

Example 1 (unknown):
```unknown
pub trait EntityCommand<Out = ()>: Send + 'static {
    // Required method
    fn apply(self, entity: EntityWorldMut<'_>) -> Out;
}
```

Example 2 (javascript):
```javascript
use bevy_ecs::system::EntityCommand;

#[derive(Resource, Default)]
struct Counter(i64);

/// A `Command` which names an entity based on a global counter.
fn count_name(mut entity: EntityWorldMut) {
    // Get the current value of the counter, and increment it for next time.
    let i = {
        let mut counter = entity.resource_mut::<Counter>();
        let i = counter.0;
        counter.0 += 1;
        i
    };
    // Name the entity after the value of the counter.
    entity.insert(Name::new(format!("Entity #{i}")));
}

// App creation boilerplate omitted...

fn setup(mut commands: Commands
...
```

---

## Enum AssetId Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AssetId.html

**Contents:**
- Enum AssetId Copy item path
- Variants§
  - Index
    - Fields
  - Uuid
    - Fields
- Implementations§
  - impl<A> AssetId<A>where A: Asset,
    - pub const DEFAULT_UUID: Uuid
    - pub const INVALID_UUID: Uuid

A unique runtime-only identifier for an Asset. This is cheap to Copy/Clone and is not directly tied to the lifetime of the Asset. This means it can point to an Asset that no longer exists.

For an identifier tied to the lifetime of an asset, see Handle.

For an “untyped” / “generic-less” id, see UntypedAssetId.

A small / efficient runtime identifier that can be used to efficiently look up an asset stored in Assets. This is the “default” identifier used for assets. The alternative(s) (ex: AssetId::Uuid) will only be used if assets are explicitly registered that way.

The unstable, opaque index of the asset.

A marker to store the type information of the asset.

A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in Assets with one.

The UUID provided during asset registration.

The uuid for the default AssetId. It is valid to assign a value to this in Assets and by convention (where appropriate) assets should support this pattern.

This asset id should never be valid. Assigning a value to this in Assets will produce undefined behavior, so don’t do it!

Returns an AssetId with Self::INVALID_UUID, which should never be assigned to.

Converts this to an “untyped” / “generic-less” Asset identifier that stores the type information inside the UntypedAssetId.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AssetId<A>where
    A: Asset,{
    Index {
        index: AssetIndex,
        marker: PhantomData<fn() -> A>,
    },
    Uuid {
        uuid: Uuid,
    },
}
```

Example 2 (javascript):
```javascript
215fn queue_custom_phase_item(
216    pipeline_cache: Res<PipelineCache>,
217    mut pipeline: ResMut<CustomPhasePipeline>,
218    mut opaque_render_phases: ResMut<ViewBinnedRenderPhases<Opaque3d>>,
219    opaque_draw_functions: Res<DrawFunctions<Opaque3d>>,
220    views: Query<(&ExtractedView, &RenderVisibleEntities, &Msaa)>,
221    mut next_tick: Local<Tick>,
222) {
223    let draw_custom_phase_item = opaque_draw_functions
224        .read()
225        .id::<DrawCustomPhaseItemCommands>();
226
227    // Render phases are per-view, so we need to iterate over all views so that
228    // the en
...
```

Example 3 (javascript):
```javascript
230fn extract_image_materials(
231    mut material_instances: ResMut<RenderMaterialInstances>,
232    changed_meshes_query: Extract<
233        Query<
234            (Entity, &ViewVisibility, &ImageMaterial3d),
235            Or<(Changed<ViewVisibility>, Changed<ImageMaterial3d>)>,
236        >,
237    >,
238) {
239    let last_change_tick = material_instances.current_change_tick;
240
241    for (entity, view_visibility, material) in &changed_meshes_query {
242        if view_visibility.get() {
243            material_instances.instances.insert(
244                entity.into(),
245           
...
```

Example 4 (javascript):
```javascript
215fn queue_custom_phase_item(
216    pipeline_cache: Res<PipelineCache>,
217    mut pipeline: ResMut<CustomPhasePipeline>,
218    mut opaque_render_phases: ResMut<ViewBinnedRenderPhases<Opaque3d>>,
219    opaque_draw_functions: Res<DrawFunctions<Opaque3d>>,
220    views: Query<(&ExtractedView, &RenderVisibleEntities, &Msaa)>,
221    mut next_tick: Local<Tick>,
222) {
223    let draw_custom_phase_item = opaque_draw_functions
224        .read()
225        .id::<DrawCustomPhaseItemCommands>();
226
227    // Render phases are per-view, so we need to iterate over all views so that
228    // the en
...
```

---

## Struct NonPathHandleError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.NonPathHandleError.html

**Contents:**
- Struct NonPathHandleError Copy item path
- Trait Implementations§
  - impl Debug for NonPathHandleError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for NonPathHandleError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for NonPathHandleError
    - fn source(&self) -> Option<&(dyn Error + 'static)>
    - fn description(&self) -> &str
    - fn cause(&self) -> Option<&dyn Error>

Error for when only path Handles are supported.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct NonPathHandleError;
```

---

## Struct BlendInput Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BlendInput.html

**Contents:**
- Struct BlendInput Copy item path
- Fields§
- Auto Trait Implementations§
  - impl<T> Freeze for BlendInput<T>where T: Freeze,
  - impl<T> RefUnwindSafe for BlendInput<T>where T: RefUnwindSafe,
  - impl<T> Send for BlendInput<T>where T: Send,
  - impl<T> Sync for BlendInput<T>where T: Sync,
  - impl<T> Unpin for BlendInput<T>where T: Unpin,
  - impl<T> UnwindSafe for BlendInput<T>where T: UnwindSafe,
- Blanket Implementations§

An individual input for Animatable::blend.

The individual item’s weight. This may not be bound to the range [0.0, 1.0].

The input value to be blended.

Whether or not to additively blend this input into the final result.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BlendInput<T> {
    pub weight: f32,
    pub value: T,
    pub additive: bool,
}
```

---

## Struct AnimationGraphNode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationGraphNode.html

**Contents:**
- Struct AnimationGraphNode Copy item path
- Fields§
- Implementations§
  - impl AnimationGraphNode
    - pub fn add_mask(&mut self, mask: u64) -> &mut AnimationGraphNode
    - pub fn remove_mask(&mut self, mask: u64) -> &mut AnimationGraphNode
    - pub fn add_mask_group(&mut self, group: u32) -> &mut AnimationGraphNode
    - pub fn remove_mask_group(&mut self, group: u32) -> &mut AnimationGraphNode
- Trait Implementations§
  - impl Clone for AnimationGraphNode

An individual node within an animation graph.

The AnimationGraphNode::node_type field specifies the type of node: one of a clip node, a blend node, or an add node. Clip nodes, the leaves of the graph, contain animation clips to play. Blend and add nodes describe how to combine their children to produce a final animation.

Animation node data specific to the type of node (clip, blend, or add).

In the case of clip nodes, this contains the actual animation clip associated with the node.

A bitfield specifying the mask groups that this node and its descendants will not affect.

A 0 in bit N indicates that this node and its descendants can animate animation targets in mask group N, while a 1 in bit N indicates that this node and its descendants cannot animate mask group N.

The weight of this node, which signifies its contribution in blending.

Note that this does not propagate down the graph hierarchy; rather, each Blend and Add node uses the weights of its children to determine the total animation that is accumulated at that node. The parent node’s weight is used only to determine the contribution of that total animation in further blending.

In other words, it is as if the blend node is replaced by a single clip node consisting of the blended animation with the weight specified at the blend node.

For animation clips, this weight is also multiplied by the active animation weight before being applied.

Masks out the mask groups specified by the given mask bitfield.

A 1 in bit position N causes this function to mask out mask group N, and thus neither this node nor its descendants will animate any animation targets that belong to group N.

Unmasks the mask groups specified by the given mask bitfield.

A 1 in bit position N causes this function to unmask mask group N, and thus this node and its descendants will be allowed to animate animation targets that belong to group N, unless another mask masks those targets out.

Masks out the single mask group specified by group.

After calling this function, neither this node nor its descendants will animate any animation targets that belong to the given group.

Unmasks the single mask group specified by group.

After calling this function, this node and its descendants will be allowed to animate animation targets that belong to the given group, unless another mask masks those targets out.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationGraphNode {
    pub node_type: AnimationNodeType,
    pub mask: u64,
    pub weight: f32,
}
```

---

## Trait PluginGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.PluginGroup.html

**Contents:**
- Trait PluginGroup Copy item path
- Required Methods§
    - fn build(self) -> PluginGroupBuilder
- Provided Methods§
    - fn name() -> String
    - fn set<T>(self, plugin: T) -> PluginGroupBuilderwhere T: Plugin,
      - Examples found in repository?
- Dyn Compatibility§
- Implementors§
  - impl PluginGroup for PluginGroupBuilder

Combines multiple Plugins into a single unit.

If you want an easier, but slightly more restrictive, method of implementing this trait, you may be interested in the plugin_group! macro.

Configures the Plugins that are to be added.

Configures a name for the PluginGroup which is primarily used for debugging.

Sets the value of the given Plugin, if it exists

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait PluginGroup: Sized {
    // Required method
    fn build(self) -> PluginGroupBuilder;

    // Provided methods
    fn name() -> String { ... }
    fn set<T>(self, plugin: T) -> PluginGroupBuilder
       where T: Plugin { ... }
}
```

Example 2 (unknown):
```unknown
5fn main() {
6    App::new()
7        .add_plugins(DefaultPlugins.set(PbrPlugin {
8            prepass_enabled: false,
9            ..default()
10        }))
11        .run();
12}
```

Example 3 (unknown):
```unknown
6fn main() {
7    App::new()
8        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
9            task_pool_options: TaskPoolOptions::with_num_threads(4),
10        }))
11        .run();
12}
```

Example 4 (unknown):
```unknown
8fn main() {
9    App::new()
10        .add_plugins(DefaultPlugins.set(WebAssetPlugin {
11            silence_startup_warning: true,
12        }))
13        .add_systems(Startup, setup)
14        .run();
15}
```

---

## Struct Allow Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Allow.html

**Contents:**
- Struct Allow Copy item path
- Trait Implementations§
  - impl<T> QueryFilter for Allow<T>where T: Component,
    - const IS_ARCHETYPAL: bool = true
    - unsafe fn filter_fetch( _: &<Allow<T> as WorldQuery>::State, _: &mut <Allow<T> as WorldQuery>::Fetch<'_>, _: Entity, _: TableRow, ) -> bool
  - impl<T> WorldQuery for Allow<T>where T: Component,
    - const IS_DENSE: bool = true
    - type Fetch<'w> = ()
    - type State = ComponentId
    - fn shrink_fetch<'wlong, 'wshort>( _: <Allow<T> as WorldQuery>::Fetch<'wlong>, ) -> <Allow<T> as WorldQuery>::Fetch<'wshort>where 'wlong: 'wshort,

Allows a query to contain entities with the component T, bypassing DefaultQueryFilters.

SAFETY: update_component_access does not add any accesses. This is sound because QueryFilter::filter_fetch does not access any components. update_component_access adds an archetypal filter for T. This is sound because it doesn’t affect the query

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Allow<T>(/* private fields */);
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/gizmos/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§
- Derive Macros§

This includes the most common types in this crate, re-exported for your convenience.

---

## Derive Macro Resource Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Resource.html

**Contents:**
- Derive Macro Resource Copy item path

Implement the Resource trait.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Resource)]
```

---

## Enum FogFalloff Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.FogFalloff.html

**Contents:**
- Enum FogFalloff Copy item path
  - §Convenience Methods
- Variants§
  - Linear
      - §Formula
    - Fields
  - Exponential
      - §Tips
      - §Formula
    - Fields

Allows switching between different fog falloff modes, and configuring their parameters.

When using non-linear fog modes it can be hard to determine the right parameter values for a given scene.

For easier artistic control, instead of creating the enum variants directly, you can use the visibility-based convenience methods:

For FogFalloff::Exponential:

For FogFalloff::ExponentialSquared:

For FogFalloff::Atmospheric:

A linear fog falloff that grows in intensity between start and end distances.

This falloff mode is simpler to control than other modes, however it can produce results that look “artificial”, depending on the scene.

The fog intensity for a given point in the scene is determined by the following formula:

Distance from the camera where fog is completely transparent, in world units.

Distance from the camera where fog is completely opaque, in world units.

An exponential fog falloff with a given density.

Initially gains intensity quickly with distance, then more slowly. Typically produces more natural results than FogFalloff::Linear, but is a bit harder to control.

To move the fog “further away”, use lower density values. To move it “closer” use higher density values.

The fog intensity for a given point in the scene is determined by the following formula:

Multiplier applied to the world distance (within the exponential fog falloff calculation).

A squared exponential fog falloff with a given density.

Similar to FogFalloff::Exponential, but grows more slowly in intensity for closer distances before “catching up”.

To move the fog “further away”, use lower density values. To move it “closer” use higher density values.

The fog intensity for a given point in the scene is determined by the following formula:

Multiplier applied to the world distance (within the exponential squared fog falloff calculation).

A more general form of the FogFalloff::Exponential mode. The falloff formula is separated into two terms, extinction and inscattering, for a somewhat simplified atmospheric scattering model. Additionally, individual color channels can have their own density values, resulting in a total of six different configuration parameters.

Unlike other modes, atmospheric falloff doesn’t use a simple intensity-based blend of fog color with object color. Instead, it calculates per-channel extinction and inscattering factors, which are then used to calculate the final color.

For a density value of D, the following two falloff modes will produce iden

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub enum FogFalloff {
    Linear {
        start: f32,
        end: f32,
    },
    Exponential {
        density: f32,
    },
    ExponentialSquared {
        density: f32,
    },
    Atmospheric {
        extinction: Vec3,
        inscattering: Vec3,
    },
}
```

Example 2 (text):
```text
let fog_intensity = 1.0 - ((end - distance) / (end - start)).clamp(0.0, 1.0);
```

Example 3 (text):
```text
let fog_intensity = 1.0 - 1.0 / (distance * density).exp();
```

Example 4 (text):
```text
let fog_intensity = 1.0 - 1.0 / (distance * density).squared().exp();
```

---

## Struct Single Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Single.html

**Contents:**
- Struct Single Copy item path
- §Example
- Implementations§
  - impl<'w, 's, D, F> Single<'w, 's, D, F>where D: QueryData, F: QueryFilter,
    - pub fn into_inner(self) -> <D as QueryData>::Item<'w, 's>
      - Examples found in repository?
- Trait Implementations§
  - impl<'w, 's, D, F> Deref for Single<'w, 's, D, F>where D: QueryData, F: QueryFilter,
    - type Target = <D as QueryData>::Item<'w, 's>
    - fn deref(&self) -> &<Single<'w, 's, D, F> as Deref>::Target

System parameter that provides access to single entity’s components, much like Query::single/Query::single_mut.

This SystemParam fails validation if zero or more than one matching entity exists. This will cause the system to be skipped, according to the rules laid out in SystemParamValidationError.

Use Option<Single<D, F>> instead if zero or one matching entities can exist.

See Query for more details.

Note that because Single implements Deref and DerefMut, methods and fields like health can be accessed directly. You can also access the underlying data manually, by calling .deref/.deref_mut, or by using the * operator.

Returns the inner item with ownership.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Single<'w, 's, D, F = ()>where
    D: QueryData,
    F: QueryFilter,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
#[derive(Component)]
struct Boss {
   health: f32
};

fn hurt_boss(mut boss: Single<&mut Boss>) {
   boss.health -= 4.0;
}
```

Example 3 (javascript):
```javascript
28fn on_set_message(
29    set_message: On<SetMessage>,
30    text: Single<(&mut Text2d, &mut TextColor), With<MessageText>>,
31) {
32    let (mut text, mut color) = text.into_inner();
33    text.0 = set_message.value.clone();
34    color.0 = set_message.color;
35}
```

Example 4 (javascript):
```javascript
143fn log_tile(tilemap: Single<(&TilemapChunk, &TilemapChunkTileData)>, mut local: Local<u16>) {
144    let (chunk, data) = tilemap.into_inner();
145    let Some(tile_data) = data.tile_data_from_tile_pos(chunk.chunk_size, UVec2::new(3, 4)) else {
146        return;
147    };
148    // log when the tile changes
149    if tile_data.tileset_index != *local {
150        info!(?tile_data, "tile_data changed");
151        *local = tile_data.tileset_index;
152    }
153}
```

---

## Function bvec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.bvec3.html

**Contents:**
- Function bvec3 Copy item path

Creates a 3-dimensional bool vector mask.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn bvec3(x: bool, y: bool, z: bool) -> BVec3
```

---

## Trait DetectChangesMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.DetectChangesMut.html

**Contents:**
- Trait DetectChangesMut Copy item path
  - §Example
- Required Associated Types§
    - type Inner: ?Sized
- Required Methods§
    - fn set_changed(&mut self)
    - fn set_added(&mut self)
    - fn set_last_changed(&mut self, last_changed: Tick)
      - §Warning
    - fn set_last_added(&mut self, last_added: Tick)

Types that implement reliable change detection.

Using types that implement DetectChangesMut, such as ResMut, provide a way to query if a value has been mutated in another system. Normally change detection is triggered by either DerefMut or AsMut, however it can be manually triggered via set_changed.

To ensure that changes are only triggered when the value actually differs, check if the value would change before assignment, such as by checking that new != old. You must be sure that you are not mutably dereferencing in this process.

set_if_neq is a helper method for this common functionality.

The type contained within this smart pointer

For example, for ResMut<T> this would be T.

Flags this value as having been changed.

Mutably accessing this smart pointer will automatically flag this value as having been changed. However, mutation through interior mutability requires manual reporting.

Note: This operation cannot be undone.

Flags this value as having been added.

It is not normally necessary to call this method. The ‘added’ tick is set when the value is first added, and is not normally changed afterwards.

Note: This operation cannot be undone.

Manually sets the change tick recording the time when this data was last mutated.

This is a complex and error-prone operation, primarily intended for use with rollback networking strategies. If you merely want to flag this data as changed, use set_changed instead. If you want to avoid triggering change detection, use bypass_change_detection instead.

Manually sets the added tick recording the time when this data was last added.

The caveats of set_last_changed apply. This modifies both the added and changed ticks together.

Manually bypasses change detection, allowing you to mutate the underlying value without updating the change tick.

This is a risky operation, that can have unexpected consequences on any system relying on this code. However, it can be an essential escape hatch when, for example, you are trying to synchronize representations using change detection and need to avoid infinite recursion.

Overwrites this smart pointer with the given value, if and only if *self != value. Returns true if the value was overwritten, and returns false if it was not.

This is useful to ensure change detection is only triggered when the underlying value changes, instead of every time it is mutably accessed.

If you’re dealing with non-trivial structs which have multiple fields of non-trivial size, then consider app

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait DetectChangesMut: DetectChanges {
    type Inner: ?Sized;

    // Required methods
    fn set_changed(&mut self);
    fn set_added(&mut self);
    fn set_last_changed(&mut self, last_changed: Tick);
    fn set_last_added(&mut self, last_added: Tick);
    fn bypass_change_detection(&mut self) -> &mut Self::Inner;

    // Provided methods
    fn set_if_neq(&mut self, value: Self::Inner) -> bool
       where Self::Inner: Sized + PartialEq { ... }
    fn replace_if_neq(&mut self, value: Self::Inner) -> Option<Self::Inner>
       where Self::Inner: Sized + PartialEq { ... }
    fn clone_f
...
```

Example 2 (unknown):
```unknown
use bevy_ecs::prelude::*;

#[derive(Resource)]
struct MyResource(u32);

fn my_system(mut resource: ResMut<MyResource>) {
    if resource.is_changed() {
        println!("My resource was mutated!");
    }

   resource.0 = 42; // triggers change detection via [`DerefMut`]
}
```

Example 3 (unknown):
```unknown
#[derive(Resource, PartialEq, Eq)]
pub struct Score(u32);

fn reset_score(mut score: ResMut<Score>) {
    // Set the score to zero, unless it is already zero.
    score.set_if_neq(Score(0));
}
```

Example 4 (javascript):
```javascript
35fn change_component(time: Res<Time>, mut query: Query<(Entity, &mut MyComponent)>) {
36    for (entity, mut component) in &mut query {
37        if rand::rng().random_bool(0.1) {
38            let new_component = MyComponent(time.elapsed_secs().round());
39            info!("New value: {new_component:?} {entity}");
40            // Change detection occurs on mutable dereference, and does not consider whether or not
41            // a value is actually equal. To avoid triggering change detection when nothing has
42            // actually changed, you can use the `set_if_neq` method on any com
...
```

---

## Trait Plugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Plugin.html

**Contents:**
- Trait Plugin Copy item path
  - §Lifecycle of a plugin
  - §Defining a plugin.
- Required Methods§
    - fn build(&self, app: &mut App)
- Provided Methods§
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

A collection of Bevy app logic and configuration.

Plugins configure an App. When an App registers a plugin, the plugin’s Plugin::build function is run. By default, a plugin can only be added once to an App.

If the plugin may need to be added twice or more, the function is_unique() should be overridden to return false. Plugins are considered duplicate if they have the same name(). The default name() implementation returns the type name, which means generic plugins with different type parameters will not be considered duplicates.

When adding a plugin to an App:

Most plugins are simply functions that add configuration to an App.

For more advanced use cases, the Plugin trait can be implemented manually for a type.

Configures the App to which this plugin is added.

Has the plugin finished its setup? This can be useful for plugins that need something asynchronous to happen before they can finish their setup, like the initialization of a renderer. Once the plugin is ready, finish should be called.

Finish adding this plugin to the App, once all plugins registered are ready. This can be useful for plugins that depends on another plugin asynchronous setup, like the renderer.

Runs after all plugins are built and finished, but before the app schedule is executed. This can be useful if you have some resource that other plugins need during their build step, but after build you want to remove it and send it to another thread.

Configures a name for the Plugin which is primarily used for checking plugin uniqueness and debugging.

If the plugin can be meaningfully instantiated several times in an App, override this method to return false.

Returns true if the trait object wraps an object of type __T.

Returns a boxed object from a boxed trait object if the underlying object is of type __T. Returns the original boxed trait if it isn’t.

Returns an Rc-ed object from an Rc-ed trait object if the underlying object is of type __T. Returns the original Rc-ed trait if it isn’t.

Returns a reference to the object within the trait object if it is of type __T, or None if it isn’t.

Returns a mutable reference to the object within the trait object if it is of type __T, or None if it isn’t.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Plugin:
    Downcast
    + Any
    + Send
    + Sync {
    // Required method
    fn build(&self, app: &mut App);

    // Provided methods
    fn ready(&self, _app: &App) -> bool { ... }
    fn finish(&self, _app: &mut App) { ... }
    fn cleanup(&self, _app: &mut App) { ... }
    fn name(&self) -> &str { ... }
    fn is_unique(&self) -> bool { ... }
}
```

Example 2 (unknown):
```unknown
App::new().add_plugins(my_plugin).run();

// This function implements `Plugin`, along with every other `fn(&mut App)`.
pub fn my_plugin(app: &mut App) {
    app.add_systems(Update, hello_world);
}
```

Example 3 (unknown):
```unknown
pub struct AccessibilityPlugin {
    pub flicker_damping: bool,
    // ...
}

impl Plugin for AccessibilityPlugin {
    fn build(&self, app: &mut App) {
        if self.flicker_damping {
            app.add_systems(PostUpdate, damp_flickering);
        }
    }
}
```

---

## Struct Interval Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Interval.html

**Contents:**
- Struct Interval Copy item path
- Implementations§
  - impl Interval
    - pub const UNIT: Interval
    - pub const EVERYWHERE: Interval
    - pub const fn new(start: f32, end: f32) -> Result<Interval, InvalidIntervalError>
    - pub const fn start(self) -> f32
    - pub const fn end(self) -> f32
    - pub fn intersect( self, other: Interval, ) -> Result<Interval, InvalidIntervalError>
    - pub const fn length(self) -> f32

A nonempty closed interval, possibly unbounded in either direction.

In other words, the interval may stretch all the way to positive or negative infinity, but it will always have some nonempty interior.

An interval of length 1.0, starting at 0.0 and ending at 1.0.

An interval which stretches across the entire real line from negative infinity to infinity.

Create a new Interval with the specified start and end. The interval can be unbounded but cannot be empty (so start must be less than end) and neither endpoint can be NaN; invalid parameters will result in an error.

Get the start of this interval.

Get the end of this interval.

Create an Interval by intersecting this interval with another. Returns an error if the intersection would be empty (hence an invalid interval).

Get the length of this interval. Note that the result may be infinite (f32::INFINITY).

Returns true if this interval is bounded — that is, if both its start and end are finite.

Equivalently, an interval is bounded if its length is finite.

Returns true if this interval has a finite start.

Returns true if this interval has a finite end.

Returns true if item is contained in this interval.

Returns true if the other interval is contained in this interval.

This is non-strict: each interval will contain itself.

Clamp the given value to lie within this interval.

Get an iterator over equally-spaced points from this interval in increasing order. If points is 1, the start of this interval is returned. If points is 0, an empty iterator is returned. An error is returned if the interval is unbounded.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Interval { /* private fields */ }
```

Example 2 (javascript):
```javascript
124fn display_curves(
125    mut gizmos: Gizmos,
126    ease_functions: Query<(&EaseFunctionPlot, &Transform, &Children)>,
127    mut transforms: Query<&mut Transform, Without<EaseFunctionPlot>>,
128    mut ui_text: Single<&mut Text>,
129    time: Res<Time>,
130) {
131    let samples = 100;
132    let duration = 2.5;
133    let time_margin = 0.5;
134
135    let now = ((time.elapsed_secs() % (duration + time_margin * 2.0) - time_margin) / duration)
136        .clamp(0.0, 1.0);
137
138    ui_text.0 = format!("Progress: {now:.2}");
139
140    for (EaseFunctionPlot(function, color), transform, chi
...
```

---

## Struct MeshPickingPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshPickingPlugin.html

**Contents:**
- Struct MeshPickingPlugin Copy item path
- Trait Implementations§
  - impl Clone for MeshPickingPlugin
    - fn clone(&self) -> MeshPickingPlugin
    - fn clone_from(&mut self, source: &Self)
  - impl Default for MeshPickingPlugin
    - fn default() -> MeshPickingPlugin
  - impl Plugin for MeshPickingPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool

Adds the mesh picking backend to your app.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshPickingPlugin;
```

---

## Struct TextShadow Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextShadow.html

**Contents:**
- Struct TextShadow Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for TextShadow
    - fn clone(&self) -> TextShadow
    - fn clone_from(&mut self, source: &Self)
  - impl Component for TextShadowwhere TextShadow: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Adds a shadow behind text

Use the Text2dShadow component for Text2d shadows

Shadow displacement in logical pixels With a value of zero the shadow will be hidden directly behind the text

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextShadow {
    pub offset: Vec2,
    pub color: Color,
}
```

---

## Struct Observer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Observer.html

**Contents:**
- Struct Observer Copy item path
- §Usage
  - §Event Trigger behavior
  - §Event sub-types
  - §Observer execution timing
  - §ObservedBy
  - §Manual Observer target configuration
  - §Cleaning up observers
  - §Component lifecycle events: Observers vs Hooks
  - §Observer re-targeting

An Observer system. Add this Component to an Entity to turn it into an “observer”.

Observers watch for a “trigger” of a specific Event. An event can be triggered on the World by calling World::trigger. It can also be queued up as a Command using Commands::trigger.

When a World triggers an Event, it will immediately run every Observer that watches for that Event.

The simplest usage of the observer pattern looks like this:

Notice that we used World::add_observer. This is just a shorthand for spawning an Entity with an Observer manually:

Observers are a specialized System called an ObserverSystem. The first parameter must be On, which provides access to the Event, the Trigger, and some additional execution context.

Because they are systems, they can access arbitrary World data by adding SystemParams:

You can also add Commands, which means you can spawn new entities, insert new components, etc:

Observers can also trigger new events:

When the commands are flushed (including these “nested triggers”) they will be recursively evaluated until there are no commands left, meaning nested triggers all evaluate at the same time!

Each Event defines a Trigger behavior, which determines which observers will run for the given Event and how they will be run.

Event by default (when derived) uses GlobalTrigger. When it is triggered any Observer watching for it will be run.

There are some built-in specialized Event types with custom Trigger logic:

You can also define your own!

Observers triggered via World::trigger are evaluated immediately, as are all commands they queue up.

Observers triggered via Commands::trigger are evaluated at the next sync point in the ECS schedule, just like any other Command.

To control the relative ordering of observer trigger commands sent from different systems, order the systems in the schedule relative to each other.

Currently, Bevy does not provide a way to specify the relative ordering of observers watching for the same event. Their ordering is considered to be arbitrary. It is recommended to make no assumptions about their execution order.

Commands sent by observers are currently not immediately applied. Instead, all queued observers will run, and then all of the commands from those observers will be applied.

When entities are observed, they will receive an ObservedBy component, which will be updated to track the observers that are currently observing them.

You can manually control the targets that an observer is watching b

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Observer { /* private fields */ }
```

Example 2 (unknown):
```unknown
#[derive(Event)]
struct Speak {
    message: String,
}

world.add_observer(|event: On<Speak>| {
    println!("{}", event.message);
});

world.trigger(Speak {
    message: "Hello!".into(),
});
```

Example 3 (unknown):
```unknown
// These are functionally the same:
world.add_observer(|event: On<Speak>| {});
world.spawn(Observer::new(|event: On<Speak>| {}));
```

Example 4 (unknown):
```unknown
world.add_observer(|event: On<PrintNames>, names: Query<&Name>| {
    for name in &names {
        println!("{name:?}");
    }
});
```

---

## Struct AnimationPlayer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationPlayer.html

**Contents:**
- Struct AnimationPlayer Copy item path
- Implementations§
  - impl AnimationPlayer
    - pub fn start(&mut self, animation: NodeIndex) -> &mut ActiveAnimation
    - pub fn play(&mut self, animation: NodeIndex) -> &mut ActiveAnimation
      - Examples found in repository?
    - pub fn stop(&mut self, animation: NodeIndex) -> &mut AnimationPlayer
    - pub fn stop_all(&mut self) -> &mut AnimationPlayer
    - pub fn playing_animations( &self, ) -> impl Iterator<Item = (&NodeIndex, &ActiveAnimation)>
      - Examples found in repository?

Automatically added to any root animations of a scene when it is spawned.

Start playing an animation, restarting it if necessary.

Start playing an animation, unless the requested animation is already playing.

Stops playing the given animation, removing it from the list of playing animations.

Stops all currently-playing animations.

Iterates through all animations that this AnimationPlayer is currently playing.

Iterates through all animations that this AnimationPlayer is currently playing, mutably.

Returns true if the animation is currently playing or paused, or false if the animation is stopped.

Check if all playing animations have finished, according to the repetition behavior.

Check if all playing animations are paused.

Pause all playing animations.

Resume all active animations.

Rewinds all active animations.

Multiplies the speed of all active animations by the given factor.

Seeks all active animations forward or backward by the same amount.

To seek forward, pass a positive value; to seek negative, pass a negative value. Values below 0.0 or beyond the end of the animation clip are clamped appropriately.

Returns the ActiveAnimation associated with the given animation node if it’s currently playing.

If the animation isn’t currently active, returns None.

Returns a mutable reference to the ActiveAnimation associated with the given animation node if it’s currently active.

If the animation isn’t currently active, returns None.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationPlayer { /* private fields */ }
```

Example 2 (unknown):
```unknown
512fn play_animations(
513    mut commands: Commands,
514    assets: Res<ExampleAssets>,
515    mut players: Query<(Entity, &mut AnimationPlayer), Without<AnimationGraphHandle>>,
516) {
517    for (entity, mut player) in players.iter_mut() {
518        commands
519            .entity(entity)
520            .insert(AnimationGraphHandle(assets.fox_animation_graph.clone()));
521        player.play(assets.fox_animation_node).repeat();
522    }
523}
```

Example 3 (javascript):
```javascript
379fn init_animations(
380    mut commands: Commands,
381    mut query: Query<(Entity, &mut AnimationPlayer)>,
382    animation_graph: Res<ExampleAnimationGraph>,
383    mut done: Local<bool>,
384) {
385    if *done {
386        return;
387    }
388
389    for (entity, mut player) in query.iter_mut() {
390        commands.entity(entity).insert((
391            AnimationGraphHandle(animation_graph.0.clone()),
392            ExampleAnimationWeights::default(),
393        ));
394        for &node_index in &CLIP_NODE_INDICES {
395            player.play(node_index.into()).repeat();
396        }
39
...
```

Example 4 (javascript):
```javascript
58fn play_animation_when_ready(
59    scene_ready: On<SceneInstanceReady>,
60    mut commands: Commands,
61    children: Query<&Children>,
62    animations_to_play: Query<&AnimationToPlay>,
63    mut players: Query<&mut AnimationPlayer>,
64) {
65    if let Ok(animation_to_play) = animations_to_play.get(scene_ready.entity) {
66        for child in children.iter_descendants(scene_ready.entity) {
67            if let Ok(mut player) = players.get_mut(child) {
68                player.play(animation_to_play.index).repeat();
69
70                commands
71                    .entity(child)
72      
...
```

---

## Struct Schedule Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Schedule.html

**Contents:**
- Struct Schedule Copy item path
- §Schedule labels
- §Example
- Implementations§
  - impl Schedule
    - pub fn new(label: impl ScheduleLabel) -> Schedule
      - Examples found in repository?
    - pub fn label(&self) -> Interned<dyn ScheduleLabel>
      - Examples found in repository?
    - pub fn add_systems<M>( &mut self, systems: impl IntoScheduleConfigs<Box<dyn System<Out = (), In = ()>>, M>, ) -> &mut Schedule

A collection of systems, and the metadata and executor needed to run them in a certain order under certain conditions.

Each schedule has a ScheduleLabel value. This value is used to uniquely identify the schedule when added to a World’s Schedules, and may be used to specify which schedule a system should be added to.

Here is an example of a Schedule running a “Hello world” system:

A schedule can also run several systems in an ordered way:

Schedules are often inserted into a World and identified by their ScheduleLabel only:

Constructs an empty Schedule.

Returns the InternedScheduleLabel for this Schedule, corresponding to the ScheduleLabel this schedule was created with.

Add a collection of systems to the schedule.

Suppress warnings and errors that would result from systems in these sets having ambiguities (conflicting access but indeterminate order) with systems in set.

Configures a collection of system sets in this schedule, adding them if they does not exist.

Add a custom build pass to the schedule.

Remove a custom build pass.

Changes miscellaneous build settings.

If settings.auto_insert_apply_deferred is false, this clears *_ignore_deferred edge settings configured so far.

Generally this method should be used before adding systems or set configurations to the schedule, not after.

Returns the schedule’s current ScheduleBuildSettings.

Returns the schedule’s current execution strategy.

Sets the schedule’s execution strategy.

Set whether the schedule applies deferred system buffers on final time or not. This is a catch-all in case a system uses commands but was not explicitly ordered before an instance of ApplyDeferred. By default this setting is true, but may be disabled if needed.

Runs all systems in this schedule on the world, using its current execution strategy.

Initializes any newly-added systems and conditions, rebuilds the executable schedule, and re-initializes the executor.

Moves all systems and run conditions out of the ScheduleGraph.

Returns the ScheduleGraph.

Returns a mutable reference to the ScheduleGraph.

Iterates the change ticks of all systems in the schedule and clamps any older than MAX_CHANGE_AGE. This prevents overflow and thus prevents false positives.

Directly applies any accumulated Deferred system parameters (like Commands) to the world.

Like always, deferred system parameters are applied in the “topological sort order” of the schedule graph. As a result, buffers from one system are only guaranteed to be a

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Schedule { /* private fields */ }
```

Example 2 (javascript):
```javascript
fn hello_world() { println!("Hello world!") }

fn main() {
    let mut world = World::new();
    let mut schedule = Schedule::default();
    schedule.add_systems(hello_world);

    schedule.run(&mut world);
}
```

Example 3 (javascript):
```javascript
fn system_one() { println!("System 1 works!") }
fn system_two() { println!("System 2 works!") }
fn system_three() { println!("System 3 works!") }

fn main() {
    let mut world = World::new();
    let mut schedule = Schedule::default();
    schedule.add_systems((
        system_two,
        system_one.before(system_two),
        system_three.after(system_two),
    ));

    schedule.run(&mut world);
}
```

Example 4 (javascript):
```javascript
use bevy_ecs::schedule::ScheduleLabel;

// Declare a new schedule label.
#[derive(ScheduleLabel, Clone, Debug, PartialEq, Eq, Hash, Default)]
struct Update;

// This system shall be part of the schedule.
fn an_update_system() {
    println!("Hello world!");
}

fn main() {
    let mut world = World::new();

    // Add a system to the schedule with that label (creating it automatically).
    world.get_resource_or_init::<Schedules>().add_systems(Update, an_update_system);

    // Run the schedule, and therefore run the system.
    world.run_schedule(Update);
}
```

---

## Struct UiPickingCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiPickingCamera.html

**Contents:**
- Struct UiPickingCamera Copy item path
- Trait Implementations§
  - impl Clone for UiPickingCamera
    - fn clone(&self) -> UiPickingCamera
    - fn clone_from(&mut self, source: &Self)
  - impl Component for UiPickingCamerawhere UiPickingCamera: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

An optional component that marks cameras that should be used in the UiPickingPlugin.

Only needed if UiPickingSettings::require_markers is set to true, and ignored otherwise.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiPickingCamera;
```

---

## Struct CurveReparamCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CurveReparamCurve.html

**Contents:**
- Struct CurveReparamCurve Copy item path
- Trait Implementations§
  - impl<T, C, D> Clone for CurveReparamCurve<T, C, D>where T: Clone, C: Clone, D: Clone,
    - fn clone(&self) -> CurveReparamCurve<T, C, D>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C, D> Curve<T> for CurveReparamCurve<T, C, D>where C: Curve<T>, D: Curve<f32>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

A curve that has been reparametrized by another curve, using that curve to transform the sample times before sampling. Curves of this type are produced by CurveExt::reparametrize_by_curve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CurveReparamCurve<T, C, D> { /* private fields */ }
```

---

## Struct BounceInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BounceInCurve.html

**Contents:**
- Struct BounceInCurve Copy item path
- Trait Implementations§
  - impl Clone for BounceInCurve
    - fn clone(&self) -> BounceInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for BounceInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BounceInCurve;
```

---

## Struct AnyOf Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnyOf.html

**Contents:**
- Struct AnyOf Copy item path
- Trait Implementations§
  - impl QueryData for AnyOf<()>
    - const IS_READ_ONLY: bool = true
    - type ReadOnly = AnyOf<()>
    - type Item<'w, 's> = ()
    - fn shrink<'wlong, 'wshort, 's>( item: <AnyOf<()> as QueryData>::Item<'wlong, 's>, ) -> <AnyOf<()> as QueryData>::Item<'wshort, 's>where 'wlong: 'wshort,
    - unsafe fn fetch<'w, 's>( _state: &'s <AnyOf<()> as WorldQuery>::State, _fetch: &mut <AnyOf<()> as WorldQuery>::Fetch<'w>, _entity: Entity, _table_row: TableRow, ) -> <AnyOf<()> as QueryData>::Item<'w, 's>
    - fn provide_extra_access( _state: &mut Self::State, _access: &mut Access, _available_access: &Access, )
  - impl<F> QueryData for AnyOf<(F₁, F₂, …, Fₙ)>where F: QueryData,

The AnyOf query parameter fetches entities with any of the component types included in T.

Query<AnyOf<(&A, &B, &mut C)>> is equivalent to Query<(Option<&A>, Option<&B>, Option<&mut C>), Or<(With<A>, With<B>, With<C>)>>. Each of the components in T is returned as an Option, as with Option<A> queries. Entities are guaranteed to have at least one of the components in T.

This trait is implemented for tuples up to 16 items long.

SAFETY: fetch accesses are a subset of the subqueries’ accesses This is sound because update_component_access adds accesses according to the implementations of all the subqueries. update_component_access replaces the filters with a disjunction where every element is a conjunction of the previous filters and the filters of one of the subqueries. This is sound because matches_component_set returns a disjunction of the results of the subqueries’ implementations.

This trait is implemented for tuples up to 16 items long. SAFETY: fetch accesses are a subset of the subqueries’ accesses This is sound because update_component_access adds accesses according to the implementations of all the subqueries. update_component_access replaces the filters with a disjunction where every element is a conjunction of the previous filters and the filters of one of the subqueries. This is sound because matches_component_set returns a disjunction of the results of the subqueries’ implementations.

SAFETY: each item in the tuple is read only

This trait is implemented for tuples up to 16 items long. SAFETY: each item in the tuple is read only

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnyOf<T>(/* private fields */);
```

---

## Struct Rhombus Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Rhombus.html

**Contents:**
- Struct Rhombus Copy item path
- Fields§
- Implementations§
  - impl Rhombus
    - pub const fn new(horizontal_diagonal: f32, vertical_diagonal: f32) -> Rhombus
      - Examples found in repository?
    - pub const fn from_side(side: f32) -> Rhombus
    - pub const fn from_inradius(inradius: f32) -> Rhombus
    - pub fn side(&self) -> f32
    - pub const fn circumradius(&self) -> f32

A rhombus primitive, also known as a diamond shape. A four sided polygon, centered on the origin, where opposite sides are parallel but without requiring right angles.

Size of the horizontal and vertical diagonals of the rhombus

Create a new Rhombus from a vertical and horizontal diagonal sizes.

Create a new Rhombus from a side length with all inner angles equal.

Create a new Rhombus from a given inradius with all inner angles equal.

Get the length of each side of the rhombus

Get the radius of the circumcircle on which all vertices of the rhombus lie

Get the radius of the largest circle that can be drawn within the rhombus

Finds the point on the rhombus that is closest to the given point.

If the point is outside the rhombus, the returned point will be on the perimeter of the rhombus. Otherwise, it will be inside the rhombus and returned as is.

Returns the default Rhombus with a half-horizontal and half-vertical diagonal of 0.5.

Get the area of the rhombus

Get the perimeter of the rhombus

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Rhombus {
    pub half_diagonals: Vec2,
}
```

Example 2 (javascript):
```javascript
104fn setup_scene(
105    mut commands: Commands,
106    mut meshes: ResMut<Assets<Mesh>>,
107    mut materials: ResMut<Assets<ColorMaterial>>,
108) {
109    commands.spawn(Camera2d);
110
111    let named_shapes = [
112        (Name::new("Annulus"), meshes.add(Annulus::new(25.0, 50.0))),
113        (
114            Name::new("Bestagon"),
115            meshes.add(RegularPolygon::new(50.0, 6)),
116        ),
117        (Name::new("Rhombus"), meshes.add(Rhombus::new(75.0, 100.0))),
118    ];
119    let num_shapes = named_shapes.len();
120
121    for (i, (name, shape)) in named_shapes.into_iter()
...
```

Example 3 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 4 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/camera/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct FixedLast Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FixedLast.html

**Contents:**
- Struct FixedLast Copy item path
- Trait Implementations§
  - impl Clone for FixedLast
    - fn clone(&self) -> FixedLast
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedLast
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedLast
    - fn default() -> FixedLast
  - impl Hash for FixedLast

The schedule that runs last in FixedMain

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedLast;
```

---

## Struct Line2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Line2d.html

**Contents:**
- Struct Line2d Copy item path
- Fields§
- Trait Implementations§
  - impl Bounded2d for Line2d
    - fn aabb_2d(&self, isometry: impl Into<Isometry2d>) -> Aabb2d
    - fn bounding_circle(&self, isometry: impl Into<Isometry2d>) -> BoundingCircle
  - impl BoundedExtrusion for Line2d
    - fn extrusion_aabb_3d( &self, half_depth: f32, isometry: impl Into<Isometry3d>, ) -> Aabb3d
    - fn extrusion_bounding_sphere( &self, half_depth: f32, isometry: impl Into<Isometry3d>, ) -> BoundingSphere
  - impl Clone for Line2d

An infinite line going through the origin along a direction in 2D space.

For a finite line: Segment2d

The direction of the line. The line extends infinitely in both the given direction and its opposite direction

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Line2d {
    pub direction: Dir2,
}
```

---

## Struct Dir2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Dir2.html

**Contents:**
- Struct Dir2 Copy item path
- Implementations§
  - impl Dir2
    - pub const X: Dir2
    - pub const Y: Dir2
    - pub const NEG_X: Dir2
    - pub const NEG_Y: Dir2
    - pub const AXES: [Dir2; 2]
    - pub const NORTH: Dir2
    - pub const SOUTH: Dir2

A normalized vector pointing in a direction in 2D space

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

The directional axes.

The “north” direction, equivalent to Dir2::Y.

The “south” direction, equivalent to Dir2::NEG_Y.

The “east” direction, equivalent to Dir2::X.

The “west” direction, equivalent to Dir2::NEG_X.

The “north-east” direction, between Dir2::NORTH and Dir2::EAST.

The “north-west” direction, between Dir2::NORTH and Dir2::WEST.

The “south-east” direction, between Dir2::SOUTH and Dir2::EAST.

The “south-west” direction, between Dir2::SOUTH and Dir2::WEST.

Create a direction from a finite, nonzero Vec2, normalizing it.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Create a Dir2 from a Vec2 that is already normalized.

value must be normalized, i.e its length must be 1.0.

Create a direction from a finite, nonzero Vec2, normalizing it and also returning its original length.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Create a direction from its x and y components.

Returns Err(InvalidDirectionError) if the length of the vector formed by the components is zero (or very close to zero), infinite, or NaN.

Create a direction from its x and y components, assuming the resulting vector is normalized.

The vector produced from x and y must be normalized, i.e its length must be 1.0.

Returns the inner Vec2

Performs a spherical linear interpolation between self and rhs based on the value s.

This corresponds to interpolating between the two directions at a constant angular velocity.

When s == 0.0, the result will be equal to self. When s == 1.0, the result will be equal to rhs.

Get the rotation that rotates this direction to other.

Get the rotation that rotates other to this direction.

Get the rotation that rotates the X-axis to this direction.

Get the rotation that rotates this direction to the X-axis.

Get the rotation that rotates the Y-axis to this direction.

Get the rotation that rotates this direction to the Y-axis.

Returns self after an approximate normalization, assuming the value is already nearly normalized. Useful for preventing numerical error accumulation. See Dir3::fast_renormalize for an example of when such error accumul

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Dir2(/* private fields */);
```

Example 2 (javascript):
```javascript
285fn get_and_draw_ray(gizmos: &mut Gizmos, time: &Time) -> RayCast2d {
286    let ray = Vec2::new(ops::cos(time.elapsed_secs()), ops::sin(time.elapsed_secs()));
287    let dist = 150. + ops::sin(0.5 * time.elapsed_secs()).abs() * 500.;
288
289    let aabb_ray = Ray2d {
290        origin: ray * 250.,
291        direction: Dir2::new_unchecked(-ray),
292    };
293    let ray_cast = RayCast2d::from_ray(aabb_ray, dist - 20.);
294
295    draw_ray(gizmos, &ray_cast);
296    ray_cast
297}
```

Example 3 (unknown):
```unknown
202fn setup(mut commands: Commands) {
203    commands.spawn(Camera2d);
204
205    commands.spawn((
206        Transform::from_xyz(-OFFSET_X, OFFSET_Y, 0.),
207        Shape::Circle(Circle::new(45.)),
208        DesiredVolume::Aabb,
209        Intersects::default(),
210    ));
211
212    commands.spawn((
213        Transform::from_xyz(0., OFFSET_Y, 0.),
214        Shape::Rectangle(Rectangle::new(80., 80.)),
215        Spin,
216        DesiredVolume::Circle,
217        Intersects::default(),
218    ));
219
220    commands.spawn((
221        Transform::from_xyz(OFFSET_X, OFFSET_Y, 0.),
222       
...
```

Example 4 (javascript):
```javascript
let dir1 = Dir2::X;
let dir2 = Dir2::Y;

let result1 = dir1.slerp(dir2, 1.0 / 3.0);
#[cfg(feature = "approx")]
assert_relative_eq!(result1, Dir2::from_xy(0.75_f32.sqrt(), 0.5).unwrap());

let result2 = dir1.slerp(dir2, 0.5);
#[cfg(feature = "approx")]
assert_relative_eq!(result2, Dir2::from_xy(0.5_f32.sqrt(), 0.5_f32.sqrt()).unwrap());
```

---

## Trait ReflectPath Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ReflectPath.html

**Contents:**
- Trait ReflectPath Copy item path
- Required Methods§
    - fn reflect_element( self, root: &(dyn PartialReflect + 'static), ) -> Result<&(dyn PartialReflect + 'static), ReflectPathError<'a>>
    - fn reflect_element_mut( self, root: &mut (dyn PartialReflect + 'static), ) -> Result<&mut (dyn PartialReflect + 'static), ReflectPathError<'a>>
- Provided Methods§
    - fn element<T>( self, root: &(dyn PartialReflect + 'static), ) -> Result<&T, ReflectPathError<'a>>where T: Reflect,
    - fn element_mut<T>( self, root: &mut (dyn PartialReflect + 'static), ) -> Result<&mut T, ReflectPathError<'a>>where T: Reflect,
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl<'a> ReflectPath<'a> for &'a str

Something that can be interpreted as a reflection path in GetPath.

Gets a reference to the specified element on the given Reflect object.

See GetPath::reflect_path for more details, see element if you want a typed return value.

Gets a mutable reference to the specified element on the given Reflect object.

See GetPath::reflect_path_mut for more details.

Gets a &T to the specified element on the given Reflect object.

See GetPath::path for more details.

Gets a &mut T to the specified element on the given Reflect object.

See GetPath::path_mut for more details.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ReflectPath<'a>: Sized {
    // Required methods
    fn reflect_element(
        self,
        root: &(dyn PartialReflect + 'static),
    ) -> Result<&(dyn PartialReflect + 'static), ReflectPathError<'a>>;
    fn reflect_element_mut(
        self,
        root: &mut (dyn PartialReflect + 'static),
    ) -> Result<&mut (dyn PartialReflect + 'static), ReflectPathError<'a>>;

    // Provided methods
    fn element<T>(
        self,
        root: &(dyn PartialReflect + 'static),
    ) -> Result<&T, ReflectPathError<'a>>
       where T: Reflect { ... }
    fn element_mut<T>(
        self,
...
```

---

## Struct Ray3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Ray3d.html

**Contents:**
- Struct Ray3d Copy item path
- Fields§
- Implementations§
  - impl Ray3d
    - pub const fn new(origin: Vec3, direction: Dir3) -> Ray3d
      - Examples found in repository?
    - pub fn get_point(&self, distance: f32) -> Vec3
      - Examples found in repository?
    - pub fn intersect_plane( &self, plane_origin: Vec3, plane: InfinitePlane3d, ) -> Option<f32>
      - Examples found in repository?

An infinite half-line starting at origin and going in direction in 3D space.

The origin of the ray.

The direction of the ray.

Create a new Ray3d from a given origin and direction

Get a point at a given distance along the ray

Get the distance to a plane if the ray intersects it

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Ray3d {
    pub origin: Vec3,
    pub direction: Dir3,
}
```

Example 2 (javascript):
```javascript
23fn bouncing_raycast(
24    mut ray_cast: MeshRayCast,
25    mut gizmos: Gizmos,
26    time: Res<Time>,
27    // The ray map stores rays cast by the cursor
28    ray_map: Res<RayMap>,
29) {
30    // Cast an automatically moving ray and bounce it off of surfaces
31    let t = ops::cos((time.elapsed_secs() - 4.0).max(0.0) * LASER_SPEED) * PI;
32    let ray_pos = Vec3::new(ops::sin(t), ops::cos(3.0 * t) * 0.5, ops::cos(t)) * 0.5;
33    let ray_dir = Dir3::new(-ray_pos).unwrap();
34    let ray = Ray3d::new(ray_pos, ray_dir);
35    gizmos.sphere(ray_pos, 0.1, Color::WHITE);
36    bounce_ray(ray, &
...
```

Example 3 (javascript):
```javascript
13fn draw_cursor(
14    camera_query: Single<(&Camera, &GlobalTransform)>,
15    ground: Single<&GlobalTransform, With<Ground>>,
16    window: Single<&Window>,
17    mut gizmos: Gizmos,
18) {
19    let (camera, camera_transform) = *camera_query;
20
21    if let Some(cursor_position) = window.cursor_position()
22        // Calculate a ray pointing from the camera into the world based on the cursor's position.
23        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
24        // Calculate if and at what distance the ray is hitting the ground plane.
25        && let 
...
```

Example 4 (javascript):
```javascript
13fn draw_cursor(
14    camera_query: Single<(&Camera, &GlobalTransform)>,
15    ground: Single<&GlobalTransform, With<Ground>>,
16    window: Single<&Window>,
17    mut gizmos: Gizmos,
18) {
19    let (camera, camera_transform) = *camera_query;
20
21    if let Some(cursor_position) = window.cursor_position()
22        // Calculate a ray pointing from the camera into the world based on the cursor's position.
23        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
24        // Calculate if and at what distance the ray is hitting the ground plane.
25        && let 
...
```

---

## Macro plugin_group Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/macro.plugin_group.html

**Contents:**
- Macro plugin_group Copy item path
- §Example

A macro for generating a well-documented PluginGroup from a list of Plugin paths.

Every plugin must implement the Default trait.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! plugin_group {
    {
        $(#[$group_meta:meta])*
        $vis:vis struct $group:ident {
            $(
                $(#[cfg(feature = $plugin_feature:literal)])?
                $(#[custom($plugin_meta:meta)])*
                $($plugin_path:ident::)* : $plugin_name:ident
            ),*
            $(
                $(,)?$(
                    #[plugin_group]
                    $(#[cfg(feature = $plugin_group_feature:literal)])?
                    $(#[custom($plugin_group_meta:meta)])*
                    $($plugin_group_path:ident::)* : $plugin_group_name:ident
       
...
```

Example 2 (unknown):
```unknown
plugin_group! {
    /// Doc comments and annotations are supported: they will be added to the generated plugin
    /// group.
    #[derive(Debug)]
    pub struct PhysicsPlugins {
        // If referencing a plugin within the same module, you must prefix it with a colon `:`.
        :TickratePlugin,
        // If referencing a plugin within a different module, there must be three colons `:::`
        // between the final module and the plugin name.
        collision::capsule:::CapsuleCollisionPlugin,
        velocity:::VelocityPlugin,
        // If you feature-flag a plugin, it will be automati
...
```

---

## Struct TaskPoolPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TaskPoolPlugin.html

**Contents:**
- Struct TaskPoolPlugin Copy item path
- Fields§
- Trait Implementations§
  - impl Default for TaskPoolPlugin
    - fn default() -> TaskPoolPlugin
  - impl Plugin for TaskPoolPlugin
    - fn build(&self, _app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

Setup of default task pools: AsyncComputeTaskPool, ComputeTaskPool, IoTaskPool.

Options for the TaskPool created at application start.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TaskPoolPlugin {
    pub task_pool_options: TaskPoolOptions,
}
```

---

## Macro debug_span Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.debug_span.html

**Contents:**
- Macro debug_span Copy item path
- §Examples

Constructs a span at the debug level.

Fields and attributes are set using the same syntax as the span! macro.

See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! debug_span {
    (target: $target:expr, parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, parent: $parent:expr, $name:expr) => { ... };
    (parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (parent: $parent:expr, $name:expr) => { ... };
    (target: $target:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, $name:expr) => { ... };
    ($name:expr, $($field:tt)*) => { ... };
    ($name:expr) => { ... };
}
```

Example 2 (unknown):
```unknown
debug_span!("my_span");
// is equivalent to:
span!(Level::DEBUG, "my_span");
```

Example 3 (javascript):
```javascript
let span = debug_span!("my span");
span.in_scope(|| {
    // do work inside the span...
});
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/render/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct MessageReader Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MessageReader.html

**Contents:**
- Struct MessageReader Copy item path
- §Concurrency
- Implementations§
  - impl<'w, 's, E> MessageReader<'w, 's, E>where E: Message,
    - pub fn read(&mut self) -> MessageIterator<'_, E> ⓘ
      - Examples found in repository?
    - pub fn read_with_id(&mut self) -> MessageIteratorWithId<'_, E> ⓘ
    - pub fn par_read(&mut self) -> MessageParIter<'_, E>
      - §Example
    - pub fn len(&self) -> usize

Reads Messages of type T in order and tracks which messages have already been read.

Unlike MessageWriter<T>, systems with MessageReader<T> param can be executed concurrently (but not concurrently with MessageWriter<T> or MessageMutator<T> systems for the same message type).

Iterates over the messages this MessageReader has not seen yet. This updates the MessageReader’s message counter, which means subsequent message reads will not include messages that happened before now.

Like read, except also returning the MessageId of the messages.

Returns a parallel iterator over the messages this MessageReader has not seen yet. See also for_each.

Determines the number of messages available to be read from this MessageReader without consuming any.

Returns true if there are no messages available to read.

The following example shows a useful pattern where some behavior is triggered if new messages are available. MessageReader::clear() is used so the same messages don’t re-trigger the behavior the next time the system runs.

Consumes all available messages.

This means these messages will not appear in calls to MessageReader::read() or MessageReader::read_with_id() and MessageReader::is_empty() will return true.

For usage, see MessageReader::is_empty().

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MessageReader<'w, 's, E>where
    E: Message,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
59fn read_and_write_different_message_types(mut a: MessageWriter<A>, mut b: MessageReader<B>) {
60    for _ in b.read() {}
61    a.write(A);
62}
63
64/// A dummy message type.
65#[derive(Debug, Clone, Message)]
66struct DebugMessage {
67    resend_from_param_set: bool,
68    resend_from_local_message_reader: bool,
69    times_sent: u8,
70}
71
72/// A system that sends all combinations of messages.
73fn send_messages(mut debug_messages: MessageWriter<DebugMessage>, frame_count: Res<FrameCount>) {
74    println!("Sending messages for frame {}", frame_count.0);
75
76    debug_messages.write(Debug
...
```

Example 3 (unknown):
```unknown
73fn handle_event(mut events: MessageReader<CustomEvent>) {
74    for evt in events.read() {
75        info!("Received event: {evt:?}");
76    }
77}
```

Example 4 (unknown):
```unknown
12fn touch_event_system(mut touch_inputs: MessageReader<TouchInput>) {
13    for touch_input in touch_inputs.read() {
14        info!("{:?}", touch_input);
15    }
16}
```

---

## Struct SceneSpawner Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SceneSpawner.html

**Contents:**
- Struct SceneSpawner Copy item path
- Implementations§
  - impl SceneSpawner
    - pub fn spawn_dynamic( &mut self, id: impl Into<Handle<DynamicScene>>, ) -> InstanceId
    - pub fn spawn_dynamic_as_child( &mut self, id: impl Into<Handle<DynamicScene>>, parent: Entity, ) -> InstanceId
    - pub fn spawn(&mut self, id: impl Into<Handle<Scene>>) -> InstanceId
    - pub fn spawn_as_child( &mut self, id: impl Into<Handle<Scene>>, parent: Entity, ) -> InstanceId
    - pub fn despawn(&mut self, id: impl Into<AssetId<Scene>>)
    - pub fn despawn_dynamic(&mut self, id: impl Into<AssetId<DynamicScene>>)
    - pub fn despawn_instance(&mut self, instance_id: InstanceId)

Handles spawning and despawning scenes in the world, either synchronously or batched through the scene_spawner_system.

Synchronous methods: (Scene operations will take effect immediately)

Deferred methods: (Scene operations will be processed when the scene_spawner_system is run)

Schedule the spawn of a new instance of the provided dynamic scene.

Schedule the spawn of a new instance of the provided dynamic scene as a child of parent.

Schedule the spawn of a new instance of the provided scene.

Schedule the spawn of a new instance of the provided scene as a child of parent.

Schedule the despawn of all instances of the provided scene.

Schedule the despawn of all instances of the provided dynamic scene.

Schedule the despawn of a scene instance, removing all its entities from the world.

Note: this will despawn all entities associated with this instance, including those that have been removed from the scene hierarchy. To despawn only entities still in the hierarchy, despawn the relevant root entity directly.

This will remove all records of this instance, without despawning any entities.

Immediately despawns all instances of a scene.

Immediately despawns all instances of a dynamic scene.

Immediately despawns a scene instance, removing all its entities from the world.

Immediately spawns a new instance of the provided dynamic scene.

Immediately spawns a new instance of the provided scene.

Iterate through all instances of the provided scenes and update those immediately.

Useful for updating already spawned scene instances after their corresponding scene has been modified.

Iterate through all instances of the provided dynamic scenes and update those immediately.

Useful for updating already spawned scene instances after their corresponding dynamic scene has been modified.

Immediately despawns all scenes scheduled for despawn by despawning their instances.

Immediately despawns all scene instances scheduled for despawn.

Immediately spawns all scenes scheduled for spawn.

Check that a scene instance spawned previously is ready to use

Get an iterator over the entities in an instance, once it’s spawned.

Before the scene is spawned, the iterator will be empty. Use Self::instance_is_ready to check if the instance is ready.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SceneSpawner { /* private fields */ }
```

---

## Function in_state Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.in_state.html

**Contents:**
- Function in_state Copy item path
- §Example
      - Examples found in repository?

Generates a SystemCondition-satisfying closure that returns true if the state machine is currently in state.

Will return false if the state does not exist or if not in state.

**Examples:**

Example 1 (unknown):
```unknown
pub fn in_state<S>(state: S) -> impl FnMut(Option<Res<'_, State<S>>>) + Clonewhere
    S: States,
```

Example 2 (unknown):
```unknown
#[derive(States, Clone, Copy, Default, Eq, PartialEq, Hash, Debug)]
enum GameState {
    #[default]
    Playing,
    Paused,
}

app
    .init_state::<GameState>()
    .add_systems(Update, (
        // `in_state` will only return true if the
        // given state equals the given value
        play_system.run_if(in_state(GameState::Playing)),
        pause_system.run_if(in_state(GameState::Paused)),
    ));

fn play_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

fn pause_system(mut counter: ResMut<Counter>) {
    counter.0 -= 1;
}

// We default to `GameState::Playing` so `play_
...
```

Example 3 (unknown):
```unknown
12fn main() {
13    App::new()
14        .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest())) // fallback to nearest sampling
15        .init_state::<AppState>()
16        .add_systems(OnEnter(AppState::Setup), load_textures)
17        .add_systems(Update, check_textures.run_if(in_state(AppState::Setup)))
18        .add_systems(OnEnter(AppState::Finished), setup)
19        .run();
20}
```

Example 4 (javascript):
```javascript
53    pub fn splash_plugin(app: &mut App) {
54        // As this plugin is managing the splash screen, it will focus on the state `GameState::Splash`
55        app
56            // When entering the state, spawn everything needed for this screen
57            .add_systems(OnEnter(GameState::Splash), splash_setup)
58            // While in this state, run the `countdown` system
59            .add_systems(Update, countdown.run_if(in_state(GameState::Splash)));
60    }
61
62    // Tag component used to tag entities added on the splash screen
63    #[derive(Component)]
64    struct OnSplashScreen;
...
```

---

## Enum UiAntiAlias Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.UiAntiAlias.html

**Contents:**
- Enum UiAntiAlias Copy item path
- Variants§
  - On
  - Off
- Trait Implementations§
  - impl Clone for UiAntiAlias
    - fn clone(&self) -> UiAntiAlias
    - fn clone_from(&mut self, source: &Self)
  - impl Component for UiAntiAliaswhere UiAntiAlias: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table

Marker for controlling whether UI is rendered with or without anti-aliasing in a camera. By default, UI is always anti-aliased.

Note: This does not affect text anti-aliasing. For that, use the font_smoothing property of the TextFont component.

UI will render with anti-aliasing

UI will render without anti-aliasing

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum UiAntiAlias {
    On,
    Off,
}
```

Example 2 (unknown):
```unknown
use bevy_camera::prelude::*;
use bevy_ecs::prelude::*;
use bevy_ui::prelude::*;
use bevy_ui_render::prelude::*;

fn spawn_camera(mut commands: Commands) {
    commands.spawn((
        Camera2d,
        // This will cause all UI in this camera to be rendered without
        // anti-aliasing
        UiAntiAlias::Off,
    ));
}
```

---

## Struct AnimationTransitions Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationTransitions.html

**Contents:**
- Struct AnimationTransitions Copy item path
- Implementations§
  - impl AnimationTransitions
    - pub fn new() -> AnimationTransitions
      - Examples found in repository?
    - pub fn play<'p>( &mut self, player: &'p mut AnimationPlayer, new_animation: NodeIndex, transition_duration: Duration, ) -> &'p mut ActiveAnimation
      - Examples found in repository?
    - pub fn get_main_animation(&self) -> Option<NodeIndex>
- Trait Implementations§
  - impl Clone for AnimationTransitions

Manages fade-out of animation blend factors, allowing for smooth transitions between animations.

To use this component, place it on the same entity as the AnimationPlayer and AnimationGraphHandle. It’ll take responsibility for adjusting the weight on the ActiveAnimation in order to fade out animations smoothly.

When using an AnimationTransitions component, you should play all animations through the AnimationTransitions::play method, rather than by directly manipulating the AnimationPlayer. Playing animations through the AnimationPlayer directly will cause the AnimationTransitions component to get confused about which animation is the “main” animation, and transitions will usually be incorrect as a result.

Creates a new AnimationTransitions component, ready to be added to an entity with an AnimationPlayer.

Plays a new animation on the given AnimationPlayer, fading out any existing animations that were already playing over the transition_duration.

Pass Duration::ZERO to instantly switch to a new animation, avoiding any transition.

Obtain the currently playing main animation.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationTransitions { /* private fields */ }
```

Example 2 (javascript):
```javascript
285    fn pause_animation_frame(
286        scene_ready: On<SceneInstanceReady>,
287        children: Query<&Children>,
288        mut commands: Commands,
289        animation: Res<Animation>,
290        mut players: Query<(Entity, &mut AnimationPlayer)>,
291    ) {
292        for child in children.iter_descendants(scene_ready.entity) {
293            if let Ok((entity, mut player)) = players.get_mut(child) {
294                let mut transitions = AnimationTransitions::new();
295                transitions
296                    .play(&mut player, animation.animation, Duration::ZERO)
297    
...
```

Example 3 (javascript):
```javascript
105fn setup_scene_once_loaded(
106    mut commands: Commands,
107    animations: Res<Animations>,
108    mut players: Query<(Entity, &mut AnimationPlayer), Added<AnimationPlayer>>,
109) {
110    for (entity, mut player) in &mut players {
111        let mut transitions = AnimationTransitions::new();
112
113        // Make sure to start the animation via the `AnimationTransitions`
114        // component. The `AnimationTransitions` component wants to manage all
115        // the animations and will get confused if the animations are started
116        // directly via the `AnimationPlayer`.
117  
...
```

Example 4 (javascript):
```javascript
142fn setup_scene_once_loaded(
143    mut commands: Commands,
144    animations: Res<Animations>,
145    feet: Res<FoxFeetTargets>,
146    graphs: Res<Assets<AnimationGraph>>,
147    mut clips: ResMut<Assets<AnimationClip>>,
148    mut players: Query<(Entity, &mut AnimationPlayer), Added<AnimationPlayer>>,
149) {
150    fn get_clip<'a>(
151        node: AnimationNodeIndex,
152        graph: &AnimationGraph,
153        clips: &'a mut Assets<AnimationClip>,
154    ) -> &'a mut AnimationClip {
155        let node = graph.get(node).unwrap();
156        let clip = match &node.node_type {
157       
...
```

---

## Struct ConstantCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ConstantCurve.html

**Contents:**
- Struct ConstantCurve Copy item path
- Implementations§
  - impl<T> ConstantCurve<T>where T: Clone,
    - pub fn new(domain: Interval, value: T) -> ConstantCurve<T>
- Trait Implementations§
  - impl<T> Clone for ConstantCurve<T>where T: Clone,
    - fn clone(&self) -> ConstantCurve<T>
    - fn clone_from(&mut self, source: &Self)
  - impl<T> Curve<T> for ConstantCurve<T>where T: Clone,
    - fn domain(&self) -> Interval

A curve with a constant value over its domain.

This is a curve that holds an inner value and always produces a clone of that value when sampled.

Create a constant curve, which has the given domain and always produces the given value when sampled.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ConstantCurve<T> { /* private fields */ }
```

---

## Struct SpotLight Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpotLight.html

**Contents:**
- Struct SpotLight Copy item path
- Fields§
- Implementations§
  - impl SpotLight
    - pub const DEFAULT_SHADOW_DEPTH_BIAS: f32 = 0.0199999996f32
    - pub const DEFAULT_SHADOW_NORMAL_BIAS: f32 = 1.79999995f32
    - pub const DEFAULT_SHADOW_MAP_NEAR_Z: f32 = 0.100000001f32
- Trait Implementations§
  - impl Clone for SpotLight
    - fn clone(&self) -> SpotLight

A light that emits light in a given direction from a central point.

Behaves like a point light in a perfectly absorbent housing that shines light only in a given direction. The direction is taken from the transform, and can be specified with Transform::looking_at.

To control the resolution of the shadow maps, use the DirectionalLightShadowMap resource.

The color of the light.

By default, this is white.

Luminous power in lumens, representing the amount of light emitted by this source in all directions.

Range in meters that this light illuminates.

Note that this value affects resolution of the shadow maps; generally, the higher you set it, the lower-resolution your shadow maps will be. Consequently, you should set this value to be only the size that you need.

Simulates a light source coming from a spherical volume with the given radius.

This affects the size of specular highlights created by this light, as well as the soft shadow penumbra size. Because of this, large values may not produce the intended result – for example, light radius does not affect shadow softness or diffuse lighting.

Whether this light casts shadows.

Note that shadows are rather expensive and become more so with every light that casts them. In general, it’s best to aggressively limit the number of lights with shadows enabled to one or two at most.

Whether soft shadows are enabled.

Soft shadows, also known as percentage-closer soft shadows or PCSS, cause shadows to become blurrier (i.e. their penumbra increases in radius) as they extend away from objects. The blurriness of the shadow depends on the SpotLight::radius of the light; larger lights result in larger penumbras and therefore blurrier shadows.

Currently, soft shadows are rather noisy if not using the temporal mode. If you enable soft shadows, consider choosing ShadowFilteringMethod::Temporal and enabling temporal antialiasing (TAA) to smooth the noise out over time.

Note that soft shadows are significantly more expensive to render than hard shadows.

Whether this spot light contributes diffuse lighting to meshes with lightmaps.

Set this to false if your lightmap baking tool bakes the direct diffuse light from this directional light into the lightmaps in order to avoid counting the radiance from this light twice. Note that the specular portion of the light is always considered, because Bevy currently has no means to bake specular light.

By default, this is set to true.

A value that adjusts the tradeoff between se

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpotLight {
    pub color: Color,
    pub intensity: f32,
    pub range: f32,
    pub radius: f32,
    pub shadows_enabled: bool,
    pub soft_shadows_enabled: bool,
    pub affects_lightmapped_mesh_diffuse: bool,
    pub shadow_depth_bias: f32,
    pub shadow_normal_bias: f32,
    pub shadow_map_near_z: f32,
    pub outer_angle: f32,
    pub inner_angle: f32,
}
```

---

## Struct UiPosition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiPosition.html

**Contents:**
- Struct UiPosition Copy item path
- Fields§
- Implementations§
  - impl UiPosition
    - pub const TOP_LEFT: UiPosition
    - pub const LEFT: UiPosition
    - pub const BOTTOM_LEFT: UiPosition
    - pub const TOP: UiPosition
    - pub const CENTER: UiPosition
    - pub const BOTTOM: UiPosition

Responsive position relative to a UI node.

Normalized anchor point

Responsive horizontal position relative to the anchor point

Responsive vertical position relative to the anchor point

Position at the top-left corner

Position at the center of the left edge

Position at the bottom-left corner

Position at the center of the top edge

Position at the center of the element

Position at the center of the bottom edge

Position at the top-right corner

Position at the center of the right edge

Position at the bottom-right corner

Position at the given normalized anchor point

Create a new position

Creates a position from self with the given x and y coordinates

Creates a position from self with the given x coordinate

Creates a position from self with the given y coordinate

Creates a position in logical pixels from self with the given x and y coordinates

Creates a percentage position from self with the given x and y coordinates

Creates a position from self with the given anchor point

Position relative to the top-left corner

Position relative to the left edge

Position relative to the bottom-left corner

Position relative to the top edge

Position relative to the center

Position relative to the bottom edge

Position relative to the top-right corner

Position relative to the right edge

Position relative to the bottom-right corner

Resolves the Position into physical coordinates.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiPosition {
    pub anchor: Vec2,
    pub x: Val,
    pub y: Val,
}
```

Example 2 (unknown):
```unknown
16fn setup(mut commands: Commands) {
17    commands.spawn(Camera2d);
18    commands
19        .spawn(Node {
20            display: Display::Grid,
21            width: percent(100),
22            height: percent(100),
23
24            ..Default::default()
25        })
26        .with_children(|commands| {
27            commands.spawn((
28                Node {
29                    width: percent(100),
30                    height: percent(100),
31                    ..Default::default()
32                },
33                BackgroundColor(Color::BLACK),
34                BackgroundGradient(v
...
```

---

## Trait AppLabel Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/trait.AppLabel.html

**Contents:**
- Trait AppLabel Copy item path
- Required Methods§
    - fn dyn_clone(&self) -> Box<dyn AppLabel>
- Provided Methods§
    - fn intern(&self) -> Interned<dyn AppLabel>where Self: Sized,
- Trait Implementations§
  - impl Hash for dyn AppLabel
    - fn hash<H>(&self, state: &mut H)where H: Hasher,
  - impl Internable for dyn AppLabel
    - fn leak(&self) -> &'static dyn AppLabel

A strongly-typed class of labels used to identify an App.

Clones this AppLabel.

Returns an Interned value corresponding to self.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AppLabel:
    Send
    + Sync
    + Debug
    + DynEq
    + DynHash {
    // Required method
    fn dyn_clone(&self) -> Box<dyn AppLabel>;

    // Provided method
    fn intern(&self) -> Interned<dyn AppLabel>
       where Self: Sized { ... }
}
```

---

## Struct CubicInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicInOutCurve.html

**Contents:**
- Struct CubicInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for CubicInOutCurve
    - fn clone(&self) -> CubicInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for CubicInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as CubicIn for t < 0.5 and as CubicOut for t >= 0.5

Due to this piecewise definition, this is only C¹ despite being a cubic: the acceleration jumps from +12 to -12 at t = ½.

Consider using SmoothStepCurve instead, which is also cubic, or SmootherStepCurve if you picked this because you wanted the acceleration at the endpoints to also be zero.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicInOutCurve;
```

---

## Struct AnimationGraphHandle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationGraphHandle.html

**Contents:**
- Struct AnimationGraphHandle Copy item path
- Tuple Fields§
- Methods from Deref<Target = Handle<AnimationGraph>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§
  - impl Clone for AnimationGraphHandle

A Handle to the AnimationGraph to be used by the AnimationPlayer on the same entity.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationGraphHandle(pub Handle<AnimationGraph>);
```

Example 2 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 3 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

Example 4 (javascript):
```javascript
169fn print_counts(
170    time: Res<Time>,
171    mut timer: Local<PrintingTimer>,
172    texts: Query<&ViewVisibility, With<Text2d>>,
173    atlases: Res<FontAtlasSets>,
174    font: Res<FontHandle>,
175) {
176    timer.tick(time.delta());
177    if !timer.just_finished() {
178        return;
179    }
180
181    let num_atlases = atlases
182        .get(font.0.id())
183        .map(|set| set.iter().map(|atlas| atlas.1.len()).sum())
184        .unwrap_or(0);
185
186    let visible_texts = texts.iter().filter(|visibility| visibility.get()).count();
187
188    info!(
189        "Texts: {} Visib
...
```

---

## Enum OverflowAxis Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.OverflowAxis.html

**Contents:**
- Enum OverflowAxis Copy item path
- Variants§
  - Visible
  - Clip
  - Hidden
  - Scroll
- Implementations§
  - impl OverflowAxis
    - pub const DEFAULT: OverflowAxis = Self::Visible
    - pub const fn is_visible(&self) -> bool

Whether to show or hide overflowing items

Show overflowing items.

Hide overflowing items by clipping.

Hide overflowing items by influencing layout and then clipping.

Scroll overflowing items.

Overflow is visible on this axis

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum OverflowAxis {
    Visible,
    Clip,
    Hidden,
    Scroll,
}
```

---

## Struct RunFixedMainLoop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.RunFixedMainLoop.html

**Contents:**
- Struct RunFixedMainLoop Copy item path
- Trait Implementations§
  - impl Clone for RunFixedMainLoop
    - fn clone(&self) -> RunFixedMainLoop
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for RunFixedMainLoop
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for RunFixedMainLoop
    - fn default() -> RunFixedMainLoop
  - impl Hash for RunFixedMainLoop

Runs the FixedMain schedule in a loop according until all relevant elapsed time has been “consumed”.

If you need to order your variable timestep systems before or after the fixed update logic, use the RunFixedMainLoopSystems system set.

Note that in contrast to most other Bevy schedules, systems added directly to RunFixedMainLoop will not be parallelized between each other.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RunFixedMainLoop;
```

---

## Enum Msaa Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Msaa.html

**Contents:**
- Enum Msaa Copy item path
- Variants§
  - Off = 1
  - Sample2 = 2
  - Sample4 = 4
  - Sample8 = 8
- Implementations§
  - impl Msaa
    - pub fn samples(&self) -> u32
      - Examples found in repository?

Component for configuring the number of samples for Multi-Sample Anti-Aliasing for a Camera.

Defaults to 4 samples. A higher number of samples results in smoother edges.

Some advanced rendering features may require that MSAA is disabled.

Note that the web currently only supports 1 or 4 samples.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Msaa {
    Off = 1,
    Sample2 = 2,
    Sample4 = 4,
    Sample8 = 8,
}
```

Example 2 (unknown):
```unknown
354    fn specialize(
355        &self,
356        key: Self::Key,
357        descriptor: &mut RenderPipelineDescriptor,
358    ) -> Result<Canonical<Self::Key>, BevyError> {
359        descriptor.multisample.count = key.0.samples();
360        Ok(key)
361    }
```

Example 3 (javascript):
```javascript
124fn queue_custom(
125    transparent_3d_draw_functions: Res<DrawFunctions<Transparent3d>>,
126    custom_pipeline: Res<CustomPipeline>,
127    mut pipelines: ResMut<SpecializedMeshPipelines<CustomPipeline>>,
128    pipeline_cache: Res<PipelineCache>,
129    meshes: Res<RenderAssets<RenderMesh>>,
130    render_mesh_instances: Res<RenderMeshInstances>,
131    material_meshes: Query<(Entity, &MainEntity), With<InstanceMaterialData>>,
132    mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent3d>>,
133    views: Query<(&ExtractedView, &Msaa)>,
134) {
135    let draw_custom = 
...
```

Example 4 (javascript):
```javascript
377pub fn queue_colored_mesh2d(
378    transparent_draw_functions: Res<DrawFunctions<Transparent2d>>,
379    colored_mesh2d_pipeline: Res<ColoredMesh2dPipeline>,
380    mut pipelines: ResMut<SpecializedRenderPipelines<ColoredMesh2dPipeline>>,
381    pipeline_cache: Res<PipelineCache>,
382    render_meshes: Res<RenderAssets<RenderMesh>>,
383    render_mesh_instances: Res<RenderColoredMesh2dInstances>,
384    mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent2d>>,
385    views: Query<(&RenderVisibleEntities, &ExtractedView, &Msaa)>,
386) {
387    if render_mesh_instances.is
...
```

---

## Struct FixedPostUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FixedPostUpdate.html

**Contents:**
- Struct FixedPostUpdate Copy item path
- Trait Implementations§
  - impl Clone for FixedPostUpdate
    - fn clone(&self) -> FixedPostUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedPostUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedPostUpdate
    - fn default() -> FixedPostUpdate
  - impl Hash for FixedPostUpdate

The schedule that runs after the FixedUpdate schedule, for reacting to changes made in the main update logic.

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedPostUpdate;
```

---

## Struct Schedules Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Schedules.html

**Contents:**
- Struct Schedules Copy item path
- Fields§
- Implementations§
  - impl Schedules
    - pub fn new() -> Schedules
    - pub fn insert(&mut self, schedule: Schedule) -> Option<Schedule>
    - pub fn remove(&mut self, label: impl ScheduleLabel) -> Option<Schedule>
    - pub fn remove_entry( &mut self, label: impl ScheduleLabel, ) -> Option<(Interned<dyn ScheduleLabel>, Schedule)>
    - pub fn contains(&self, label: impl ScheduleLabel) -> bool
    - pub fn get(&self, label: impl ScheduleLabel) -> Option<&Schedule>

Resource that stores Schedules mapped to ScheduleLabels excluding the current running Schedule.

List of ComponentIds to ignore when reporting system order ambiguity conflicts

Constructs an empty Schedules with zero initial capacity.

Inserts a labeled schedule into the map.

If the map already had an entry for label, schedule is inserted, and the old schedule is returned. Otherwise, None is returned.

Removes the schedule corresponding to the label from the map, returning it if it existed.

Removes the (schedule, label) pair corresponding to the label from the map, returning it if it existed.

Does a schedule with the provided label already exist?

Returns a reference to the schedule associated with label, if it exists.

Returns a mutable reference to the schedule associated with label, if it exists.

Returns a mutable reference to the schedules associated with label, creating one if it doesn’t already exist.

Returns an iterator over all schedules. Iteration order is undefined.

Returns an iterator over mutable references to all schedules. Iteration order is undefined.

Applies the provided ScheduleBuildSettings to all schedules.

Ignore system order ambiguities caused by conflicts on Components of type T.

Ignore system order ambiguities caused by conflicts on Resources of type T.

Iterate through the ComponentId’s that will be ignored.

Prints the names of the components and resources with info

May panic or retrieve incorrect names if Components is not from the same world

Adds one or more systems to the Schedule matching the provided ScheduleLabel.

Configures a collection of system sets in the provided schedule, adding any sets that do not exist.

Suppress warnings and errors that would result from systems in these sets having ambiguities (conflicting access but indeterminate order) with systems in set.

When possible, do this directly in the .add_systems(Update, a.ambiguous_with(b)) call. However, sometimes two independent plugins A and B are reported as ambiguous, which you can only suppress as the consumer of both.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Schedules {
    pub ignored_scheduling_ambiguities: BTreeSet<ComponentId>,
    /* private fields */
}
```

Example 2 (javascript):
```javascript
99fn build_ui(
100    mut commands: Commands,
101    asset_server: Res<AssetServer>,
102    schedules: Res<Schedules>,
103    mut stepping: ResMut<Stepping>,
104    mut state: ResMut<State>,
105) {
106    let mut text_spans = Vec::new();
107    let mut always_run: Vec<(
108        bevy_ecs::intern::Interned<dyn ScheduleLabel + 'static>,
109        NodeId,
110    )> = Vec::new();
111
112    let Ok(schedule_order) = stepping.schedules() else {
113        return;
114    };
115
116    // go through the stepping schedules and construct a list of systems for
117    // each label
118    for label in 
...
```

Example 3 (javascript):
```javascript
76fn count_ambiguities(sub_app: &SubApp) -> AmbiguitiesCount {
77    let schedules = sub_app.world().resource::<Schedules>();
78    let mut ambiguities = <HashMap<_, _>>::default();
79    for (_, schedule) in schedules.iter() {
80        let ambiguities_in_schedule = schedule.graph().conflicting_systems().len();
81        ambiguities.insert(schedule.label(), ambiguities_in_schedule);
82    }
83    AmbiguitiesCount(ambiguities)
84}
```

Example 4 (javascript):
```javascript
63fn configure_ambiguity_detection(sub_app: &mut SubApp) {
64    let mut schedules = sub_app.world_mut().resource_mut::<Schedules>();
65    for (_, schedule) in schedules.iter_mut() {
66        schedule.set_build_settings(ScheduleBuildSettings {
67            // NOTE: you can change this to `LogLevel::Ignore` to easily see the current number of ambiguities.
68            ambiguity_detection: LogLevel::Warn,
69            use_shortnames: false,
70            ..default()
71        });
72    }
73}
```

---

## Enum SliceScaleMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.SliceScaleMode.html

**Contents:**
- Enum SliceScaleMode Copy item path
- Variants§
  - Stretch
  - Tile
    - Fields
- Trait Implementations§
  - impl Clone for SliceScaleMode
    - fn clone(&self) -> SliceScaleMode
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for SliceScaleMode

Defines how a texture slice scales when resized

The slice will be stretched to fit the area

The slice will be tiled to fit the area

The slice will repeat when the ratio between the drawing dimensions of texture and the original texture size are above stretch_value.

Example: 1.0 means that a 10 pixel wide image would repeat after 10 screen pixels. 2.0 means it would repeat after 20 screen pixels.

Note: The value should be inferior or equal to 1.0 to avoid quality loss.

Note: the value will be clamped to 0.001 if lower

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum SliceScaleMode {
    Stretch,
    Tile {
        stretch_value: f32,
    },
}
```

---

## Struct ViewportNode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ViewportNode.html

**Contents:**
- Struct ViewportNode Copy item path
- §See Also
- Fields§
- Implementations§
  - impl ViewportNode
    - pub const fn new(camera: Entity) -> ViewportNode
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for ViewportNode
    - fn clone(&self) -> ViewportNode

Component used to render a Camera::target to a node.

update_viewport_render_target_size

The entity representing the Camera associated with this viewport.

Note that removing the ViewportNode component will not despawn this entity.

Creates a new ViewportNode with a given camera.

Required Components: Node, PointerId.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ViewportNode {
    pub camera: Entity,
}
```

Example 2 (javascript):
```javascript
25fn test(
26    mut commands: Commands,
27    mut images: ResMut<Assets<Image>>,
28    mut meshes: ResMut<Assets<Mesh>>,
29    mut materials: ResMut<Assets<StandardMaterial>>,
30) {
31    // Spawn a UI camera
32    commands.spawn(Camera3d::default());
33
34    // Set up an texture for the 3D camera to render to.
35    // The size of the texture will be based on the viewport's ui size.
36    let mut image = Image::new_uninit(
37        default(),
38        TextureDimension::D2,
39        TextureFormat::Bgra8UnormSrgb,
40        RenderAssetUsages::all(),
41    );
42    image.texture_descriptor.
...
```

---

## Function vmax Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vmax.html

**Contents:**
- Function vmax Copy item path
      - Examples found in repository?

Returns a Val::VMax representing a percentage of the viewport’s larger dimension.

**Examples:**

Example 1 (unknown):
```unknown
pub fn vmax<T>(value: T) -> Valwhere
    T: ValNum,
```

Example 2 (unknown):
```unknown
68fn spawn_with_viewport_coords(commands: &mut Commands) {
69    commands
70        .spawn((
71            Node {
72                width: vw(100),
73                height: vh(100),
74                border: UiRect::axes(vw(5), vh(5)),
75                flex_wrap: FlexWrap::Wrap,
76                ..default()
77            },
78            BorderColor::all(PALETTE[0]),
79            Coords::Viewport,
80        ))
81        .with_children(|builder| {
82            builder.spawn((
83                Node {
84                    width: vw(30),
85                    height: vh(30),
86             
...
```

---

## Struct TextureAtlas Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextureAtlas.html

**Contents:**
- Struct TextureAtlas Copy item path
- Fields§
- Implementations§
  - impl TextureAtlas
    - pub fn texture_rect( &self, texture_atlases: &Assets<TextureAtlasLayout>, ) -> Option<URect>
    - pub fn with_index(self, index: usize) -> TextureAtlas
    - pub fn with_layout(self, layout: Handle<TextureAtlasLayout>) -> TextureAtlas
- Trait Implementations§
  - impl Clone for TextureAtlas
    - fn clone(&self) -> TextureAtlas

An index into a TextureAtlasLayout, which corresponds to a specific section of a texture.

It stores a handle to TextureAtlasLayout and the index of the current section of the atlas. The texture atlas contains various sections of a given texture, allowing users to have a single image file for either sprite animation or global mapping. You can change the texture index of the atlas to animate the sprite or display only a section of the texture for efficient rendering of related game objects.

Check the following examples for usage:

Texture atlas layout handle

Texture atlas section index

Retrieves the current texture URect of the sprite sheet according to the section index

Returns this TextureAtlas with the specified index.

Returns this TextureAtlas with the specified TextureAtlasLayout handle.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureAtlas {
    pub layout: Handle<TextureAtlasLayout>,
    pub index: usize,
}
```

---

## Function pointer_events Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.pointer_events.html

**Contents:**
- Function pointer_events Copy item path

Dispatches interaction events to the target entities.

Within a single frame, events are dispatched in the following order:

Additionally, across multiple frames, the following are also strictly ordered by the interaction state machine:

Two events – Over and Out – are driven only by the HoverMap. The rest rely on additional data from the PointerInput event stream. To receive these events for a custom pointer, you must add PointerInput events.

When the pointer goes from hovering entity A to entity B, entity A will receive Out and then entity B will receive Over. No entity will ever receive both an Over and and a Out event during the same frame.

When we account for event bubbling, this is no longer true. When the hovering focus shifts between children, parent entities may receive redundant Out → Over pairs. In the context of UI, this is especially problematic. Additional hierarchy-aware events will be added in a future release.

Both Click and Release target the entity hovered in the previous frame, rather than the current frame. This is because touch pointers hover nothing on the frame they are released. The end effect is that these two events can be received sequentially after an Out event (but always on the same frame as the Out event).

Note: Though it is common for the PointerInput stream may contain multiple pointer movements and presses each frame, the hover state is determined only by the pointer’s final position. Since the hover state ultimately determines which entities receive events, this may mean that an entity can receive events from before or after it was actually hovered.

**Examples:**

Example 1 (unknown):
```unknown
pub fn pointer_events(
    input_events: MessageReader<'_, '_, PointerInput>,
    pointers: Query<'_, '_, &PointerLocation>,
    pointer_map: Res<'_, PointerMap>,
    hover_map: Res<'_, HoverMap>,
    previous_hover_map: Res<'_, PreviousHoverMap>,
    pointer_state: ResMut<'_, PointerState>,
    commands: Commands<'_, '_>,
    message_writers: PickingMessageWriters<'_>,
)
```

---

## Struct Label Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Label.html

**Contents:**
- Struct Label Copy item path
- Trait Implementations§
  - impl Clone for Label
    - fn clone(&self) -> Label
    - fn clone_from(&mut self, source: &Self)
  - impl Component for Labelwhere Label: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

Marker struct for labels

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Label;
```

---

## Struct Res Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Res.html

**Contents:**
- Struct Res Copy item path
- Implementations§
  - impl<'w, T> Res<'w, T>where T: Resource,
    - pub fn clone(this: &Res<'w, T>) -> Res<'w, T>
    - pub fn into_inner(self) -> &'w T
      - Examples found in repository?
- Trait Implementations§
  - impl<'w, T> AsRef<T> for Res<'w, T>where T: Resource,
    - fn as_ref(&self) -> &T
  - impl<'w, T> Debug for Res<'w, T>where T: Resource + Debug + ?Sized,

Shared borrow of a Resource.

See the Resource documentation for usage.

If you need a unique mutable borrow, use ResMut instead.

This SystemParam fails validation if resource doesn’t exist. This will cause a panic, but can be configured to do nothing or warn once.

Use Option<Res<T>> instead if the resource might not always exist.

Copies a reference to a resource.

Note that unless you actually need an instance of Res<T>, you should prefer to just convert it to &T which can be freely copied.

Due to lifetime limitations of the Deref trait, this method can be used to obtain a reference of the Resource with a lifetime bound to 'w instead of the lifetime of the struct itself.

Convert a Res into a Ref. This allows keeping the change-detection feature of Ref while losing the specificity of Res for resources.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Res<'w, T>where
    T: Resource + ?Sized,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
174fn scheduled_spawner(
175    mut commands: Commands,
176    args: Res<Args>,
177    window: Single<&Window>,
178    mut scheduled: ResMut<BirdScheduled>,
179    mut counter: ResMut<BevyCounter>,
180    bird_resources: ResMut<BirdResources>,
181) {
182    if scheduled.waves > 0 {
183        let bird_resources = bird_resources.into_inner();
184        spawn_birds(
185            &mut commands,
186            args.into_inner(),
187            &window.resolution,
188            &mut counter,
189            scheduled.per_wave,
190            bird_resources,
191            None,
192            sc
...
```

Example 3 (javascript):
```javascript
69    fn render<'w>(
70        _: &P,
71        _: ROQueryItem<'w, '_, Self::ViewQuery>,
72        _: Option<ROQueryItem<'w, '_, Self::ItemQuery>>,
73        custom_phase_item_buffers: SystemParamItem<'w, '_, Self::Param>,
74        pass: &mut TrackedRenderPass<'w>,
75    ) -> RenderCommandResult {
76        // Borrow check workaround.
77        let custom_phase_item_buffers = custom_phase_item_buffers.into_inner();
78
79        // Tell the GPU where the vertices are.
80        pass.set_vertex_buffer(
81            0,
82            custom_phase_item_buffers
83                .vertices
84      
...
```

Example 4 (javascript):
```javascript
50fn setup(
51    mut commands: Commands,
52    args: Res<Args>,
53    mesh_assets: ResMut<Assets<Mesh>>,
54    material_assets: ResMut<Assets<StandardMaterial>>,
55) {
56    let args = args.into_inner();
57    let material_assets = material_assets.into_inner();
58    let mesh_assets = mesh_assets.into_inner();
59    let n = args.grid_size;
60
61    // Camera
62    let w = n as f32;
63    commands.spawn((
64        Camera3d::default(),
65        Transform::from_xyz(w * 1.25, w + 1.0, w * 1.25)
66            .looking_at(Vec3::new(0.0, (w * -1.1) + 1.0, 0.0), Vec3::Y),
67    ));
68
69    // Ligh
...
```

---

## Struct TransformPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TransformPlugin.html

**Contents:**
- Struct TransformPlugin Copy item path
- Trait Implementations§
  - impl Default for TransformPlugin
    - fn default() -> TransformPlugin
  - impl Plugin for TransformPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

The base plugin for handling Transform components

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TransformPlugin;
```

---

## Struct Press Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Press.html

**Contents:**
- Struct Press Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Press
    - fn clone(&self) -> Press
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Press
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Press
    - type This<'from_arg> = Press

Fires when a pointer button is pressed over the target entity.

Pointer button pressed to trigger this event.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Press {
    pub button: PointerButton,
    pub hit: HitData,
}
```

---

## Struct Transform Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Transform.html

**Contents:**
- Struct Transform Copy item path
  - §Transform and GlobalTransform
- §Examples
- Fields§
- Implementations§
  - impl Transform
    - pub const IDENTITY: Transform
    - pub const fn from_xyz(x: f32, y: f32, z: f32) -> Transform
      - Examples found in repository?
    - pub fn from_matrix(world_from_local: Mat4) -> Transform

Describe the position of an entity. If the entity has a parent, the position is relative to its parent position.

Transform is the position of an entity relative to its parent position, or the reference frame if it doesn’t have a ChildOf component.

GlobalTransform is the position of an entity relative to the reference frame.

GlobalTransform is updated from Transform in the TransformSystems::Propagate system set.

This system runs during PostUpdate. If you update the Transform of an entity during this set or after, you will notice a 1 frame lag before the GlobalTransform is updated.

Position of the entity. In 2d, the last value of the Vec3 is used for z-ordering.

See the translations example for usage.

Rotation of the entity.

See the 3d_rotation example for usage.

See the scale example for usage.

An identity Transform with no translation, rotation, and a scale of 1 on all axes.

Creates a new Transform at the position (x, y, z). In 2d, the z component is used for z-ordering elements: higher z-value will be in front of lower z-value.

Extracts the translation, rotation, and scale from matrix. It must be a 3d affine transformation matrix.

Creates a new Transform, with translation. Rotation will be 0 and scale 1 on all axes.

Creates a new Transform, with rotation. Translation will be 0 and scale 1 on all axes.

Creates a new Transform, with scale. Translation will be 0 and rotation 0 on all axes.

Creates a new Transform that is equivalent to the given isometry.

Returns this Transform with a new rotation so that Transform::forward points towards the target position and Transform::up points towards up.

In some cases it’s not possible to construct a rotation. Another axis will be picked in those cases:

Returns this Transform with a new rotation so that Transform::forward points in the given direction and Transform::up points towards up.

In some cases it’s not possible to construct a rotation. Another axis will be picked in those cases:

Rotates this Transform so that the main_axis vector, reinterpreted in local coordinates, points in the given main_direction, while secondary_axis points towards secondary_direction. For example, if a spaceship model has its nose pointing in the X-direction in its own local coordinates and its dorsal fin pointing in the Y-direction, then align(Dir3::X, v, Dir3::Y, w) will make the spaceship’s nose point in the direction of v, while the dorsal fin does its best to point in the direction w.

In some cases a rotation ca

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Transform {
    pub translation: Vec3,
    pub rotation: Quat,
    pub scale: Vec3,
}
```

Example 2 (unknown):
```unknown
201fn spawn_light(commands: &mut Commands) {
202    commands.spawn((
203        DirectionalLight::default(),
204        Transform::from_xyz(4.0, 8.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y),
205    ));
206}
207
208/// Spawns the camera.
209fn spawn_camera(commands: &mut Commands) {
210    commands
211        .spawn(Camera3d::default())
212        .insert(Transform::from_xyz(0.0, 2.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y))
213        // Tag the camera with `Selection::Camera`.
214        .insert(Selection::Camera);
215}
```

Example 3 (unknown):
```unknown
157fn spawn_camera(commands: &mut Commands) {
158    commands
159        .spawn(Camera3d::default())
160        .insert(Transform::from_xyz(-0.7, 0.7, 1.0).looking_at(vec3(0.0, 0.3, 0.0), Vec3::Y));
161}
```

Example 4 (unknown):
```unknown
394fn spawn_camera(commands: &mut Commands) {
395    commands
396        .spawn(Camera3d::default())
397        .insert(Transform::from_xyz(0.0, 0.0, 9.0).looking_at(Vec3::ZERO, Vec3::Y))
398        .insert(DepthPrepass)
399        .insert(OcclusionCulling);
400}
```

---

## Struct Mat2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mat2.html

**Contents:**
- Struct Mat2 Copy item path
- Implementations§
  - impl Mat2
    - pub const ZERO: Mat2
    - pub const IDENTITY: Mat2
    - pub const NAN: Mat2
    - pub const fn from_cols(x_axis: Vec2, y_axis: Vec2) -> Mat2
    - pub const fn from_cols_array(m: &[f32; 4]) -> Mat2
    - pub const fn to_cols_array(&self) -> [f32; 4]
    - pub const fn from_cols_array_2d(m: &[[f32; 2]; 2]) -> Mat2

A 2x2 column major matrix.

SIMD vector types are used for storage on supported platforms.

This type is 16 byte aligned.

A 2x2 matrix with all elements set to 0.0.

A 2x2 identity matrix, where all diagonal elements are 1, and all off-diagonal elements are 0.

Creates a 2x2 matrix from two column vectors.

Creates a 2x2 matrix from a [f32; 4] array stored in column major order. If your data is stored in row major you will need to transpose the returned matrix.

Creates a [f32; 4] array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 2x2 matrix from a [[f32; 2]; 2] 2D array stored in column major order. If your data is in row major order you will need to transpose the returned matrix.

Creates a [[f32; 2]; 2] 2D array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 2x2 matrix with its diagonal set to diagonal and all other entries set to 0.

Creates a 2x2 matrix containing the combining non-uniform scale and rotation of angle (in radians).

Creates a 2x2 matrix containing a rotation of angle (in radians).

Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.

Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the ith column and jth row.

Panics if i or j is greater than 2.

Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.

Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the ith column and jth row.

Panics if i or j is greater than 2.

Creates a 2x2 matrix from the first 4 values in slice.

Panics if slice is less than 4 elements long.

Writes the columns of self to the first 4 elements in slice.

Panics if slice is less than 4 elements long.

Returns the matrix column for the given index.

Panics if index is greater than 1.

Returns a mutable reference to the matrix column for the given index.

Panics if index is greater than 1.

Returns the matrix row for the given index.

Panics if index is greater than 1.

Returns true if, and only if, all elements are finite. If any element is either NaN, positive or negative infinity, this will return false.

Returns true if any elements are NaN.

Returns the transpose of self.

Returns the determinant of self.

Returns the inverse of self.

If the matrix is not invertible the returned matrix will be invalid.

Will panic if the determinant of self is zero when glam_assert is enabled.

Transforms 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Mat2(/* private fields */);
```

---

## Trait GizmoPrimitive2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.GizmoPrimitive2d.html

**Contents:**
- Trait GizmoPrimitive2d Copy item path
- Required Associated Types§
    - type Output<'a> where Self: 'a
- Required Methods§
    - fn primitive_2d( &mut self, primitive: &P, isometry: impl Into<Isometry2d>, color: impl Into<Color>, ) -> Self::Output<'_>
- Dyn Compatibility§
- Implementors§
  - impl<Config, Clear> GizmoPrimitive2d<Annulus> for GizmoBuffer<Config, Clear>where Config: GizmoConfigGroup, Clear: 'static + Send + Sync,
    - type Output<'a> = Annulus2dBuilder<'a, Config, Clear> where GizmoBuffer<Config, Clear>: 'a
  - impl<Config, Clear> GizmoPrimitive2d<Arc2d> for GizmoBuffer<Config, Clear>where Config: GizmoConfigGroup, Clear: 'static + Send + Sync,

A trait for rendering 2D geometric primitives (P) with GizmoBuffer.

The output of primitive_2d. This is a builder to set non-default values.

Renders a 2D primitive with its associated details.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait GizmoPrimitive2d<P>where
    P: Primitive2d,{
    type Output<'a>
       where Self: 'a;

    // Required method
    fn primitive_2d(
        &mut self,
        primitive: &P,
        isometry: impl Into<Isometry2d>,
        color: impl Into<Color>,
    ) -> Self::Output<'_>;
}
```

---

## Struct PlaybackSettings Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PlaybackSettings.html

**Contents:**
- Struct PlaybackSettings Copy item path
- Fields§
- Implementations§
  - impl PlaybackSettings
    - pub const ONCE: PlaybackSettings
    - pub const LOOP: PlaybackSettings
    - pub const DESPAWN: PlaybackSettings
    - pub const REMOVE: PlaybackSettings
    - pub const fn paused(self) -> PlaybackSettings
    - pub const fn muted(self) -> PlaybackSettings

Initial settings to be used when audio starts playing.

If you would like to control the audio while it is playing, query for the AudioSink or SpatialAudioSink components. Changes to this component will not be applied to already-playing audio.

The desired playback behavior.

Create the sink in paused state. Useful for “deferred playback”, if you want to prepare the entity, but hear the sound later.

Whether to create the sink in muted state or not.

This is useful for audio that should be initially muted. You can still set the initial volume and it is applied when the audio is unmuted.

Enables spatial audio for this source.

See also: SpatialListener.

Note: Bevy does not currently support HRTF or any other high-quality 3D sound rendering features. Spatial audio is implemented via simple left-right stereo panning.

Optional scale factor applied to the positions of this audio source and the listener, overriding the default value configured on AudioPlugin::default_spatial_scale.

The point in time in the audio clip where playback should start. If set to None, it will play from the beginning of the clip.

If the playback mode is set to Loop, each loop will start from this position.

How long the audio should play before stopping. If set, the clip will play for at most the specified duration. If set to None, it will play for as long as it can.

If the playback mode is set to Loop, each loop will last for this duration.

Will play the associated audio source once.

Note: It is not possible to reuse an AudioPlayer after it has finished playing and the underlying AudioSink or SpatialAudioSink has been drained.

To replay a sound, the audio components provided by AudioPlayer must be removed and added again.

Will play the associated audio source in a loop.

Will play the associated audio source once and despawn the entity afterwards.

Will play the associated audio source once and remove the audio components afterwards.

Helper to start in a paused state.

Helper to start muted.

Helper to set the volume from start of playback.

Helper to set the speed from start of playback.

Helper to enable or disable spatial audio.

Helper to use a custom spatial scale.

Helper to use a custom playback start position.

Helper to use a custom playback duration.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PlaybackSettings {
    pub mode: PlaybackMode,
    pub volume: Volume,
    pub speed: f32,
    pub paused: bool,
    pub muted: bool,
    pub spatial: bool,
    pub spatial_scale: Option<SpatialScale>,
    pub start_position: Option<Duration>,
    pub duration: Option<Duration>,
}
```

Example 2 (javascript):
```javascript
26fn setup(
27    mut commands: Commands,
28    mut meshes: ResMut<Assets<Mesh>>,
29    mut materials: ResMut<Assets<ColorMaterial>>,
30    asset_server: Res<AssetServer>,
31) {
32    // Space between the two ears
33    let gap = 400.0;
34
35    // sound emitter
36    commands.spawn((
37        Mesh2d(meshes.add(Circle::new(15.0))),
38        MeshMaterial2d(materials.add(Color::from(BLUE))),
39        Transform::from_translation(Vec3::new(0.0, 50.0, 0.0)),
40        Emitter::default(),
41        AudioPlayer::new(asset_server.load("sounds/Windless Slopes.ogg")),
42        PlaybackSettings::LOOP
...
```

Example 3 (javascript):
```javascript
18fn setup(
19    mut commands: Commands,
20    asset_server: Res<AssetServer>,
21    mut meshes: ResMut<Assets<Mesh>>,
22    mut materials: ResMut<Assets<StandardMaterial>>,
23) {
24    // Space between the two ears
25    let gap = 4.0;
26
27    // sound emitter
28    commands.spawn((
29        Mesh3d(meshes.add(Sphere::new(0.2).mesh().uv(32, 18))),
30        MeshMaterial3d(materials.add(Color::from(BLUE))),
31        Transform::from_xyz(0.0, 0.0, 0.0),
32        Emitter::default(),
33        AudioPlayer::new(asset_server.load("sounds/Windless Slopes.ogg")),
34        PlaybackSettings::LOOP.w
...
```

---

## Struct RumbleSystems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RumbleSystems.html

**Contents:**
- Struct RumbleSystems Copy item path
- Trait Implementations§
  - impl Clone for RumbleSystems
    - fn clone(&self) -> RumbleSystems
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for RumbleSystems
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Hash for RumbleSystems
    - fn hash<__H>(&self, state: &mut __H)where __H: Hasher,
    - fn hash_slice<H>(data: &[Self], state: &mut H)where H: Hasher, Self: Sized,

Updates the running gamepad rumble effects.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RumbleSystems;
```

---

## Struct Changed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Changed.html

**Contents:**
- Struct Changed Copy item path
- §Deferred
- §Time complexity
- §Examples
- Trait Implementations§
  - impl<T> QueryFilter for Changed<T>where T: Component,
    - const IS_ARCHETYPAL: bool = false
    - unsafe fn filter_fetch( _state: &<Changed<T> as WorldQuery>::State, fetch: &mut <Changed<T> as WorldQuery>::Fetch<'_>, entity: Entity, table_row: TableRow, ) -> bool
  - impl<T> WorldQuery for Changed<T>where T: Component,
    - const IS_DENSE: bool

A filter on a component that only retains results the first time after they have been added or mutably dereferenced.

A common use for this filter is avoiding redundant work when values have not changed.

Note that simply mutably dereferencing a component is considered a change (DerefMut). Bevy does not compare components to their previous values.

To retain all results without filtering but still check whether they were changed after the system last ran, use Ref<T>.

Note that this includes changes that happened before the first time this Query was run.

Note, that entity modifications issued with Commands (like entity creation or entity component addition or removal) are visible only after deferred operations are applied, typically after the system that queued them.

Changed is not ArchetypeFilter, which practically means that if query (with T component filter) matches million entities, Changed<T> filter will iterate over all of them even if none of them were changed.

For example, these two systems are roughly equivalent in terms of performance:

SAFETY: fetch accesses a single component in a readonly way. This is sound because update_component_access add read access for that component and panics when appropriate. update_component_access adds a With filter for a component. This is sound because matches_component_set returns whether the set contains that component.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Changed<T>(/* private fields */);
```

Example 2 (unknown):
```unknown
fn system1(q: Query<&MyComponent, Changed<Transform>>) {
    for item in &q { /* component changed */ }
}

fn system2(q: Query<(&MyComponent, Ref<Transform>)>) {
    for item in &q {
        if item.1.is_changed() { /* component changed */ }
    }
}
```

Example 3 (unknown):
```unknown
fn print_moving_objects_system(query: Query<&Name, Changed<Transform>>) {
    for name in &query {
        println!("Entity Moved: {:?}", name);
    }
}
```

---

## Struct LinearCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LinearCurve.html

**Contents:**
- Struct LinearCurve Copy item path
- Trait Implementations§
  - impl Clone for LinearCurve
    - fn clone(&self) -> LinearCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for LinearCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LinearCurve;
```

---

## Struct TextBackgroundColor Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextBackgroundColor.html

**Contents:**
- Struct TextBackgroundColor Copy item path
- Tuple Fields§
- Implementations§
  - impl TextBackgroundColor
    - pub const BLACK: TextBackgroundColor
    - pub const WHITE: TextBackgroundColor
- Methods from Deref<Target = Color>§
    - pub const WHITE: Color
    - pub const BLACK: Color
    - pub const NONE: Color

The background color of the text for this section.

Return the color as a linear RGBA color.

Return the color as an SRGBA color.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextBackgroundColor(pub Color);
```

Example 2 (javascript):
```javascript
90fn animate(
91    mut materials: ResMut<Assets<CustomUiMaterial>>,
92    q: Query<&MaterialNode<CustomUiMaterial>>,
93    time: Res<Time>,
94) {
95    let duration = 2.0;
96    for handle in &q {
97        if let Some(material) = materials.get_mut(handle) {
98            // rainbow color effect
99            let new_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 1., 0.5);
100            let border_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 0.75, 0.75);
101            material.color = new_color.to_linear().to_vec4();
102            material.slider.x =
103              
...
```

Example 3 (unknown):
```unknown
228fn spawn_light_textures(
229    commands: &mut Commands,
230    asset_server: &AssetServer,
231    meshes: &mut Assets<Mesh>,
232    materials: &mut Assets<StandardMaterial>,
233) {
234    commands.spawn((
235        SpotLight {
236            color: Color::srgb(1.0, 1.0, 0.8),
237            intensity: 10e6,
238            outer_angle: 0.25,
239            inner_angle: 0.25,
240            shadows_enabled: true,
241            ..default()
242        },
243        Transform::from_translation(Vec3::new(6.0, 1.0, 2.0)).looking_at(Vec3::ZERO, Vec3::Y),
244        SpotLightTexture {
245        
...
```

Example 4 (unknown):
```unknown
104fn update_colors(
105    keyboard_input: Res<ButtonInput<KeyCode>>,
106    mut config: ResMut<Wireframe2dConfig>,
107    mut wireframe_colors: Query<&mut Wireframe2dColor>,
108    mut text: Single<&mut Text>,
109) {
110    text.0 = format!(
111        "Controls
112---------------
113Z - Toggle global
114X - Change global color
115C - Change color of the circle wireframe
116
117Wireframe2dConfig
118-------------
119Global: {}
120Color: {:?}",
121        config.global,
122        config.default_color.to_srgba(),
123    );
124
125    // Toggle showing a wireframe on all meshes
126    if keyboa
...
```

---

## Struct CubicOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicOutCurve.html

**Contents:**
- Struct CubicOutCurve Copy item path
- Trait Implementations§
  - impl Clone for CubicOutCurve
    - fn clone(&self) -> CubicOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for CubicOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = (t - 1.0)³ + 1.0

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicOutCurve;
```

---

## Struct FixedFirst Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedFirst.html

**Contents:**
- Struct FixedFirst Copy item path
- Trait Implementations§
  - impl Clone for FixedFirst
    - fn clone(&self) -> FixedFirst
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedFirst
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedFirst
    - fn default() -> FixedFirst
  - impl Hash for FixedFirst

Runs first in the FixedMain schedule.

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedFirst;
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/audio/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Traits§

This includes the most common types in this crate, re-exported for your convenience.

---

## Enum KeyCode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.KeyCode.html

**Contents:**
- Enum KeyCode Copy item path
  - §Usage
  - §Updating
- Variants§
  - Unidentified(NativeKeyCode)
  - Backquote
  - Backslash
  - BracketLeft
  - BracketRight
  - Comma

The key code of a KeyboardInput.

It is used as the generic T value of an ButtonInput to create a Res<ButtonInput<KeyCode>>.

Code representing the location of a physical key This mostly conforms to the UI Events Specification's KeyboardEvent.code with a few exceptions:

The resource is updated inside of the keyboard_input_system.

This variant is used when the key cannot be translated to any other variant.

The native keycode is provided (if available) so you’re able to more reliably match key-press and key-release events by hashing the KeyCode. It is also possible to use this for keybinds for non-standard keys, but such keybinds are tied to a given platform.

` on a US keyboard. This is also called a backtick or grave. This is the 半角/全角/漢字 (hankaku/zenkaku/kanji) key on Japanese keyboards

Used for both the US \ (on the 101-key layout) and also for the key located between the “ and Enter keys on row C of the 102-, 104- and 106-key layouts. Labeled # on a UK (102) keyboard.

Located between the left Shift and Z keys. Labeled \ on a UK keyboard.

Located between the / and right Shift keys. Labeled \ (ro) on a Japanese keyboard.

Located between the = and Backspace keys. Labeled ¥ (yen) on a Japanese keyboard. \ on a Russian keyboard.

a on a US keyboard. Labeled q on an AZERTY (e.g., French) keyboard.

q on a US keyboard. Labeled a on an AZERTY (e.g., French) keyboard.

w on a US keyboard. Labeled z on an AZERTY (e.g., French) keyboard.

y on a US keyboard. Labeled z on a QWERTZ (e.g., German) keyboard.

z on a US keyboard. Labeled w on an AZERTY (e.g., French) keyboard, and y on a QWERTZ (e.g., German) keyboard.

Alt, Option, or ⌥. This is labeled AltGr on many keyboard layouts.

Backspace or ⌫. Labeled Delete on Apple keyboards.

The application context menu key, which is typically found between the right Super key and the right Control key.

Enter or ↵. Labeled Return on Apple keyboards.

The Windows, ⌘, Command, or other OS symbol key.

The Windows, ⌘, Command, or other OS symbol key.

Japanese: カタカナ/ひらがな/ローマ字 (katakana/hiragana/romaji)

Korean: HangulMode 한/영 (han/yeong)

Japanese (Mac keyboard): か (kana)

Korean: Hanja 한 (hanja)

Japanese (Mac keyboard): 英 (eisu)

Japanese (word-processing keyboard): Katakana

Japanese (word-processing keyboard): Hiragana

Japanese (word-processing keyboard): Zenkaku/Hankaku

Japanese: 無変換 (muhenkan)

⌦. The forward delete key. Note that on Apple keyboards, the key labeled Delete on the main part of the keyboard is e

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(u32)]pub enum KeyCode {
Show 195 variants    Unidentified(NativeKeyCode),
    Backquote,
    Backslash,
    BracketLeft,
    BracketRight,
    Comma,
    Digit0,
    Digit1,
    Digit2,
    Digit3,
    Digit4,
    Digit5,
    Digit6,
    Digit7,
    Digit8,
    Digit9,
    Equal,
    IntlBackslash,
    IntlRo,
    IntlYen,
    KeyA,
    KeyB,
    KeyC,
    KeyD,
    KeyE,
    KeyF,
    KeyG,
    KeyH,
    KeyI,
    KeyJ,
    KeyK,
    KeyL,
    KeyM,
    KeyN,
    KeyO,
    KeyP,
    KeyQ,
    KeyR,
    KeyS,
    KeyT,
    KeyU,
    KeyV,
    KeyW,
    KeyX,
    KeyY,
    KeyZ,
    Minu
...
```

---

## Struct Virtual Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Virtual.html

**Contents:**
- Struct Virtual Copy item path
- Trait Implementations§
  - impl Clone for Virtual
    - fn clone(&self) -> Virtual
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Virtual
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Virtual
    - fn default() -> Virtual
  - impl FromArg for Virtual

The virtual game clock representing game time.

A specialization of the Time structure. For method documentation, see Time<Virtual>.

Normally used as Time<Virtual>. It is automatically inserted as a resource by TimePlugin and updated based on Time<Real>. The virtual clock is automatically set as the default generic Time resource for the update.

The virtual clock differs from real time clock in that it can be paused, sped up and slowed down. It also limits how much it can advance in a single update in order to prevent unexpected behavior in cases where updates do not happen at regular intervals (e.g. coming back after the program was suspended a long time).

The virtual clock can be paused by calling pause() and unpaused by calling unpause(). When the game clock is paused delta() will be zero on each update, and elapsed() will not grow. effective_speed() will return 0.0. Calling pause() will not affect value the delta() value for the update currently being processed.

The speed of the virtual clock can be changed by calling set_relative_speed(). A value of 2.0 means that virtual clock should advance twice as fast as real time, meaning that delta() values will be double of what Time<Real>::delta() reports and elapsed() will go twice as fast as Time<Real>::elapsed(). Calling set_relative_speed() will not affect the delta() value for the update currently being processed.

The maximum amount of delta time that can be added by a single update can be set by set_max_delta(). This value serves a dual purpose in the virtual clock.

If the game temporarily freezes due to any reason, such as disk access, a blocking system call, or operating system level suspend, reporting the full elapsed delta time is likely to cause bugs in game logic. Usually if a laptop is suspended for an hour, it doesn’t make sense to try to simulate the game logic for the elapsed hour when resuming. Instead it is better to lose the extra time and pretend a shorter duration of time passed. Setting max_delta() to a relatively short time means that the impact on game logic will be minimal.

If the game lags for some reason, meaning that it will take a longer time to compute a frame than the real time that passes during the computation, then we would fall behind in processing virtual time. If this situation persists, and computing a frame takes longer depending on how much virtual time has passed, the game would enter a “death spiral” where computing each frame takes longer and longer and the gam

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Virtual { /* private fields */ }
```

---

## Struct Camera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Camera.html

**Contents:**
- Struct Camera Copy item path
- Fields§
- Implementations§
  - impl Camera
    - pub fn to_logical(&self, physical_size: UVec2) -> Option<Vec2>
    - pub fn physical_viewport_rect(&self) -> Option<URect>
    - pub fn logical_viewport_rect(&self) -> Option<Rect>
    - pub fn logical_viewport_size(&self) -> Option<Vec2>
    - pub fn physical_viewport_size(&self) -> Option<UVec2>
    - pub fn logical_target_size(&self) -> Option<Vec2>

The defining Component for camera entities, storing information about how and what to render through this camera.

The Camera component is added to an entity to define the properties of the viewpoint from which rendering occurs. It defines the position of the view to render, the projection method to transform the 3D objects into a 2D image, as well as the render target into which that image is produced.

Note that a Camera needs a CameraRenderGraph to render anything. This is typically provided by adding a Camera2d or Camera3d component, but custom render graphs can also be defined. Inserting a Camera with no render graph will emit an error at runtime.

If set, this camera will render to the given Viewport rectangle within the configured RenderTarget.

Cameras with a higher order are rendered later, and thus on top of lower order cameras.

If this is set to true, this camera will be rendered to its specified RenderTarget. If false, this camera will not be rendered.

Computed values for this camera, such as the projection matrix and the render target size.

The “target” that this camera will render to.

The CameraOutputMode for this camera.

If this is enabled, a previous camera exists that shares this camera’s render target, and this camera has MSAA enabled, then the previous camera’s outputs will be written to the intermediate multi-sampled render target textures for this camera. This enables cameras with MSAA enabled to “write their results on top” of previous camera results, and include them as a part of their render results. This is enabled by default to ensure cameras with MSAA enabled layer their results in the same way as cameras without MSAA enabled by default.

The clear color operation to perform on the render target.

If set, this camera will be a sub camera of a large view, defined by a SubCameraView.

Converts a physical size in this Camera to a logical size.

The rendered physical bounds URect of the camera. If the viewport field is set to Some, this will be the rect of that custom viewport. Otherwise it will default to the full physical rect of the current RenderTarget.

The rendered logical bounds Rect of the camera. If the viewport field is set to Some, this will be the rect of that custom viewport. Otherwise it will default to the full logical rect of the current RenderTarget.

The logical size of this camera’s viewport. If the viewport field is set to Some, this will be the size of that custom viewport. Otherwise it will default to the f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Camera {
    pub viewport: Option<Viewport>,
    pub order: isize,
    pub is_active: bool,
    pub computed: ComputedCameraValues,
    pub target: RenderTarget,
    pub output_mode: CameraOutputMode,
    pub msaa_writeback: bool,
    pub clear_color: ClearColorConfig,
    pub sub_camera_view: Option<SubCameraView>,
}
```

Example 2 (javascript):
```javascript
22fn draw_cursor(
23    camera_query: Single<(&Camera, &GlobalTransform)>,
24    window: Single<&Window>,
25    mut gizmos: Gizmos,
26) {
27    let (camera, camera_transform) = *camera_query;
28
29    if let Some(cursor_position) = window.cursor_position()
30        // Calculate a world position based on the cursor's position.
31        && let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_position)
32        // To test Camera::world_to_viewport, convert result back to viewport space and then back to world space.
33        && let Ok(viewport_check) = camera.world_to_viewp
...
```

Example 3 (javascript):
```javascript
247fn example_control_system(
248    mut materials: ResMut<Assets<StandardMaterial>>,
249    controllable: Query<(&MeshMaterial3d<StandardMaterial>, &ExampleControls)>,
250    camera: Single<
251        (
252            Entity,
253            &mut Camera,
254            &mut Transform,
255            &GlobalTransform,
256            Has<Hdr>,
257        ),
258        With<Camera3d>,
259    >,
260    mut labels: Query<(&mut Node, &ExampleLabel)>,
261    mut display: Single<&mut Text, With<ExampleDisplay>>,
262    labeled: Query<&GlobalTransform>,
263    mut state: Local<ExampleState>,
264    ti
...
```

Example 4 (javascript):
```javascript
fn system(camera_query: Single<(&Camera, &GlobalTransform)>, window: Single<&Window>) {
    let (camera, camera_transform) = *camera_query;

    if let Some(cursor_position) = window.cursor_position()
        // Calculate a ray pointing from the camera into the world based on the cursor's position.
        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
    {
        println!("{ray:?}");
    }
}

// Run the system after transform propagation so the camera's global transform is up-to-date.
app.add_systems(PostUpdate, system.after(TransformSystems::Propagate));
```

---

## Trait UiMaterial Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.UiMaterial.html

**Contents:**
- Trait UiMaterial Copy item path
- §Example
- Provided Methods§
    - fn vertex_shader() -> ShaderRef
    - fn fragment_shader() -> ShaderRef
    - fn specialize( descriptor: &mut RenderPipelineDescriptor, key: UiMaterialKey<Self>, )
- Dyn Compatibility§
- Implementors§
  - impl UiMaterial for FrametimeGraphMaterial

Materials are used alongside UiMaterialPlugin and MaterialNode to spawn entities that are rendered with a specific UiMaterial type. They serve as an easy to use high level way to render Node entities with custom shader logic.

UiMaterials must implement AsBindGroup to define how data will be transferred to the GPU and bound in shaders. AsBindGroup can be derived, which makes generating bindings straightforward. See the AsBindGroup docs for details.

Materials must also implement Asset so they can be treated as such.

If you are only using the fragment shader, make sure your shader imports the UiVertexOutput from bevy_ui::ui_vertex_output and uses it as the input of your fragment shader like the example below does.

Here is a simple UiMaterial implementation. The AsBindGroup derive has many features. To see what else is available, check out the AsBindGroup documentation.

In WGSL shaders, the material’s binding would look like this:

If you only use the fragment shader make sure to import UiVertexOutput from bevy_ui::ui_vertex_output in your wgsl shader. Also note that bind group 0 is always bound to the View Uniform and the Globals Uniform.

Returns this materials vertex shader. If ShaderRef::Default is returned, the default UI vertex shader will be used.

Returns this materials fragment shader. If ShaderRef::Default is returned, the default UI fragment shader will be used.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait UiMaterial:
    Sized
    + AsBindGroup
    + Asset
    + Clone {
    // Provided methods
    fn vertex_shader() -> ShaderRef { ... }
    fn fragment_shader() -> ShaderRef { ... }
    fn specialize(
        descriptor: &mut RenderPipelineDescriptor,
        key: UiMaterialKey<Self>,
    ) { ... }
}
```

Example 2 (unknown):
```unknown
#[derive(AsBindGroup, Asset, TypePath, Debug, Clone)]
pub struct CustomMaterial {
    // Uniform bindings must implement `ShaderType`, which will be used to convert the value to
    // its shader-compatible equivalent. Most core math types already implement `ShaderType`.
    #[uniform(0)]
    color: LinearRgba,
    // Images can be bound as textures in shaders. If the Image's sampler is also needed, just
    // add the sampler attribute with a different binding index.
    #[texture(1)]
    #[sampler(2)]
    color_texture: Handle<Image>,
}

// All functions on `UiMaterial` have default impls. Y
...
```

Example 3 (wgsl):
```wgsl
#import bevy_ui::ui_vertex_output UiVertexOutput

struct CustomMaterial {
    color: vec4<f32>,
}

@group(1) @binding(0)
var<uniform> material: CustomMaterial;
@group(1) @binding(1)
var color_texture: texture_2d<f32>;
@group(1) @binding(2)
var color_sampler: sampler;

@fragment
fn fragment(in: UiVertexOutput) -> @location(0) vec4<f32> {

}
```

---

## Trait AnimationCurveEvaluator Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AnimationCurveEvaluator.html

**Contents:**
- Trait AnimationCurveEvaluator Copy item path
- Required Methods§
    - fn blend( &mut self, graph_node: NodeIndex, ) -> Result<(), AnimationEvaluationError>
    - fn add(&mut self, graph_node: NodeIndex) -> Result<(), AnimationEvaluationError>
    - fn push_blend_register( &mut self, weight: f32, graph_node: NodeIndex, ) -> Result<(), AnimationEvaluationError>
    - fn commit( &mut self, entity: EntityMutExcept<'_, '_, (AnimationTarget, AnimationPlayer, AnimationGraphHandle)>, ) -> Result<(), AnimationEvaluationError>
- Implementations§
  - impl dyn AnimationCurveEvaluator
    - pub fn is<__T>(&self) -> boolwhere __T: AnimationCurveEvaluator,
    - pub fn downcast<__T>( self: Box<dyn AnimationCurveEvaluator>, ) -> Result<Box<__T>, Box<dyn AnimationCurveEvaluator>>where __T: AnimationCurveEvaluator,

A low-level trait for use in VariableCurve that provides fine control over how animations are evaluated.

You can implement this trait when the generic AnimatableCurveEvaluator isn’t sufficiently-expressive for your needs. For example, MorphWeights implements this trait instead of using AnimatableCurveEvaluator because it needs to animate arbitrarily many weights at once, which can’t be done with Animatable as that works on fixed-size values only.

If you implement this trait, you should also implement AnimationCurve on your curve type, as that trait allows creating instances of this one.

Implementations of AnimatableCurveEvaluator should maintain a stack of (value, weight, node index) triples, as well as a blend register, which is either a (value, weight) pair or empty. Value here refers to an instance of the value being animated: for example, Vec3 in the case of translation keyframes. The stack stores intermediate values generated while evaluating the AnimationGraph, while the blend register stores the result of a blend operation.

Blends the top element of the stack with the blend register.

The semantics of this method are as follows:

Pop the top element of the stack. Call its value vₘ and its weight wₘ. If the stack was empty, return success.

If the blend register is empty, set the blend register value to vₘ and the blend register weight to wₘ; then, return success.

If the blend register is nonempty, call its current value vₙ and its current weight wₙ. Then, set the value of the blend register to interpolate(vₙ, vₘ, wₘ / (wₘ + wₙ)), and set the weight of the blend register to wₘ + wₙ.

Additively blends the top element of the stack with the blend register.

The semantics of this method are as follows:

Pop the top element of the stack. Call its value vₘ and its weight wₘ. If the stack was empty, return success.

If the blend register is empty, set the blend register value to vₘ and the blend register weight to wₘ; then, return success.

If the blend register is nonempty, call its current value vₙ. Then, set the value of the blend register to vₙ + vₘwₘ.

Pushes the current value of the blend register onto the stack.

If the blend register is empty, this method does nothing successfully. Otherwise, this method pushes the current value of the blend register onto the stack, alongside the weight and graph node supplied to this function. The weight present in the blend register is discarded; only the weight parameter to this function is pushed onto the 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait AnimationCurveEvaluator:
    Downcast
    + Send
    + Sync
    + 'static {
    // Required methods
    fn blend(
        &mut self,
        graph_node: NodeIndex,
    ) -> Result<(), AnimationEvaluationError>;
    fn add(
        &mut self,
        graph_node: NodeIndex,
    ) -> Result<(), AnimationEvaluationError>;
    fn push_blend_register(
        &mut self,
        weight: f32,
        graph_node: NodeIndex,
    ) -> Result<(), AnimationEvaluationError>;
    fn commit(
        &mut self,
        entity: EntityMutExcept<'_, '_, (AnimationTarget, AnimationPlayer, AnimationGraphH
...
```

---

## Macro embedded_asset Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/asset/macro.embedded_asset.html

**Contents:**
- Macro embedded_asset Copy item path

Creates a new embedded asset by embedding the bytes of the given path into the current binary and registering those bytes with the embedded AssetSource.

This accepts the current App as the first parameter and a path &str (relative to the current file) as the second.

By default this will generate an AssetPath using the following rules:

For example, consider the following file structure in the theoretical bevy_rock crate, which provides a Bevy Plugin that renders fancy rocks for scenes.

rock.wgsl is a WGSL shader asset that the bevy_rock plugin author wants to bundle with their crate. They invoke the following in bevy_rock/src/render/mod.rs:

embedded_asset!(app, "rock.wgsl")

rock.wgsl can now be loaded by the AssetServer as follows:

Some things to note in the path:

The default behavior also works for cargo workspaces. Pretend the bevy_rock crate now exists in a larger workspace in $SOME_WORKSPACE/crates/bevy_rock. The asset path would remain the same, because embedded_asset searches for the first instance of bevy_rock/src in the path.

For most “standard crate structures” the default works just fine. But for some niche cases (such as cargo examples), the src path will not be present. You can override this behavior by adding it as the second argument to embedded_asset:

embedded_asset!(app, "/examples/rock_stuff/", "rock.wgsl")

When there are three arguments, the second argument will replace the default /src/ value. Note that these two are equivalent:

embedded_asset!(app, "rock.wgsl") embedded_asset!(app, "/src/", "rock.wgsl")

This macro uses the include_bytes macro internally and will not reallocate the bytes. Generally the AssetPath generated will be predictable, but if your asset isn’t available for some reason, you can use the embedded_path macro to debug.

Hot-reloading embedded assets is supported. Just enable the embedded_watcher cargo feature.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! embedded_asset {
    ($app: expr, $path: expr) => { ... };
    ($app: expr, $source_path: expr, $path: expr) => { ... };
}
```

Example 2 (text):
```text
bevy_rock
├── src
│   ├── render
│   │   ├── rock.wgsl
│   │   └── mod.rs
│   └── lib.rs
└── Cargo.toml
```

Example 3 (javascript):
```javascript
// If we are loading the shader in the same module we used `embedded_asset!`:
let shader = load_embedded_asset!(&asset_server, "rock.wgsl");

// If the goal is to expose the asset **to the end user**:
let shader = asset_server.load::<Shader>("embedded://bevy_rock/render/rock.wgsl");
```

---

## Struct Mat4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mat4.html

**Contents:**
- Struct Mat4 Copy item path
- Fields§
- Implementations§
  - impl Mat4
    - pub const ZERO: Mat4
    - pub const IDENTITY: Mat4
    - pub const NAN: Mat4
    - pub const fn from_cols( x_axis: Vec4, y_axis: Vec4, z_axis: Vec4, w_axis: Vec4, ) -> Mat4
    - pub const fn from_cols_array(m: &[f32; 16]) -> Mat4
    - pub const fn to_cols_array(&self) -> [f32; 16]

A 4x4 column major matrix.

This 4x4 matrix type features convenience methods for creating and using affine transforms and perspective projections. If you are primarily dealing with 3D affine transformations considering using Affine3A which is faster than a 4x4 matrix for some affine operations.

Affine transformations including 3D translation, rotation and scale can be created using methods such as Self::from_translation(), Self::from_quat(), Self::from_scale() and Self::from_scale_rotation_translation().

Orthographic projections can be created using the methods Self::orthographic_lh() for left-handed coordinate systems and Self::orthographic_rh() for right-handed systems. The resulting matrix is also an affine transformation.

The Self::transform_point3() and Self::transform_vector3() convenience methods are provided for performing affine transformations on 3D vectors and points. These multiply 3D inputs as 4D vectors with an implicit w value of 1 for points and 0 for vectors respectively. These methods assume that Self contains a valid affine transform.

Perspective projections can be created using methods such as Self::perspective_lh(), Self::perspective_infinite_lh() and Self::perspective_infinite_reverse_lh() for left-handed co-ordinate systems and Self::perspective_rh(), Self::perspective_infinite_rh() and Self::perspective_infinite_reverse_rh() for right-handed co-ordinate systems.

The resulting perspective project can be use to transform 3D vectors as points with perspective correction using the Self::project_point3() convenience method.

A 4x4 matrix with all elements set to 0.0.

A 4x4 identity matrix, where all diagonal elements are 1, and all off-diagonal elements are 0.

Creates a 4x4 matrix from four column vectors.

Creates a 4x4 matrix from a [f32; 16] array stored in column major order. If your data is stored in row major you will need to transpose the returned matrix.

Creates a [f32; 16] array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 4x4 matrix from a [[f32; 4]; 4] 4D array stored in column major order. If your data is in row major order you will need to transpose the returned matrix.

Creates a [[f32; 4]; 4] 4D array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 4x4 matrix with its diagonal set to diagonal and all other entries set to 0.

Creates an affine transformation matrix from the given 3D

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct Mat4 {
    pub x_axis: Vec4,
    pub y_axis: Vec4,
    pub z_axis: Vec4,
    pub w_axis: Vec4,
}
```

Example 2 (unknown):
```unknown
59static VOXEL_FROM_WORLD: Mat4 = Mat4::from_cols_array_2d(&[
60    [-42.317566, 0.0, 0.0, 0.0],
61    [0.0, 0.0, 44.601563, 0.0],
62    [0.0, 16.73776, 0.0, 0.0],
63    [0.0, 6.544792, 0.0, 1.0],
64]);
```

Example 3 (javascript):
```javascript
92fn setup_meshes(
93    mut commands: Commands,
94    mut mesh_assets: ResMut<Assets<Mesh>>,
95    mut material_assets: ResMut<Assets<StandardMaterial>>,
96    mut inverse_bindposes_assets: ResMut<Assets<SkinnedMeshInverseBindposes>>,
97) {
98    // Create a mesh with two rectangles.
99    let unskinned_mesh = Mesh::new(
100        PrimitiveTopology::TriangleList,
101        RenderAssetUsages::default(),
102    )
103    .with_inserted_attribute(
104        Mesh::ATTRIBUTE_POSITION,
105        vec![
106            [-0.3, -0.3, 0.0],
107            [0.3, -0.3, 0.0],
108            [-0.3, 0.3, 0
...
```

Example 4 (javascript):
```javascript
37fn setup(
38    mut commands: Commands,
39    asset_server: Res<AssetServer>,
40    mut meshes: ResMut<Assets<Mesh>>,
41    mut materials: ResMut<Assets<StandardMaterial>>,
42    mut skinned_mesh_inverse_bindposes_assets: ResMut<Assets<SkinnedMeshInverseBindposes>>,
43) {
44    // Create a camera
45    commands.spawn((
46        Camera3d::default(),
47        Transform::from_xyz(2.5, 2.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
48    ));
49
50    // Create inverse bindpose matrices for a skeleton consists of 2 joints
51    let inverse_bindposes = skinned_mesh_inverse_bindposes_assets.add(vec![
...
```

---

## Struct RadialGradient Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RadialGradient.html

**Contents:**
- Struct RadialGradient Copy item path
- Fields§
- Implementations§
  - impl RadialGradient
    - pub fn new( position: UiPosition, shape: RadialGradientShape, stops: Vec<ColorStop>, ) -> RadialGradient
    - pub const fn in_color_space( self, color_space: InterpolationColorSpace, ) -> RadialGradient
- Trait Implementations§
  - impl Clone for RadialGradient
    - fn clone(&self) -> RadialGradient
    - fn clone_from(&mut self, source: &Self)

https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient

The color space used for interpolation.

The center of the radial gradient

Defines the end shape of the radial gradient

The list of color stops

Create a new radial gradient

Interpolate in the given color_space.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RadialGradient {
    pub color_space: InterpolationColorSpace,
    pub position: UiPosition,
    pub shape: RadialGradientShape,
    pub stops: Vec<ColorStop>,
}
```

---

## Struct Gamepad Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Gamepad.html

**Contents:**
- Struct Gamepad Copy item path
- §Examples
- Implementations§
  - impl Gamepad
    - pub fn vendor_id(&self) -> Option<u16>
    - pub fn product_id(&self) -> Option<u16>
    - pub fn get(&self, input: impl Into<GamepadInput>) -> Option<f32>
      - Examples found in repository?
    - pub fn get_unclamped(&self, input: impl Into<GamepadInput>) -> Option<f32>
    - pub fn left_stick(&self) -> Vec2

Stores a connected gamepad’s metadata such as the name and its GamepadButton and GamepadAxis.

An entity with this component is spawned automatically after GamepadConnectionEvent and updated by gamepad_event_processing_system.

See also GamepadSettings for configuration.

Returns the USB vendor ID as assigned by the USB-IF, if available.

Returns the USB product ID as assigned by the vendor, if available.

Returns the analog data of the provided GamepadAxis or GamepadButton.

This will be clamped between [Axis::MIN,Axis::MAX].

Returns the unclamped analog data of the provided GamepadAxis or GamepadButton.

This value may be outside the Axis::MIN and Axis::MAX range.

Returns the left stick as a Vec2.

Returns the right stick as a Vec2.

Returns the directional pad as a Vec2.

Returns true if the GamepadButton has been pressed.

Returns true if any item in the GamepadButton iterator has been pressed.

Returns true if all items in the GamepadButton iterator have been pressed.

Returns true if the GamepadButton has been pressed during the current frame.

Note: This function does not imply information regarding the current state of ButtonInput::pressed or ButtonInput::just_released.

Returns true if any item in the GamepadButton iterator has been pressed during the current frame.

Returns true if all items in the GamepadButton iterator have been just pressed.

Returns true if the GamepadButton has been released during the current frame.

Note: This function does not imply information regarding the current state of ButtonInput::pressed or ButtonInput::just_pressed.

Returns true if any item in the GamepadButton iterator has just been released.

Returns true if all items in the GamepadButton iterator have just been released.

Returns an iterator over all digital buttons that are pressed.

Returns an iterator over all digital buttons that were just pressed.

Returns an iterator over all digital buttons that were just released.

Returns an iterator over all analog axes.

ButtonInput of GamepadButton representing their digital state.

Mutable ButtonInput of GamepadButton representing their digital state. Useful for mocking inputs.

Axis of GamepadButton representing their analog state.

Mutable Axis of GamepadButton representing their analog state. Useful for mocking inputs.

Required Components: GamepadSettings.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required componen

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Gamepad { /* private fields */ }
```

Example 2 (javascript):
```javascript
fn gamepad_usage_system(gamepads: Query<(&Name, &Gamepad)>) {
    for (name, gamepad) in &gamepads {
        println!("{name}");

        if gamepad.just_pressed(GamepadButton::North) {
            println!("{} just pressed North", name)
        }

        if let Some(left_stick_x) = gamepad.get(GamepadAxis::LeftStickX)  {
            println!("left stick X: {}", left_stick_x)
        }
    }
}
```

Example 3 (javascript):
```javascript
12fn gamepad_system(gamepads: Query<(Entity, &Gamepad)>) {
13    for (entity, gamepad) in &gamepads {
14        if gamepad.just_pressed(GamepadButton::South) {
15            info!("{} just pressed South", entity);
16        } else if gamepad.just_released(GamepadButton::South) {
17            info!("{} just released South", entity);
18        }
19
20        let right_trigger = gamepad.get(GamepadButton::RightTrigger2).unwrap();
21        if right_trigger.abs() > 0.01 {
22            info!("{} RightTrigger2 value is {}", entity, right_trigger);
23        }
24
25        let left_stick_x = gamepa
...
```

Example 4 (javascript):
```javascript
12fn gamepad_system(gamepads: Query<(Entity, &Gamepad)>) {
13    for (entity, gamepad) in &gamepads {
14        if gamepad.just_pressed(GamepadButton::South) {
15            info!("{} just pressed South", entity);
16        } else if gamepad.just_released(GamepadButton::South) {
17            info!("{} just released South", entity);
18        }
19
20        let right_trigger = gamepad.get(GamepadButton::RightTrigger2).unwrap();
21        if right_trigger.abs() > 0.01 {
22            info!("{} RightTrigger2 value is {}", entity, right_trigger);
23        }
24
25        let left_stick_x = gamepa
...
```

---

## Enum LinearReparamError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.LinearReparamError.html

**Contents:**
- Enum LinearReparamError Copy item path
- Variants§
  - SourceCurveUnbounded
  - TargetIntervalUnbounded
- Trait Implementations§
  - impl Debug for LinearReparamError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for LinearReparamError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for LinearReparamError

An error indicating that a linear reparameterization couldn’t be performed because of malformed inputs.

The source curve that was to be reparametrized had unbounded domain.

The target interval for reparameterization was unbounded.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum LinearReparamError {
    SourceCurveUnbounded,
    TargetIntervalUnbounded,
}
```

---

## Struct State Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.State.html

**Contents:**
- Struct State Copy item path
- Implementations§
  - impl<S> State<S>where S: States,
    - pub fn new(state: S) -> State<S>
    - pub fn get(&self) -> &S
      - Examples found in repository?
- Trait Implementations§
  - impl<S> Debug for State<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Deref for State<S>where S: States,

A finite-state machine whose transitions have associated schedules (OnEnter(state) and OnExit(state)).

The current state value can be accessed through this resource. To change the state, queue a transition in the NextState<S> resource, and it will be applied during the StateTransition schedule - which by default runs after PreUpdate.

You can also manually trigger the StateTransition schedule to apply the changes at an arbitrary time.

The starting state is defined via the Default implementation for S.

Creates a new state with a specific value.

To change the state use NextState<S> rather than using this to modify the State<S>.

Get the current state.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct State<S>(/* private fields */)
where
    S: States;
```

Example 2 (javascript):
```javascript
use bevy_state::prelude::*;
use bevy_ecs::prelude::*;
use bevy_state_macros::States;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Default, States)]
enum GameState {
    #[default]
    MainMenu,
    SettingsMenu,
    InGame,
}

fn game_logic(game_state: Res<State<GameState>>) {
    match game_state.get() {
        GameState::InGame => {
            // Run game logic here...
        },
        _ => {},
    }
}
```

Example 3 (unknown):
```unknown
50fn switch_scene(
51    keyboard: Res<ButtonInput<KeyCode>>,
52    scene: Res<State<Scene>>,
53    mut next_scene: ResMut<NextState<Scene>>,
54) {
55    if keyboard.just_pressed(KeyCode::Space) {
56        info!("Switching scene");
57        next_scene.set(scene.get().next());
58    }
59}
```

Example 4 (unknown):
```unknown
61fn switch_scene(
62    keyboard: Res<ButtonInput<KeyCode>>,
63    scene: Res<State<Scene>>,
64    mut next_scene: ResMut<NextState<Scene>>,
65) {
66    if keyboard.just_pressed(KeyCode::Space) {
67        info!("Switching scene");
68        next_scene.set(scene.get().next());
69    }
70}
```

---

## Struct PreStartup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PreStartup.html

**Contents:**
- Struct PreStartup Copy item path
- Trait Implementations§
  - impl Clone for PreStartup
    - fn clone(&self) -> PreStartup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PreStartup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PreStartup
    - fn default() -> PreStartup
  - impl Hash for PreStartup

The schedule that runs before Startup.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PreStartup;
```

---

## Struct Outline Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Outline.html

**Contents:**
- Struct Outline Copy item path
- Fields§
- Implementations§
  - impl Outline
    - pub const fn new(width: Val, offset: Val, color: Color) -> Outline
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for Outline
    - fn clone(&self) -> Outline
    - fn clone_from(&mut self, source: &Self)

The Outline component adds an outline outside the edge of a UI node. Outlines do not take up space in the layout.

To add an Outline to a ui node you can spawn a (Node, Outline) tuple bundle:

Outline components can also be added later to existing UI nodes:

Inserting and removing an Outline component repeatedly will result in table moves, so it is generally preferable to set Outline::color to Color::NONE to hide an outline.

The width of the outline.

Percentage Val values are resolved based on the width of the outlined Node.

The amount of space between a node’s outline the edge of the node.

Percentage Val values are resolved based on the width of the outlined Node.

The color of the outline.

If you are frequently toggling outlines for a UI node on and off it is recommended to set Color::NONE to hide the outline. This avoids the table moves that would occur from the repeated insertion and removal of the Outline component.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Outline {
    pub width: Val,
    pub offset: Val,
    pub color: Color,
}
```

Example 2 (unknown):
```unknown
fn setup_ui(mut commands: Commands) {
    commands.spawn((
        Node {
            width: Val::Px(100.),
            height: Val::Px(100.),
            ..Default::default()
        },
        BackgroundColor(BLUE.into()),
        Outline::new(Val::Px(10.), Val::ZERO, RED.into())
    ));
}
```

Example 3 (javascript):
```javascript
fn outline_hovered_button_system(
    mut commands: Commands,
    mut node_query: Query<(Entity, &Interaction, Option<&mut Outline>), Changed<Interaction>>,
) {
    for (entity, interaction, mut maybe_outline) in node_query.iter_mut() {
        let outline_color =
            if matches!(*interaction, Interaction::Hovered) {
                Color::WHITE
            } else {
                Color::NONE
            };
        if let Some(mut outline) = maybe_outline {
            outline.color = outline_color;
        } else {
            commands.entity(entity).insert(Outline::new(Val::Px(10.),
...
```

Example 4 (javascript):
```javascript
18fn setup(
19    mut commands: Commands,
20    asset_server: Res<AssetServer>,
21    mut texture_atlases: ResMut<Assets<TextureAtlasLayout>>,
22) {
23    // Camera
24    commands.spawn(Camera2d);
25
26    let text_font = TextFont::default();
27
28    let texture_handle = asset_server.load("textures/rpg/chars/gabe/gabe-idle-run.png");
29    let texture_atlas = TextureAtlasLayout::from_grid(UVec2::splat(24), 7, 1, None, None);
30    let texture_atlas_handle = texture_atlases.add(texture_atlas);
31
32    // root node
33    commands
34        .spawn(Node {
35            width: percent(100),
36   
...
```

---

## Trait InColorSpace Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.InColorSpace.html

**Contents:**
- Trait InColorSpace Copy item path
- Required Methods§
    - fn in_color_space(self, color_space: InterpolationColorSpace) -> Self
- Provided Methods§
    - fn in_oklaba(self) -> Self
    - fn in_oklch(self) -> Self
    - fn in_oklch_long(self) -> Self
    - fn in_srgb(self) -> Self
    - fn in_linear_rgb(self) -> Self
- Dyn Compatibility§

Set the color space used for interpolation.

Interpolate in the given color_space.

Interpolate in OKLab space.

Interpolate in OKLCH space (short hue path).

Interpolate in OKLCH space (long hue path).

Interpolate in sRGB space.

Interpolate in linear sRGB space.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait InColorSpace: Sized {
    // Required method
    fn in_color_space(self, color_space: InterpolationColorSpace) -> Self;

    // Provided methods
    fn in_oklaba(self) -> Self { ... }
    fn in_oklch(self) -> Self { ... }
    fn in_oklch_long(self) -> Self { ... }
    fn in_srgb(self) -> Self { ... }
    fn in_linear_rgb(self) -> Self { ... }
}
```

---

## Enum GridPlacementError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GridPlacementError.html

**Contents:**
- Enum GridPlacementError Copy item path
- Variants§
  - InvalidZeroIndex
  - InvalidZeroSpan
- Trait Implementations§
  - impl Clone for GridPlacementError
    - fn clone(&self) -> GridPlacementError
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for GridPlacementError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

Errors that occur when setting constraints for a GridPlacement

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GridPlacementError {
    InvalidZeroIndex,
    InvalidZeroSpan,
}
```

---

## Type Alias ChildSpawner Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.ChildSpawner.html

**Contents:**
- Type Alias ChildSpawner Copy item path
- Aliased Type§

A type alias over RelatedSpawner used to spawn child entities containing a ChildOf relationship.

**Examples:**

Example 1 (unknown):
```unknown
pub type ChildSpawner<'w> = RelatedSpawner<'w, ChildOf>;
```

Example 2 (unknown):
```unknown
pub struct ChildSpawner<'w> { /* private fields */ }
```

---

## Struct Circle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Circle.html

**Contents:**
- Struct Circle Copy item path
- Fields§
- Implementations§
  - impl Circle
    - pub const fn new(radius: f32) -> Circle
      - Examples found in repository?
    - pub const fn diameter(&self) -> f32
    - pub fn closest_point(&self, point: Vec2) -> Vec2
- Trait Implementations§
  - impl Bounded2d for Circle

A circle primitive, representing the set of points some distance from the origin

The radius of the circle

Create a new Circle from a radius

Get the diameter of the circle

Finds the point on the circle that is closest to the given point.

If the point is outside the circle, the returned point will be on the perimeter of the circle. Otherwise, it will be inside the circle and returned as is.

Returns the default Circle with a radius of 0.5.

Get the area of the circle

Get the perimeter or circumference of the circle

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Circle {
    pub radius: f32,
}
```

Example 2 (unknown):
```unknown
31fn setup_scene(
32    mut commands: Commands,
33    mut meshes: ResMut<Assets<Mesh>>,
34    mut materials: ResMut<Assets<ColorMaterial>>,
35) {
36    // World where we move the player
37    commands.spawn((
38        Mesh2d(meshes.add(Rectangle::new(1000., 700.))),
39        MeshMaterial2d(materials.add(Color::srgb(0.2, 0.2, 0.3))),
40    ));
41
42    // Player
43    commands.spawn((
44        Player,
45        Mesh2d(meshes.add(Circle::new(25.))),
46        MeshMaterial2d(materials.add(Color::srgb(6.25, 9.4, 9.1))), // RGB values exceed 1 to achieve a bright color for the bloom effect
47   
...
```

Example 3 (unknown):
```unknown
13fn setup(
14    mut commands: Commands,
15    mut meshes: ResMut<Assets<Mesh>>,
16    mut materials: ResMut<Assets<StandardMaterial>>,
17) {
18    // circular base
19    commands.spawn((
20        Mesh3d(meshes.add(Circle::new(4.0))),
21        MeshMaterial3d(materials.add(Color::WHITE)),
22        Transform::from_rotation(Quat::from_rotation_x(-std::f32::consts::FRAC_PI_2)),
23    ));
24    // cube
25    commands.spawn((
26        Mesh3d(meshes.add(Cuboid::new(1.0, 1.0, 1.0))),
27        MeshMaterial3d(materials.add(Color::srgb_u8(124, 144, 255))),
28        Transform::from_xyz(0.0, 0.5, 0.
...
```

Example 4 (unknown):
```unknown
221fn setup_scene(
222    mut commands: Commands,
223    asset_server: Res<AssetServer>,
224    mut meshes: ResMut<Assets<Mesh>>,
225    mut materials: ResMut<Assets<StandardMaterial>>,
226) {
227    commands.spawn((
228        Camera3d::default(),
229        Transform::from_xyz(-10.0, 5.0, 13.0).looking_at(Vec3::new(0., 1., 0.), Vec3::Y),
230    ));
231
232    commands.spawn((
233        PointLight {
234            intensity: 10_000_000.0,
235            shadows_enabled: true,
236            ..default()
237        },
238        Transform::from_xyz(-4.0, 8.0, 13.0),
239    ));
240
241    comma
...
```

---

## Enum BoxSizing Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.BoxSizing.html

**Contents:**
- Enum BoxSizing Copy item path
- Variants§
  - BorderBox
  - ContentBox
- Implementations§
  - impl BoxSizing
    - pub const DEFAULT: BoxSizing = Self::BorderBox
- Trait Implementations§
  - impl Clone for BoxSizing
    - fn clone(&self) -> BoxSizing

Which part of a Node’s box length styles like width and height control

See: https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing

Length styles like width and height refer to the “border box” size (size including padding and border)

Length styles like width and height refer to the “content box” size (size excluding padding and border)

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum BoxSizing {
    BorderBox,
    ContentBox,
}
```

---

## Function propagate_output Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/fn.propagate_output.html

**Contents:**
- Function propagate_output Copy item path

add C to entities with Inherited::<C>

**Examples:**

Example 1 (unknown):
```unknown
pub fn propagate_output<C, F>(
    commands: Commands<'_, '_>,
    changed: Query<'_, '_, (Entity, &Inherited<C>, Option<&C>), (Changed<Inherited<C>>, Without<PropagateOver<C>>, F)>,
)where
    C: Component + Clone + PartialEq,
    F: QueryFilter,
```

---

## Struct TextSpan Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextSpan.html

**Contents:**
- Struct TextSpan Copy item path
- Tuple Fields§
- Implementations§
  - impl TextSpan
    - pub fn new(text: impl Into<String>) -> TextSpan
      - Examples found in repository?
- Methods from Deref<Target = String>§
    - pub fn as_str(&self) -> &str
      - §Examples
    - pub fn as_mut_str(&mut self) -> &mut str

A span of text in a tree of spans.

A TextSpan is only valid when it exists as a child of a parent that has either Text or Text2d. The parent’s Text / Text2d component contains the base text content. Any children with TextSpan extend this text by appending their content to the parent’s text in sequence to form a ComputedTextBlock. The parent’s TextLayout determines the layout of the block but each node has its own TextFont and TextColor.

Makes a new text span component.

Extracts a string slice containing the entire String.

Converts a String into a mutable string slice.

Appends a given string slice onto the end of this String.

Copies elements from src range to the end of the string.

Panics if the range has start_bound > end_bound, or, if the range is bounded on either end and does not lie on a char boundary.

Returns this String’s capacity, in bytes.

Reserves capacity for at least additional bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient.

Panics if the new capacity overflows usize.

This might not actually increase the capacity:

Reserves the minimum capacity for at least additional bytes more than the current length. Unlike reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling reserve_exact, capacity will be greater than or equal to self.len() + additional. Does nothing if the capacity is already sufficient.

Panics if the new capacity overflows usize.

This might not actually increase the capacity:

Tries to reserve capacity for at least additional bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling try_reserve, capacity will be greater than or equal to self.len() + additional if it returns Ok(()). Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.

If the capacity overflows, or the allocator reports a failure, then an error is returned.

Tries to reserve the minimum capacity for at least additional bytes more than the current length. Unlike try_reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling try_reserve_exact, capacity will be greater than or equal to self.len() + additional if it returns Ok(()

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextSpan(pub String);
```

Example 2 (unknown):
```unknown
237fn setup_ui(mut commands: Commands) {
238    commands.spawn((
239        Text::default(),
240        Node {
241            position_type: PositionType::Absolute,
242            top: px(12),
243            left: px(12),
244            ..default()
245        },
246        children![
247            TextSpan::default(),
248            TextSpan::default(),
249            TextSpan::new("1/2: -/+ shutter angle (blur amount)\n"),
250            TextSpan::new("3/4: -/+ sample count (blur quality)\n"),
251            TextSpan::new("Spacebar: cycle camera\n"),
252        ],
253    ));
254}
```

Example 3 (unknown):
```unknown
92fn setup_ui(mut commands: Commands) {
93    commands.spawn(Camera2d);
94    commands.spawn((
95        Text::default(),
96        TextLayout::new_with_justify(Justify::Center),
97        Node {
98            align_self: AlignSelf::Center,
99            justify_self: JustifySelf::Center,
100            ..default()
101        },
102        children![
103            (TextSpan::new("Press A or B to trigger a one-shot system\n")),
104            (TextSpan::new("Last Triggered: ")),
105            (
106                TextSpan::new("-"),
107                TextColor(bevy::color::palettes::css::ORA
...
```

Example 4 (javascript):
```javascript
144fn print_logs(
145    mut log_message_reader: MessageReader<LogMessage>,
146    mut commands: Commands,
147    log_viewer_root: Single<Entity, With<LogViewerRoot>>,
148) {
149    let root_entity = *log_viewer_root;
150
151    commands.entity(root_entity).with_children(|child| {
152        for log_message in log_message_reader.read() {
153            child.spawn((
154                Text::default(),
155                children![
156                    (
157                        TextSpan::new(format!("{:5} ", log_message.level)),
158                        TextColor(level_color(&log_message
...
```

---

## Struct ClearColor Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ClearColor.html

**Contents:**
- Struct ClearColor Copy item path
- Tuple Fields§
- Methods from Deref<Target = Color>§
    - pub const WHITE: Color
    - pub const BLACK: Color
    - pub const NONE: Color
    - pub fn to_linear(&self) -> LinearRgba
      - Examples found in repository?
    - pub fn to_srgba(&self) -> Srgba
      - Examples found in repository?

A Resource that stores the default color that cameras use to clear the screen between frames.

This color appears as the “background” color for simple apps, when there are portions of the screen with nothing rendered.

Individual cameras may use Camera.clear_color to specify a different clear color or opt out of clearing their viewport.

Return the color as a linear RGBA color.

Return the color as an SRGBA color.

Match the dark gray bevy website code block color by default.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ClearColor(pub Color);
```

Example 2 (javascript):
```javascript
90fn animate(
91    mut materials: ResMut<Assets<CustomUiMaterial>>,
92    q: Query<&MaterialNode<CustomUiMaterial>>,
93    time: Res<Time>,
94) {
95    let duration = 2.0;
96    for handle in &q {
97        if let Some(material) = materials.get_mut(handle) {
98            // rainbow color effect
99            let new_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 1., 0.5);
100            let border_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 0.75, 0.75);
101            material.color = new_color.to_linear().to_vec4();
102            material.slider.x =
103              
...
```

Example 3 (unknown):
```unknown
228fn spawn_light_textures(
229    commands: &mut Commands,
230    asset_server: &AssetServer,
231    meshes: &mut Assets<Mesh>,
232    materials: &mut Assets<StandardMaterial>,
233) {
234    commands.spawn((
235        SpotLight {
236            color: Color::srgb(1.0, 1.0, 0.8),
237            intensity: 10e6,
238            outer_angle: 0.25,
239            inner_angle: 0.25,
240            shadows_enabled: true,
241            ..default()
242        },
243        Transform::from_translation(Vec3::new(6.0, 1.0, 2.0)).looking_at(Vec3::ZERO, Vec3::Y),
244        SpotLightTexture {
245        
...
```

Example 4 (unknown):
```unknown
104fn update_colors(
105    keyboard_input: Res<ButtonInput<KeyCode>>,
106    mut config: ResMut<Wireframe2dConfig>,
107    mut wireframe_colors: Query<&mut Wireframe2dColor>,
108    mut text: Single<&mut Text>,
109) {
110    text.0 = format!(
111        "Controls
112---------------
113Z - Toggle global
114X - Change global color
115C - Change color of the circle wireframe
116
117Wireframe2dConfig
118-------------
119Global: {}
120Color: {:?}",
121        config.global,
122        config.default_color.to_srgba(),
123    );
124
125    // Toggle showing a wireframe on all meshes
126    if keyboa
...
```

---

## Enum EvaluatorId Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.EvaluatorId.html

**Contents:**
- Enum EvaluatorId Copy item path
- Variants§
  - ComponentField(&'a Hashed<(TypeId, usize)>)
  - Type(TypeId)
- Trait Implementations§
  - impl<'a> Clone for EvaluatorId<'a>
    - fn clone(&self) -> EvaluatorId<'a>
    - fn clone_from(&mut self, source: &Self)
- Auto Trait Implementations§
  - impl<'a> Freeze for EvaluatorId<'a>

The EvaluatorId is used to look up the AnimationCurveEvaluator for an AnimatableProperty. For a given animated property, this ID should always be the same to allow things like animation blending to occur.

Corresponds to a specific field on a specific component type. The TypeId should correspond to the component type, and the usize should correspond to the Reflect-ed field index of the field.

Corresponds to a custom property of a given type. This should be the TypeId of the custom AnimatableProperty.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum EvaluatorId<'a> {
    ComponentField(&'a Hashed<(TypeId, usize)>),
    Type(TypeId),
}
```

---

## Struct DynamicTextureAtlasBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DynamicTextureAtlasBuilder.html

**Contents:**
- Struct DynamicTextureAtlasBuilder Copy item path
- Implementations§
  - impl DynamicTextureAtlasBuilder
    - pub fn new(size: UVec2, padding: u32) -> DynamicTextureAtlasBuilder
      - §Arguments
    - pub fn add_texture( &mut self, atlas_layout: &mut TextureAtlasLayout, texture: &Image, atlas_texture: &mut Image, ) -> Result<usize, DynamicTextureAtlasBuilderError>
      - §Arguments
- Auto Trait Implementations§
  - impl Freeze for DynamicTextureAtlasBuilder
  - impl RefUnwindSafe for DynamicTextureAtlasBuilder

Helper utility to update TextureAtlasLayout on the fly.

Helpful in cases when texture is created procedurally, e.g: in a font glyph TextureAtlasLayout, only add the Image texture for letters to be rendered.

Create a new DynamicTextureAtlasBuilder

Add a new texture to atlas_layout.

It is the user’s responsibility to pass in the correct TextureAtlasLayout. Also, the asset that atlas_texture_handle points to must have a usage matching RenderAssetUsages::MAIN_WORLD.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DynamicTextureAtlasBuilder { /* private fields */ }
```

---

## Struct ExitSchedules Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ExitSchedules.html

**Contents:**
- Struct ExitSchedules Copy item path
- Trait Implementations§
  - impl<S> Clone for ExitSchedules<S>where S: Clone + States,
    - fn clone(&self) -> ExitSchedules<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for ExitSchedules<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Default for ExitSchedules<S>where S: States,
    - fn default() -> ExitSchedules<S>
  - impl<S> Hash for ExitSchedules<S>where S: Hash + States,

System set that runs exit schedule(s) for state S.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ExitSchedules<S>(/* private fields */)
where
    S: States;
```

---

## Struct Last Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Last.html

**Contents:**
- Struct Last Copy item path
- Trait Implementations§
  - impl Clone for Last
    - fn clone(&self) -> Last
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Last
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Last
    - fn default() -> Last
  - impl Hash for Last

Runs last in the schedule.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Last;
```

---

## Struct UiMaterialPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiMaterialPlugin.html

**Contents:**
- Struct UiMaterialPlugin Copy item path
- Trait Implementations§
  - impl<M> Default for UiMaterialPlugin<M>where M: UiMaterial,
    - fn default() -> UiMaterialPlugin<M>
  - impl<M> Plugin for UiMaterialPlugin<M>where M: UiMaterial, <M as AsBindGroup>::Data: PartialEq + Eq + Hash + Clone,
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

Adds the necessary ECS resources and render logic to enable rendering entities using the given UiMaterial asset type (which includes UiMaterial types).

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiMaterialPlugin<M>(/* private fields */)
where
    M: UiMaterial;
```

---

## Enum NextState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.NextState.html

**Contents:**
- Enum NextState Copy item path
- Variants§
  - Unchanged
  - Pending(S)
- Implementations§
  - impl<S> NextState<S>where S: FreelyMutableState,
    - pub fn set(&mut self, state: S)
      - Examples found in repository?
    - pub fn reset(&mut self)
- Trait Implementations§

The next state of State<S>.

This can be fetched as a resource and used to queue state transitions. To queue a transition, call NextState::set or mutate the value to NextState::Pending directly.

Note that these transitions can be overridden by other systems: only the actual value of this resource during the StateTransition schedule matters.

No state transition is pending

There is a pending transition for state S

Tentatively set a pending state transition to Some(state).

Remove any pending changes to State<S>

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum NextState<S>where
    S: FreelyMutableState,{
    Unchanged,
    Pending(S),
}
```

Example 2 (unknown):
```unknown
use bevy_state::prelude::*;
use bevy_ecs::prelude::*;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Default, States)]
enum GameState {
    #[default]
    MainMenu,
    SettingsMenu,
    InGame,
}

fn start_game(mut next_game_state: ResMut<NextState<GameState>>) {
    next_game_state.set(GameState::InGame);
}
```

Example 3 (unknown):
```unknown
74fn transition_to_in_game_system(
75    mut next_state: ResMut<NextState<AppState>>,
76    keyboard_input: Res<ButtonInput<KeyCode>>,
77) {
78    if keyboard_input.pressed(KeyCode::Space) {
79        next_state.set(AppState::InGame);
80    }
81}
```

Example 4 (javascript):
```javascript
98    fn countdown(
99        mut game_state: ResMut<NextState<GameState>>,
100        time: Res<Time>,
101        mut timer: ResMut<SplashTimer>,
102    ) {
103        if timer.tick(time.delta()).is_finished() {
104            game_state.set(GameState::Menu);
105        }
106    }
107}
108
109mod game {
110    use bevy::{
111        color::palettes::basic::{BLUE, LIME},
112        prelude::*,
113    };
114
115    use super::{DisplayQuality, GameState, Volume, TEXT_COLOR};
116
117    // This plugin will contain the game. In this case, it's just be a screen that will
118    // display the curre
...
```

---

## Function resource_changed_or_removed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_changed_or_removed.html

**Contents:**
- Function resource_changed_or_removed Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the resource of the given type has been added, removed or mutably dereferenced since the condition was last checked.

Note that simply mutably dereferencing a resource is considered a change (DerefMut). Bevy does not compare resources to their previous values.

The condition will return false if the resource does not exist.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_changed_or_removed<T>(
    res: Option<Res<'_, T>>,
    existed: Local<'_, bool>,
) -> boolwhere
    T: Resource,
```

Example 2 (javascript):
```javascript
app.add_systems(
    // `resource_changed_or_removed` will only return true if the
    // given resource was just changed or removed (or added)
    my_system.run_if(
        resource_changed_or_removed::<Counter>
        // By default detecting changes will also trigger if the resource was
        // just added, this won't work with my example so I will add a second
        // condition to make sure the resource wasn't just added
        .and(not(resource_added::<Counter>))
    ),
);

#[derive(Resource, Default)]
struct MyResource;

// If `Counter` exists, increment it, otherwise insert `MyRes
...
```

---

## Enum MonitorSelection Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.MonitorSelection.html

**Contents:**
- Enum MonitorSelection Copy item path
- Variants§
  - Current
  - Primary
  - Index(usize)
  - Entity(Entity)
- Trait Implementations§
  - impl Clone for MonitorSelection
    - fn clone(&self) -> MonitorSelection
    - fn clone_from(&mut self, source: &Self)

References a screen monitor.

Used when centering a Window on a monitor.

Uses the current monitor of the window.

If WindowPosition::Centered(MonitorSelection::Current) is used when creating a window, the window doesn’t have a monitor yet, this will fall back to WindowPosition::Automatic.

Uses the primary monitor of the system.

Uses the monitor with the specified index.

Uses a given crate::monitor::Monitor entity.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum MonitorSelection {
    Current,
    Primary,
    Index(usize),
    Entity(Entity),
}
```

---

## Struct SmootherStepOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SmootherStepOutCurve.html

**Contents:**
- Struct SmootherStepOutCurve Copy item path
- Trait Implementations§
  - impl Clone for SmootherStepOutCurve
    - fn clone(&self) -> SmootherStepOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SmootherStepOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as the second half of SmootherStepCurve.

This has f″(0) = 0, unlike CubicOutCurve which ends similarly.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SmootherStepOutCurve;
```

---

## Enum Val Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Val.html

**Contents:**
- Enum Val Copy item path
- Variants§
  - Auto
  - Px(f32)
  - Percent(f32)
  - Vw(f32)
  - Vh(f32)
  - VMin(f32)
  - VMax(f32)
- Implementations§

Represents the possible value types for layout properties.

This enum allows specifying values for various Node properties in different units, such as logical pixels, percentages, or automatically determined values.

Val also implements core::str::FromStr to allow parsing values from strings in the format #.#px. Whitespaces between the value and unit is allowed. The following units are supported:

Additionally, auto will be parsed as Val::Auto.

Automatically determine the value based on the context and other Node properties.

Set this value in logical pixels.

Set the value as a percentage of its parent node’s length along a specific axis.

If the UI node has no parent, the percentage is calculated based on the window’s length along the corresponding axis.

The chosen axis depends on the Node field set:

Set this value in percent of the viewport width

Set this value in percent of the viewport height

Set this value in percent of the viewport’s smaller dimension.

Set this value in percent of the viewport’s larger dimension.

Returns a UiRect with its left equal to this value, and all other fields set to Val::ZERO.

Returns a UiRect with its right equal to this value, and all other fields set to Val::ZERO.

Returns a UiRect with its top equal to this value, and all other fields set to Val::ZERO.

Returns a UiRect with its bottom equal to this value, and all other fields set to Val::ZERO.

Returns a UiRect with all its fields equal to this value.

Returns a UiRect with all its left and right equal to this value, and its top and bottom set to Val::ZERO.

Returns a UiRect with all its top and bottom equal to this value, and its left and right set to Val::ZERO.

Resolves this Val to a value in physical pixels from the given scale_factor, physical_base_value, and physical_target_size context values.

Returns a ValArithmeticError::NonEvaluable if the Val is impossible to resolve into a concrete value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Val {
    Auto,
    Px(f32),
    Percent(f32),
    Vw(f32),
    Vh(f32),
    VMin(f32),
    VMax(f32),
}
```

Example 2 (javascript):
```javascript
let ui_rect = Val::Px(1.).left();

assert_eq!(ui_rect.left, Val::Px(1.));
assert_eq!(ui_rect.right, Val::ZERO);
assert_eq!(ui_rect.top, Val::ZERO);
assert_eq!(ui_rect.bottom, Val::ZERO);
```

Example 3 (javascript):
```javascript
let ui_rect = Val::Px(1.).right();

assert_eq!(ui_rect.left, Val::ZERO);
assert_eq!(ui_rect.right, Val::Px(1.));
assert_eq!(ui_rect.top, Val::ZERO);
assert_eq!(ui_rect.bottom, Val::ZERO);
```

Example 4 (javascript):
```javascript
let ui_rect = Val::Px(1.).top();

assert_eq!(ui_rect.left, Val::ZERO);
assert_eq!(ui_rect.right, Val::ZERO);
assert_eq!(ui_rect.top, Val::Px(1.));
assert_eq!(ui_rect.bottom, Val::ZERO);
```

---

## Struct PerspectiveProjection Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PerspectiveProjection.html

**Contents:**
- Struct PerspectiveProjection Copy item path
- Fields§
- Trait Implementations§
  - impl CameraProjection for PerspectiveProjection
    - fn get_clip_from_view(&self) -> Mat4
    - fn get_clip_from_view_for_sub(&self, sub_view: &SubCameraView) -> Mat4
    - fn update(&mut self, width: f32, height: f32)
    - fn far(&self) -> f32
    - fn get_frustum_corners(&self, z_near: f32, z_far: f32) -> [Vec3A; 8]
    - fn compute_frustum(&self, camera_transform: &GlobalTransform) -> Frustum

A 3D camera projection in which distant objects appear smaller than close objects.

The vertical field of view (FOV) in radians.

Defaults to a value of π/4 radians or 45 degrees.

The aspect ratio (width divided by height) of the viewing frustum.

Bevy’s camera_system automatically updates this value when the aspect ratio of the associated window changes.

Defaults to a value of 1.0.

The distance from the camera in world units of the viewing frustum’s near plane.

Objects closer to the camera than this value will not be visible.

Defaults to a value of 0.1.

The distance from the camera in world units of the viewing frustum’s far plane.

Objects farther from the camera than this value will not be visible.

Defaults to a value of 1000.0.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PerspectiveProjection {
    pub fov: f32,
    pub aspect_ratio: f32,
    pub near: f32,
    pub far: f32,
}
```

---

## Type Alias StateScoped Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.StateScoped.html

**Contents:**
- Type Alias StateScoped Copy item path
- Aliased Type§
- Tuple Fields§

A deprecated alias for DespawnOnExit.

**Examples:**

Example 1 (unknown):
```unknown
pub type StateScoped<S> = DespawnOnExit<S>;
```

Example 2 (unknown):
```unknown
pub struct StateScoped<S>(pub S);
```

---

## Struct AabbGizmoConfigGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AabbGizmoConfigGroup.html

**Contents:**
- Struct AabbGizmoConfigGroup Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for AabbGizmoConfigGroup
    - fn clone(&self) -> AabbGizmoConfigGroup
    - fn clone_from(&mut self, source: &Self)
  - impl Default for AabbGizmoConfigGroup
    - fn default() -> AabbGizmoConfigGroup
  - impl FromArg for AabbGizmoConfigGroup
    - type This<'from_arg> = AabbGizmoConfigGroup

The GizmoConfigGroup used for debug visualizations of Aabb components on entities

Draws all bounding boxes in the scene when set to true.

To draw a specific entity’s bounding box, you can add the ShowAabbGizmo component.

The default color for bounding box gizmos.

A random color is chosen per box if None.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AabbGizmoConfigGroup {
    pub draw_all: bool,
    pub default_color: Option<Color>,
}
```

---

## Function interpolate_with_cubic_bezier Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.interpolate_with_cubic_bezier.html

**Contents:**
- Function interpolate_with_cubic_bezier Copy item path

Evaluates a cubic Bézier curve at a value t, given two endpoints and the derivatives at those endpoints.

The derivatives are linearly scaled by duration.

**Examples:**

Example 1 (unknown):
```unknown
pub fn interpolate_with_cubic_bezier<T>(
    p0: &T,
    d0: &T,
    d3: &T,
    p3: &T,
    t: f32,
    duration: f32,
) -> Twhere
    T: Animatable + Clone,
```

---

## Enum ReverseError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ReverseError.html

**Contents:**
- Enum ReverseError Copy item path
- Variants§
  - SourceDomainEndInfinite
- Trait Implementations§
  - impl Debug for ReverseError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for ReverseError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for ReverseError
    - fn source(&self) -> Option<&(dyn Error + 'static)>

An error indicating that a reversion of a curve couldn’t be performed because of malformed inputs.

The source curve that was to be reversed had unbounded domain end.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ReverseError {
    SourceDomainEndInfinite,
}
```

---

## Struct BounceOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BounceOutCurve.html

**Contents:**
- Struct BounceOutCurve Copy item path
- Trait Implementations§
  - impl Clone for BounceOutCurve
    - fn clone(&self) -> BounceOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for BounceOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BounceOutCurve;
```

---

## Type Alias OnRemove Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.OnRemove.html

**Contents:**
- Type Alias OnRemove Copy item path
- Aliased Type§
- Fields§

Deprecated in favor of Remove.

The entity this component was removed from.

**Examples:**

Example 1 (unknown):
```unknown
pub type OnRemove = Remove;
```

Example 2 (unknown):
```unknown
pub struct OnRemove {
    pub entity: Entity,
}
```

---

## Struct Entity Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Entity.html

**Contents:**
- Struct Entity Copy item path
- §Aliasing
- §Stability warning
- §Usage
- Implementations§
  - impl Entity
    - pub const PLACEHOLDER: Entity
        - §Examples
    - pub const fn from_row_and_generation( row: EntityRow, generation: EntityGeneration, ) -> Entity
    - pub const fn from_row(row: EntityRow) -> Entity

Lightweight identifier of an entity.

The identifier is implemented using a generational index: a combination of an index (EntityRow) and a generation (EntityGeneration). This allows fast insertion after data removal in an array while minimizing loss of spatial locality.

These identifiers are only valid on the World it’s sourced from. Attempting to use an Entity to fetch entity components or metadata from a different world will either fail or return unexpected results.

Once an entity is despawned, it ceases to exist. However, its Entity id is still present, and may still be contained in some data. This becomes problematic because it is possible for a later entity to be spawned at the exact same id! If this happens, which is rare but very possible, it will be logged.

Aliasing can happen without warning. Holding onto a Entity id corresponding to an entity well after that entity was despawned can cause un-intuitive behavior for both ordering, and comparing in general. To prevent these bugs, it is generally best practice to stop holding an Entity or EntityGeneration value as soon as you know it has been despawned. If you must do otherwise, do not assume the Entity corresponds to the same conceptual entity it originally did. See EntityGeneration’s docs for more information about aliasing and why it occurs.

For all intents and purposes, Entity should be treated as an opaque identifier. The internal bit representation is liable to change from release to release as are the behaviors or performance characteristics of any of its trait implementations (i.e. Ord, Hash, etc.). This means that changes in Entity’s representation, though made readable through various functions on the type, are not considered breaking changes under SemVer.

In particular, directly serializing with Serialize and Deserialize make zero guarantee of long term wire format compatibility. Changes in behavior will cause serialized Entity values persisted to long term storage (i.e. disk, databases, etc.) will fail to deserialize upon being updated.

This data type is returned by iterating a Query that has Entity as part of its query fetch type parameter (learn more). It can also be obtained by calling EntityCommands::id or EntityWorldMut::id.

It can be used to refer to a specific entity to apply EntityCommands, or to call Query::get (or similar methods) to access its components.

An entity ID with a placeholder value. This may or may not correspond to an actual entity, and should be overwritte

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Entity { /* private fields */ }
```

Example 2 (javascript):
```javascript
fn setup(mut commands: Commands) {
    // Calling `spawn` returns `EntityCommands`.
    let entity = commands.spawn(SomeComponent).id();
}

fn exclusive_system(world: &mut World) {
    // Calling `spawn` returns `EntityWorldMut`.
    let entity = world.spawn(SomeComponent).id();
}
```

Example 3 (unknown):
```unknown
fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {
    for food_entity in &query {
        commands.entity(food_entity).despawn();
    }
}
```

Example 4 (javascript):
```javascript
// Create a new array of size 10 filled with invalid entity ids.
let mut entities: [Entity; 10] = [Entity::PLACEHOLDER; 10];

// ... replace the entities with valid ones.
```

---

## Struct SmoothStepOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SmoothStepOutCurve.html

**Contents:**
- Struct SmoothStepOutCurve Copy item path
- Trait Implementations§
  - impl Clone for SmoothStepOutCurve
    - fn clone(&self) -> SmoothStepOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SmoothStepOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as the second half of SmoothStepCurve.

This has f″(0) = 0, unlike QuadraticOutCurve which ends similarly.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SmoothStepOutCurve;
```

---

## Struct ZIndex Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ZIndex.html

**Contents:**
- Struct ZIndex Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for ZIndex
    - fn clone(&self) -> ZIndex
    - fn clone_from(&mut self, source: &Self)
  - impl Component for ZIndexwhere ZIndex: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Indicates that this Node entity’s front-to-back ordering is not controlled solely by its location in the UI hierarchy. A node with a higher z-index will appear on top of sibling nodes with a lower z-index.

UI nodes that have the same z-index will appear according to the order in which they appear in the UI hierarchy. In such a case, the last node to be added to its parent will appear in front of its siblings.

Nodes without this component will be treated as if they had a value of ZIndex(0).

Use GlobalZIndex if you need to order separate UI hierarchies or nodes that are not siblings in a given UI hierarchy.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ZIndex(pub i32);
```

---

## Struct ConicGradient Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ConicGradient.html

**Contents:**
- Struct ConicGradient Copy item path
- Fields§
- Implementations§
  - impl ConicGradient
    - pub fn new(position: UiPosition, stops: Vec<AngularColorStop>) -> ConicGradient
    - pub const fn with_start(self, start: f32) -> ConicGradient
    - pub const fn with_position(self, position: UiPosition) -> ConicGradient
    - pub const fn in_color_space( self, color_space: InterpolationColorSpace, ) -> ConicGradient
- Trait Implementations§
  - impl Clone for ConicGradient

https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient

The color space used for interpolation.

The starting angle of the gradient in radians

The center of the conic gradient

The list of color stops

Create a new conic gradient

Sets the starting angle of the gradient in radians

Sets the position of the gradient

Interpolate in the given color_space.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ConicGradient {
    pub color_space: InterpolationColorSpace,
    pub start: f32,
    pub position: UiPosition,
    pub stops: Vec<AngularColorStop>,
}
```

---

## Trait SpawnRelated Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SpawnRelated.html

**Contents:**
- Trait SpawnRelated Copy item path
- Required Methods§
    - fn spawn<L>(list: L) -> SpawnRelatedBundle<Self::Relationship, L>where L: SpawnableList<Self::Relationship>,
    - fn spawn_one<B>(bundle: B) -> SpawnOneRelated<Self::Relationship, B>where B: Bundle,
- Dyn Compatibility§
- Implementors§
  - impl<T> SpawnRelated for Twhere T: RelationshipTarget,

RelationshipTarget methods that create a Bundle with a DynamicBundle::Effect that:

Returns a Bundle containing this RelationshipTarget component. It also spawns a SpawnableList of entities, each related to the bundle’s entity via RelationshipTarget::Relationship. The RelationshipTarget (when possible) will pre-allocate space for the related entities.

See Spawn, SpawnIter, SpawnWith, WithRelated and WithOneRelated for usage examples.

Returns a Bundle containing this RelationshipTarget component. It also spawns a single entity containing Bundle that is related to the bundle’s entity via RelationshipTarget::Relationship.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait SpawnRelated: RelationshipTarget {
    // Required methods
    fn spawn<L>(list: L) -> SpawnRelatedBundle<Self::Relationship, L>
       where L: SpawnableList<Self::Relationship>;
    fn spawn_one<B>(bundle: B) -> SpawnOneRelated<Self::Relationship, B>
       where B: Bundle;
}
```

Example 2 (javascript):
```javascript
let mut world = World::new();
world.spawn((
    Name::new("Root"),
    Children::spawn_one(Name::new("Child")),
));
```

---

## Struct CubicCardinalSpline Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicCardinalSpline.html

**Contents:**
- Struct CubicCardinalSpline Copy item path
    - §Interpolation
    - §Tangency
    - §Continuity
    - §Parametrization
    - §Usage
- Fields§
- Implementations§
  - impl<P> CubicCardinalSpline<P>where P: VectorSpace,
    - pub fn new( tension: f32, control_points: impl IntoIterator<Item = P>, ) -> CubicCardinalSpline<P>

A spline interpolated continuously across the nearest four control points, with the position of the curve specified at every control point and the tangents computed automatically. The associated CubicCurve has one segment between each pair of adjacent control points.

Note the Catmull-Rom spline is a special case of Cardinal spline where the tension is 0.5.

The curve passes through every control point.

Tangents are automatically computed based on the positions of control points.

The curve is at minimum C1, meaning that it is continuous (it has no holes or jumps), and its tangent vector is also well-defined everywhere, without sudden jumps.

The first segment of the curve connects the first two control points, the second connects the second and third, and so on. This remains true when a cyclic curve is formed with to_curve_cyclic, in which case the final curve segment connects the last control point to the first.

The control points of the Cardinal spline

Build a new Cardinal spline.

Build a new Catmull-Rom spline, the special case of a Cardinal spline where tension = 1/2.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicCardinalSpline<P>where
    P: VectorSpace,{
    pub tension: f32,
    pub control_points: Vec<P>,
}
```

Example 2 (javascript):
```javascript
let points = [
    vec2(-1.0, -20.0),
    vec2(3.0, 2.0),
    vec2(5.0, 3.0),
    vec2(9.0, 8.0),
];
let cardinal = CubicCardinalSpline::new(0.3, points).to_curve().unwrap();
let positions: Vec<_> = cardinal.iter_positions(100).collect();
```

Example 3 (javascript):
```javascript
202fn form_curve(
203    control_points: &ControlPoints,
204    spline_mode: SplineMode,
205    cycling_mode: CyclingMode,
206) -> Curve {
207    let (points, tangents): (Vec<_>, Vec<_>) =
208        control_points.points_and_tangents.iter().copied().unzip();
209
210    match spline_mode {
211        SplineMode::Hermite => {
212            let spline = CubicHermite::new(points, tangents);
213            Curve(match cycling_mode {
214                CyclingMode::NotCyclic => spline.to_curve().ok(),
215                CyclingMode::Cyclic => spline.to_curve_cyclic().ok(),
216            })
217   
...
```

---

## Trait ComputedStates Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ComputedStates.html

**Contents:**
- Trait ComputedStates Copy item path
- Required Associated Types§
    - type SourceStates: StateSet
- Required Methods§
    - fn compute(sources: Self::SourceStates) -> Option<Self>
- Provided Methods§
    - fn register_computed_state_systems(schedule: &mut Schedule)
- Dyn Compatibility§
- Implementors§

A state whose value is automatically computed based on the values of other States.

A computed state is a state that is deterministically derived from a set of SourceStates. The StateSet is passed into the compute method whenever one of them changes, and the result becomes the state’s value.

you can then add it to an App, and from there you use the state as normal

The set of states from which the Self is derived.

This can either be a single type that implements States, an Option of a type that implements States, or a tuple containing multiple types that implement States or Optional versions of them.

For example, (MapState, EnemyState) is valid, as is (MapState, Option<EnemyState>)

Computes the next value of State<Self>. This function gets called whenever one of the SourceStates changes.

If the result is None, the State<Self> resource will be removed from the world.

This function sets up systems that compute the state whenever one of the SourceStates change. It is called by App::add_computed_state, but can be called manually if App is not used.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ComputedStates:
    'static
    + Send
    + Sync
    + Clone
    + PartialEq
    + Eq
    + Hash
    + Debug {
    type SourceStates: StateSet;

    // Required method
    fn compute(sources: Self::SourceStates) -> Option<Self>;

    // Provided method
    fn register_computed_state_systems(schedule: &mut Schedule) { ... }
}
```

Example 2 (javascript):
```javascript
/// Computed States require some state to derive from
#[derive(States, Clone, PartialEq, Eq, Hash, Debug, Default)]
enum AppState {
    #[default]
    Menu,
    InGame { paused: bool }
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
struct InGame;

impl ComputedStates for InGame {
    /// We set the source state to be the state, or a tuple of states,
    /// we want to depend on. You can also wrap each state in an Option,
    /// if you want the computed state to execute even if the state doesn't
    /// currently exist in the world.
    type SourceStates = AppState;

    /// We then define th
...
```

Example 3 (unknown):
```unknown
App::new()
    .init_state::<AppState>()
    .add_computed_state::<InGame>();
```

---

## Struct ColorStop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ColorStop.html

**Contents:**
- Struct ColorStop Copy item path
- Fields§
- Implementations§
  - impl ColorStop
    - pub fn new(color: impl Into<Color>, point: Val) -> ColorStop
      - Examples found in repository?
    - pub fn auto(color: impl Into<Color>) -> ColorStop
      - Examples found in repository?
    - pub fn px(color: impl Into<Color>, px: f32) -> ColorStop
    - pub fn percent(color: impl Into<Color>, percent: f32) -> ColorStop

A color stop for a gradient

Logical position along the gradient line. Stop positions are relative to the start of the gradient and not other stops.

Normalized position between this and the following stop of the interpolation midpoint.

Create a new color stop

An automatic color stop. The positions of automatic stops are interpolated evenly between explicit stops.

A color stop with its position in logical pixels.

A color stop with a percentage position.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ColorStop {
    pub color: Color,
    pub point: Val,
    pub hint: f32,
}
```

Example 2 (javascript):
```javascript
83fn setup(mut commands: Commands, args: Res<Args>) {
84    commands.spawn(Camera2d);
85
86    let rows_to_spawn = args.gradient_count.div_ceil(COLS);
87
88    // Create a grid of gradients
89    commands
90        .spawn(Node {
91            width: percent(100),
92            height: percent(100),
93            display: Display::Grid,
94            grid_template_columns: RepeatedGridTrack::flex(COLS as u16, 1.0),
95            grid_template_rows: RepeatedGridTrack::flex(rows_to_spawn as u16, 1.0),
96            ..default()
97        })
98        .with_children(|parent| {
99            for i i
...
```

Example 3 (javascript):
```javascript
800    pub fn setup(mut commands: Commands) {
801        let color_stops = vec![
802            ColorStop::new(Color::BLACK, px(5)),
803            ColorStop::new(Color::WHITE, px(5)),
804            ColorStop::new(Color::WHITE, percent(100)),
805            ColorStop::auto(RED),
806        ];
807
808        commands.spawn((Camera2d, DespawnOnExit(super::Scene::RadialGradient)));
809        commands
810            .spawn((
811                Node {
812                    width: percent(100),
813                    height: percent(100),
814                    display: Display::Grid,
815        
...
```

Example 4 (javascript):
```javascript
26fn setup(mut commands: Commands) {
27    commands.spawn(Camera2d);
28
29    commands
30        .spawn(Node {
31            flex_direction: FlexDirection::Column,
32            row_gap: px(20),
33            margin: UiRect::all(px(20)),
34            ..Default::default()
35        })
36        .with_children(|commands| {
37            for (b, stops) in [
38                (
39                    4.,
40                    vec![
41                        ColorStop::new(Color::WHITE, percent(15)),
42                        ColorStop::new(Color::BLACK, percent(85)),
43                    ],
44   
...
```

---

## Struct LightmapPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/pbr/struct.LightmapPlugin.html

**Contents:**
- Struct LightmapPlugin Copy item path
- Trait Implementations§
  - impl Plugin for LightmapPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str
    - fn is_unique(&self) -> bool
- Auto Trait Implementations§

A plugin that provides an implementation of lightmaps.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LightmapPlugin;
```

---

## Function on_event Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.on_event.html

**Contents:**
- Function on_event Copy item path
- §Example

A SystemCondition-satisfying system that returns true if there are any new events of the given type since it was last called.

**Examples:**

Example 1 (unknown):
```unknown
pub fn on_event<T>(reader: MessageReader<'_, '_, T>) -> boolwhere
    T: Message,
```

Example 2 (unknown):
```unknown
app.add_systems(
    my_system.run_if(on_message::<MyMessage>),
);

#[derive(Message)]
struct MyMessage;

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// No new `MyMessage` events have been push so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 0);

world.resource_mut::<Messages<MyMessage>>().write(MyMessage);

// A `MyMessage` event has been pushed so `my_system` will run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Derive Macro GizmoConfigGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.GizmoConfigGroup.html

**Contents:**
- Derive Macro GizmoConfigGroup Copy item path

Implements the GizmoConfigGroup trait for a gizmo config group type.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(GizmoConfigGroup)]
```

---

## Struct AudioSink Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AudioSink.html

**Contents:**
- Struct AudioSink Copy item path
- Implementations§
  - impl AudioSink
    - pub fn new(sink: Sink) -> AudioSink
- Trait Implementations§
  - impl AudioSinkPlayback for AudioSink
    - fn volume(&self) -> Volume
    - fn set_volume(&mut self, volume: Volume)
    - fn speed(&self) -> f32
    - fn set_speed(&self, speed: f32)

Used to control audio during playback.

Bevy inserts this component onto your entities when it begins playing an audio source. Use AudioPlayer to trigger that to happen.

You can use this component to modify the playback settings while the audio is playing.

If this component is removed from an entity, and an AudioSource is attached to that entity, that AudioSource will start playing. If that source is unchanged, that translates to the audio restarting.

Create a new audio sink.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AudioSink { /* private fields */ }
```

---

## Struct SubApp Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.SubApp.html

**Contents:**
- Struct SubApp Copy item path
- §Example
- Fields§
- Implementations§
  - impl SubApp
    - pub fn new() -> SubApp
    - pub fn world(&self) -> &World
      - Examples found in repository?
    - pub fn world_mut(&mut self) -> &mut World
      - Examples found in repository?

A secondary application with its own World. These can run independently of each other.

These are useful for situations where certain processes (e.g. a render thread) need to be kept separate from the main application.

The schedule that will be run by update.

Returns a default, empty SubApp.

Returns a reference to the World.

Returns a mutable reference to the World.

Runs the default schedule.

Does not clear internal trackers used for change detection.

Runs the default schedule and updates internal component trackers.

Extracts data from world into the app’s world using the registered extract method.

Note: There is no default extract method. Calling extract does nothing if set_extract has not been called.

Sets the method that will be called by extract.

The first argument is the World to extract data from, the second argument is the app World.

Take the function that will be called by extract out of the app, if any was set, and replace it with None.

If you use Bevy, bevy_render will set a default extract function used to extract data from the main world into the render world as part of the Extract phase. In that case, you cannot replace it with your own function. Instead, take the Bevy default function with this, and install your own instead which calls the Bevy default.

See App::insert_resource.

See App::init_resource.

See App::add_systems.

See App::register_system.

See App::configure_sets.

See App::add_schedule.

See App::init_schedule.

See App::get_schedule.

See App::get_schedule_mut.

See App::edit_schedule.

See App::configure_schedules.

See App::allow_ambiguous_component.

See App::allow_ambiguous_resource.

See App::ignore_ambiguity.

See App::add_message.

See App::add_message.

See App::add_plugins.

See App::is_plugin_added.

See App::get_added_plugins.

Return the state of plugins.

Runs Plugin::finish for each plugin.

Runs Plugin::cleanup for each plugin.

See App::register_type.

See App::register_type_data.

See App::register_function.

See App::register_function_with_name.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SubApp {
    pub update_schedule: Option<Interned<dyn ScheduleLabel>>,
    /* private fields */
}
```

Example 2 (javascript):
```javascript
#[derive(Resource, Default)]
struct Val(pub i32);

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, AppLabel)]
struct ExampleApp;

// Create an app with a certain resource.
let mut app = App::new();
app.insert_resource(Val(10));

// Create a sub-app with the same resource and a single schedule.
let mut sub_app = SubApp::new();
sub_app.update_schedule = Some(Main.intern());
sub_app.insert_resource(Val(100));

// Setup an extract function to copy the resource's value in the main world.
sub_app.set_extract(|main_world, sub_world| {
    sub_world.resource_mut::<Val>().0 = main_world.resource::<Va
...
```

Example 3 (javascript):
```javascript
76fn count_ambiguities(sub_app: &SubApp) -> AmbiguitiesCount {
77    let schedules = sub_app.world().resource::<Schedules>();
78    let mut ambiguities = <HashMap<_, _>>::default();
79    for (_, schedule) in schedules.iter() {
80        let ambiguities_in_schedule = schedule.graph().conflicting_systems().len();
81        ambiguities.insert(schedule.label(), ambiguities_in_schedule);
82    }
83    AmbiguitiesCount(ambiguities)
84}
```

Example 4 (javascript):
```javascript
63fn configure_ambiguity_detection(sub_app: &mut SubApp) {
64    let mut schedules = sub_app.world_mut().resource_mut::<Schedules>();
65    for (_, schedule) in schedules.iter_mut() {
66        schedule.set_build_settings(ScheduleBuildSettings {
67            // NOTE: you can change this to `LogLevel::Ignore` to easily see the current number of ambiguities.
68            ambiguity_detection: LogLevel::Warn,
69            use_shortnames: false,
70            ..default()
71        });
72    }
73}
```

---

## Trait ShapeSample Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ShapeSample.html

**Contents:**
- Trait ShapeSample Copy item path
- Required Associated Types§
    - type Output
- Required Methods§
    - fn sample_interior<R>(&self, rng: &mut R) -> Self::Outputwhere R: Rng + ?Sized,
      - §Example
    - fn sample_boundary<R>(&self, rng: &mut R) -> Self::Outputwhere R: Rng + ?Sized,
      - §Example
- Provided Methods§
    - fn interior_dist(self) -> impl Distribution<Self::Output>where Self: Sized,

Exposes methods to uniformly sample a variety of primitive shapes.

The type of vector returned by the sample methods, Vec2 for 2D shapes and Vec3 for 3D shapes.

Uniformly sample a point from inside the area/volume of this shape, centered on 0.

Shapes like Cylinder, Capsule2d and Capsule3d are oriented along the y-axis.

Uniformly sample a point from the surface of this shape, centered on 0.

Shapes like Cylinder, Capsule2d and Capsule3d are oriented along the y-axis.

Extract a Distribution whose samples are points of this shape’s interior, taken uniformly.

Extract a Distribution whose samples are points of this shape’s boundary, taken uniformly.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ShapeSample {
    type Output;

    // Required methods
    fn sample_interior<R>(&self, rng: &mut R) -> Self::Output
       where R: Rng + ?Sized;
    fn sample_boundary<R>(&self, rng: &mut R) -> Self::Output
       where R: Rng + ?Sized;

    // Provided methods
    fn interior_dist(self) -> impl Distribution<Self::Output>
       where Self: Sized { ... }
    fn boundary_dist(self) -> impl Distribution<Self::Output>
       where Self: Sized { ... }
}
```

Example 2 (javascript):
```javascript
let square = Rectangle::new(2.0, 2.0);

// Returns a Vec2 with both x and y between -1 and 1.
println!("{}", square.sample_interior(&mut rand::rng()));
```

Example 3 (javascript):
```javascript
let square = Rectangle::new(2.0, 2.0);

// Returns a Vec2 where one of the coordinates is at ±1,
//  and the other is somewhere between -1 and 1.
println!("{}", square.sample_boundary(&mut rand::rng()));
```

Example 4 (javascript):
```javascript
let square = Rectangle::new(2.0, 2.0);
let rng = rand::rng();

// Iterate over points randomly drawn from `square`'s interior:
for random_val in square.interior_dist().sample_iter(rng).take(5) {
    println!("{}", random_val);
}
```

---

## Struct Plane2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Plane2d.html

**Contents:**
- Struct Plane2d Copy item path
- Fields§
- Implementations§
  - impl Plane2d
    - pub fn new(normal: Vec2) -> Plane2d
      - §Panics
- Trait Implementations§
  - impl Bounded2d for Plane2d
    - fn aabb_2d(&self, isometry: impl Into<Isometry2d>) -> Aabb2d
    - fn bounding_circle(&self, isometry: impl Into<Isometry2d>) -> BoundingCircle

An unbounded plane in 2D space. It forms a separating surface through the origin, stretching infinitely far

The normal of the plane. The plane will be placed perpendicular to this direction

Create a new Plane2d from a normal

Panics if the given normal is zero (or very close to zero), or non-finite.

Returns the default Plane2d with a normal pointing in the +Y direction.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Plane2d {
    pub normal: Dir2,
}
```

---

## Struct World Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.World.html

**Contents:**
- Struct World Copy item path
  - §Resources
- Implementations§
  - impl World
    - pub fn register_event_key<E>(&mut self) -> EventKeywhere E: Event,
    - pub fn event_key<E>(&self) -> Option<EventKey>where E: Event,
  - impl World
    - pub fn add_observer<E, B, M>( &mut self, system: impl IntoObserverSystem<E, B, M>, ) -> EntityWorldMut<'_>where E: Event, B: Bundle,
      - §Example
      - §Panics

Stores and exposes operations on entities, components, resources, and their associated metadata.

Each Entity has a set of unique components, based on their type. Entity components can be created, updated, removed, and queried using a given

For complex access patterns involving SystemParam, consider using SystemState.

To mutate different parts of the world simultaneously, use World::resource_scope or SystemState.

Worlds can also store Resources, which are unique instances of a given type that don’t belong to a specific Entity. There are also non send resources, which can only be accessed on the main thread. See Resource for usage.

Generates the EventKey for this event type.

If this type has already been registered, this will return the existing EventKey.

This is used by various dynamically typed observer APIs, such as DeferredWorld::trigger_raw.

Fetches the EventKey for this event type, if it has already been generated.

This is used by various dynamically typed observer APIs, such as DeferredWorld::trigger_raw.

Spawns a “global” Observer which will watch for the given event. Returns its Entity as a EntityWorldMut.

system can be any system whose first parameter is On.

Calling observe on the returned EntityWorldMut will observe the observer itself, which you very likely do not want.

Panics if the given system is an exclusive system.

Triggers the given Event, which will run any Observers watching for it.

For a variant that borrows the event rather than consuming it, use World::trigger_ref instead.

A deprecated alias for trigger to ease migration.

Instead of specifying the trigger target separately, information about the target of the event is embedded in the data held by the event type itself.

Triggers the given Event using the given Trigger, which will run any Observers watching for it.

For a variant that borrows the event rather than consuming it, use World::trigger_ref instead.

Triggers the given mutable Event reference, which will run any Observers watching for it.

Compared to World::trigger, this method is most useful when it’s necessary to check or use the event after it has been modified by observers.

Triggers the given mutable Event reference using the given mutable Trigger reference, which will run any Observers watching for it.

Compared to World::trigger, this method is most useful when it’s necessary to check or use the event after it has been modified by observers.

Registers a system and returns a SystemId so it can later be

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct World { /* private fields */ }
```

Example 2 (unknown):
```unknown
#[derive(Component)]
struct A;

world.add_observer(|_: On<Add, A>| {
    // ...
});
world.add_observer(|_: On<Remove, A>| {
    // ...
});
```

Example 3 (javascript):
```javascript
47fn setup_with_world(world: &mut World) {
48    // We can run it once manually
49    world.run_system_once(system_b).unwrap();
50    // Or with a Callback
51    let system_id = world.register_system(system_b);
52    world.spawn((Callback(system_id), B));
53}
```

Example 4 (javascript):
```javascript
fn increment(mut counter: Local<u8>) {
   *counter += 1;
   println!("{}", *counter);
}

let mut world = World::default();
let counter_one = world.register_system(increment);
let counter_two = world.register_system(increment);
world.run_system(counter_one); // -> 1
world.run_system(counter_one); // -> 2
world.run_system(counter_two); // -> 1
```

---

## Function mat3a Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.mat3a.html

**Contents:**
- Function mat3a Copy item path

Creates a 3x3 matrix from three column vectors.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn mat3a(x_axis: Vec3A, y_axis: Vec3A, z_axis: Vec3A) -> Mat3A
```

---

## Struct LinearRgba Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LinearRgba.html

**Contents:**
- Struct LinearRgba Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl LinearRgba
    - pub const BLACK: LinearRgba
    - pub const WHITE: LinearRgba
    - pub const NONE: LinearRgba
    - pub const RED: LinearRgba
    - pub const GREEN: LinearRgba

Linear RGB color with alpha.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The red channel. [0.0, 1.0]

The green channel. [0.0, 1.0]

The blue channel. [0.0, 1.0]

The alpha channel. [0.0, 1.0]

A fully black color with full alpha.

A fully white color with full alpha.

A fully transparent color.

A fully red color with full alpha.

A fully green color with full alpha.

A fully blue color with full alpha.

This type can be used to represent an invalid color value; in some rendering applications the color will be ignored, enabling performant hacks like hiding lines by setting their color to INVALID.

Construct a new LinearRgba color from components.

Construct a new LinearRgba color from (r, g, b) components, with the default alpha (1.0).

Return a copy of this color with the red channel set to the given value.

Return a copy of this color with the green channel set to the given value.

Return a copy of this color with the blue channel set to the given value.

Converts this color to a u32.

Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian). A will be the most significant byte and R the least significant.

Construct a new LinearRgba color with the default values (white with full alpha).

Luminance calculated using the CIE XYZ formula.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct LinearRgba {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

Example 3 (javascript):
```javascript
38fn setup(
39    mut commands: Commands,
40    mut meshes: ResMut<Assets<Mesh>>,
41    mut materials: ResMut<Assets<StandardMaterial>>,
42) {
43    // ground plane
44    commands.spawn((
45        Mesh3d(meshes.add(Plane3d::default().mesh().size(100.0, 100.0))),
46        MeshMaterial3d(materials.add(Color::WHITE)),
47        Movable,
48    ));
49
50    // cubes
51
52    // We're seeding the PRNG here to make this example deterministic for testing purposes.
53    // This isn't strictly required in practical use unless you need your app to be deterministic.
54    let mut rng = ChaCha8Rng::seed
...
```

Example 4 (javascript):
```javascript
42fn setup(
43    parameters: Res<Parameters>,
44    mut commands: Commands,
45    mut meshes: ResMut<Assets<Mesh>>,
46    mut materials: ResMut<Assets<StandardMaterial>>,
47    asset_server: Res<AssetServer>,
48) {
49    // ground plane
50    commands.spawn((
51        Mesh3d(meshes.add(Plane3d::default().mesh().size(10.0, 10.0))),
52        MeshMaterial3d(materials.add(StandardMaterial {
53            base_color: Color::WHITE,
54            perceptual_roughness: 1.0,
55            ..default()
56        })),
57    ));
58
59    // left wall
60    let mut transform = Transform::from_xyz(2.5, 2.
...
```

---

## Enum AppExit Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/enum.AppExit.html

**Contents:**
- Enum AppExit Copy item path
- §Portability
- Variants§
  - Success
  - Error(NonZero<u8>)
- Implementations§
  - impl AppExit
    - pub const fn error() -> AppExit
      - Examples found in repository?
    - pub const fn is_success(&self) -> bool

A Message that indicates the App should exit. If one or more of these are present at the end of an update, the runner will end and (maybe) return control to the caller.

This message can be used to detect when an exit is requested. Make sure that systems listening for this message run before the current update ends.

This type is roughly meant to map to a standard definition of a process exit code (0 means success, not 0 means error). Due to portability concerns (see ExitCode and process::exit) we only allow error codes between 1 and 255.

App exited without any problems.

The App experienced an unhandleable error. Holds the exit code we expect our app to return.

Creates a AppExit::Error with an error code of 1.

Returns true if self is a AppExit::Success.

Returns true if self is a AppExit::Error.

Creates a AppExit from a code.

When code is 0 a AppExit::Success is constructed otherwise a AppExit::Error is constructed.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AppExit {
    Success,
    Error(NonZero<u8>),
}
```

Example 2 (unknown):
```unknown
154fn setup(
155    mut commands: Commands,
156    asset_server: Res<AssetServer>,
157    app_status: Res<AppStatus>,
158    render_device: Res<RenderDevice>,
159    render_adapter: Res<RenderAdapter>,
160    mut meshes: ResMut<Assets<Mesh>>,
161    mut materials: ResMut<Assets<ExtendedMaterial<StandardMaterial, CustomDecalExtension>>>,
162) {
163    // Error out if clustered decals aren't supported on the current platform.
164    if !decal::clustered::clustered_decals_are_usable(&render_device, &render_adapter) {
165        error!("Clustered decals aren't usable on this platform.");
166      
...
```

Example 3 (unknown):
```unknown
143fn setup(
144    mut commands: Commands,
145    asset_server: Res<AssetServer>,
146    app_status: Res<AppStatus>,
147    render_device: Res<RenderDevice>,
148    render_adapter: Res<RenderAdapter>,
149    mut meshes: ResMut<Assets<Mesh>>,
150    mut materials: ResMut<Assets<StandardMaterial>>,
151) {
152    // Error out if clustered decals (and so light textures) aren't supported on the current platform.
153    if !decal::clustered::clustered_decals_are_usable(&render_device, &render_adapter) {
154        error!("Light textures aren't usable on this platform.");
155        commands.write_m
...
```

---

## Struct NonSend Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.NonSend.html

**Contents:**
- Struct NonSend Copy item path
- Implementations§
  - impl<'w, T> NonSend<'w, T>where T: 'static,
    - pub fn is_added(&self) -> bool
    - pub fn is_changed(&self) -> bool
    - pub fn changed_by(&self) -> MaybeLocation
- Trait Implementations§
  - impl<'w, T> Debug for NonSend<'w, T>where T: Debug,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'w, T> Deref for NonSend<'w, T>

Shared borrow of a non-Send resource.

Only Send resources may be accessed with the Res SystemParam. In case that the resource does not implement Send, this SystemParam wrapper can be used. This will instruct the scheduler to instead run the system on the main thread so that it doesn’t send the resource over to another thread.

This SystemParam fails validation if non-send resource doesn’t exist. This will cause a panic, but can be configured to do nothing or warn once.

Use Option<NonSend<T>> instead if the resource might not always exist.

Returns true if the resource was added after the system last ran.

Returns true if the resource was added or mutably dereferenced after the system last ran.

The location that last caused this to change.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct NonSend<'w, T>where
    T: 'static,{ /* private fields */ }
```

---

## Struct DynamicScene Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DynamicScene.html

**Contents:**
- Struct DynamicScene Copy item path
- Fields§
- Implementations§
  - impl DynamicScene
    - pub fn from_scene(scene: &Scene) -> DynamicScene
    - pub fn from_world(world: &World) -> DynamicScene
      - Examples found in repository?
    - pub fn write_to_world_with( &self, world: &mut World, entity_map: &mut EntityHashMap<Entity>, type_registry: &AppTypeRegistry, ) -> Result<(), SceneSpawnError>
    - pub fn write_to_world( &self, world: &mut World, entity_map: &mut EntityHashMap<Entity>, ) -> Result<(), SceneSpawnError>
    - pub fn serialize(&self, registry: &TypeRegistry) -> Result<String, Error>

A collection of serializable resources and dynamic entities.

Each dynamic entity in the collection contains its own run-time defined set of components. To spawn a dynamic scene, you can use either:

Resources stored in the dynamic scene.

Entities contained in the dynamic scene.

Create a new dynamic scene from a given scene.

Create a new dynamic scene from a given world.

Write the resources, the dynamic entities, and their corresponding components to the given world.

This method will return a SceneSpawnError if a type either is not registered in the provided AppTypeRegistry resource, or doesn’t reflect the Component or Resource trait.

Write the resources, the dynamic entities, and their corresponding components to the given world.

This method will return a SceneSpawnError if a type either is not registered in the world’s AppTypeRegistry resource, or doesn’t reflect the Component trait.

Serialize this dynamic scene into the official Bevy scene format (.scn / .scn.ron).

The Bevy scene format is based on Rusty Object Notation (RON). It describes the scene in a human-friendly format. To deserialize the scene, use the SceneLoader.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DynamicScene {
    pub resources: Vec<Box<dyn PartialReflect>>,
    pub entities: Vec<DynamicEntity>,
}
```

Example 2 (javascript):
```javascript
157fn save_scene_system(world: &mut World) {
158    // Scenes can be created from any ECS World.
159    // You can either create a new one for the scene or use the current World.
160    // For demonstration purposes, we'll create a new one.
161    let mut scene_world = World::new();
162
163    // The `TypeRegistry` resource contains information about all registered types (including components).
164    // This is used to construct scenes, so we'll want to ensure that our previous type registrations
165    // exist in this new scene world as well.
166    // To do this, we can simply clone the `A
...
```

Example 3 (javascript):
```javascript
157fn save_scene_system(world: &mut World) {
158    // Scenes can be created from any ECS World.
159    // You can either create a new one for the scene or use the current World.
160    // For demonstration purposes, we'll create a new one.
161    let mut scene_world = World::new();
162
163    // The `TypeRegistry` resource contains information about all registered types (including components).
164    // This is used to construct scenes, so we'll want to ensure that our previous type registrations
165    // exist in this new scene world as well.
166    // To do this, we can simply clone the `A
...
```

---

## Struct BorderRadius Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BorderRadius.html

**Contents:**
- Struct BorderRadius Copy item path
- §Example
- Fields§
- Implementations§
  - impl BorderRadius
    - pub const DEFAULT: BorderRadius = Self::ZERO
    - pub const ZERO: BorderRadius
    - pub const MAX: BorderRadius
    - pub const fn all(radius: Val) -> BorderRadius
      - Examples found in repository?

Used to add rounded corners to a UI node. You can set a UI node to have uniformly rounded corners or specify different radii for each corner. If a given radius exceeds half the length of the smallest dimension between the node’s height or width, the radius will calculated as half the smallest dimension.

Elliptical nodes are not supported yet. Percentage values are based on the node’s smallest dimension, either width or height.

https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius

Zero curvature. All the corners will be right-angled.

Maximum curvature. The UI Node will take a capsule shape or circular if width and height are equal.

Set all four corners to the same curvature.

Sets the radii to logical pixel values.

Sets the radii to percentage values.

Sets the radius for the top left corner. Remaining corners will be right-angled.

Sets the radius for the top right corner. Remaining corners will be right-angled.

Sets the radius for the bottom right corner. Remaining corners will be right-angled.

Sets the radius for the bottom left corner. Remaining corners will be right-angled.

Sets the radii for the top left and bottom left corners. Remaining corners will be right-angled.

Sets the radii for the top right and bottom right corners. Remaining corners will be right-angled.

Sets the radii for the top left and top right corners. Remaining corners will be right-angled.

Sets the radii for the bottom left and bottom right corners. Remaining corners will be right-angled.

Returns the BorderRadius with its top_left field set to the given value.

Returns the BorderRadius with its top_right field set to the given value.

Returns the BorderRadius with its bottom_right field set to the given value.

Returns the BorderRadius with its bottom_left field set to the given value.

Returns the BorderRadius with its top_left and bottom_left fields set to the given value.

Returns the BorderRadius with its top_right and bottom_right fields set to the given value.

Returns the BorderRadius with its top_left and top_right fields set to the given value.

Returns the BorderRadius with its bottom_left and bottom_right fields set to the given value.

Resolve the border radius for a single corner from the given context values. Returns the radius of the corner in physical pixels.

Resolve the border radii for the corners from the given context values. Returns the radii of the each corner in physical pixels.

Returns the argument unchanged.

Creates Self using defaul

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct BorderRadius {
    pub top_left: Val,
    pub top_right: Val,
    pub bottom_right: Val,
    pub bottom_left: Val,
}
```

Example 2 (unknown):
```unknown
fn setup_ui(mut commands: Commands) {
    commands.spawn((
        Node {
            width: Val::Px(100.),
            height: Val::Px(100.),
            border: UiRect::all(Val::Px(2.)),
            ..Default::default()
        },
        BackgroundColor(BLUE.into()),
        BorderRadius::new(
            // top left
            Val::Px(10.),
            // top right
            Val::Px(20.),
            // bottom right
            Val::Px(30.),
            // bottom left
            Val::Px(40.),
        ),
    ));
}
```

Example 3 (unknown):
```unknown
277fn drag_button(label: &str) -> impl Bundle {
278    (
279        Node {
280            border: BUTTON_BORDER,
281            justify_content: JustifyContent::Center,
282            align_items: AlignItems::Center,
283            padding: BUTTON_PADDING,
284            ..default()
285        },
286        Button,
287        BackgroundColor(Color::BLACK),
288        BorderRadius::all(BUTTON_BORDER_RADIUS_SIZE),
289        BUTTON_BORDER_COLOR,
290        children![widgets::ui_text(label, Color::WHITE)],
291    )
292}
```

Example 4 (unknown):
```unknown
325fn drag_button(label: &str) -> impl Bundle {
326    (
327        Node {
328            border: BUTTON_BORDER,
329            justify_content: JustifyContent::Center,
330            align_items: AlignItems::Center,
331            padding: BUTTON_PADDING,
332            ..default()
333        },
334        Button,
335        BackgroundColor(Color::BLACK),
336        BorderRadius::all(BUTTON_BORDER_RADIUS_SIZE),
337        BUTTON_BORDER_COLOR,
338        children![widgets::ui_text(label, Color::WHITE),],
339    )
340}
```

---

## Struct MinimalPlugins Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MinimalPlugins.html

**Contents:**
- Struct MinimalPlugins Copy item path
- §Example:
- Trait Implementations§
  - impl PluginGroup for MinimalPlugins
    - fn build(self) -> PluginGroupBuilder
    - fn name() -> String
    - fn set<T>(self, plugin: T) -> PluginGroupBuilderwhere T: Plugin,
- Auto Trait Implementations§
  - impl Freeze for MinimalPlugins
  - impl RefUnwindSafe for MinimalPlugins

This plugin group will add the minimal plugins for a Bevy application:

This plugin group represents the absolute minimum, bare-bones, bevy application. Use this if you want to have absolute control over the plugins used.

It includes a schedule runner (ScheduleRunnerPlugin) to provide functionality that would otherwise be driven by a windowed application’s event loop or message loop.

By default, this loop will run as fast as possible, which can result in high CPU usage. You can add a delay using run_loop, or remove the loop using run_once.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MinimalPlugins;
```

Example 2 (unknown):
```unknown
App::new().add_plugins(MinimalPlugins.set(ScheduleRunnerPlugin::run_loop(
    // Run 60 times per second.
    Duration::from_secs_f64(1.0 / 60.0),
))).run();
```

---

## Struct ResMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ResMut.html

**Contents:**
- Struct ResMut Copy item path
- Implementations§
  - impl<'w, T> ResMut<'w, T>where T: Resource + ?Sized,
    - pub fn into_inner(self) -> &'w mut T
      - Examples found in repository?
    - pub fn reborrow(&mut self) -> Mut<'_, T>
    - pub fn map_unchanged<U>(self, f: impl FnOnce(&mut T) -> &mut U) -> Mut<'w, U>where U: ?Sized,
    - pub fn filter_map_unchanged<U>( self, f: impl FnOnce(&mut T) -> Option<&mut U>, ) -> Option<Mut<'w, U>>where U: ?Sized,
    - pub fn try_map_unchanged<U, E>( self, f: impl FnOnce(&mut T) -> Result<&mut U, E>, ) -> Result<Mut<'w, U>, E>where U: ?Sized,
    - pub fn as_deref_mut(&mut self) -> Mut<'_, <T as Deref>::Target>where T: DerefMut,

Unique mutable borrow of a Resource.

See the Resource documentation for usage.

If you need a shared borrow, use Res instead.

This SystemParam fails validation if resource doesn’t exist. This will cause a panic, but can be configured to do nothing or warn once.

Use Option<ResMut<T>> instead if the resource might not always exist.

Consume self and return a mutable reference to the contained value while marking self as “changed”.

Returns a Mut<> with a smaller lifetime. This is useful if you have &mut ResMut <T>, but you need a Mut<T>.

Maps to an inner value by applying a function to the contained reference, without flagging a change.

You should never modify the argument passed to the closure – if you want to modify the data without flagging a change, consider using DetectChangesMut::bypass_change_detection to make your intent explicit.

Optionally maps to an inner value by applying a function to the contained reference. This is useful in a situation where you need to convert a Mut<T> to a Mut<U>, but only if T contains U.

As with map_unchanged, you should never modify the argument passed to the closure.

Optionally maps to an inner value by applying a function to the contained reference, returns an error on failure. This is useful in a situation where you need to convert a Mut<T> to a Mut<U>, but only if T contains U.

As with map_unchanged, you should never modify the argument passed to the closure.

Allows you access to the dereferenced value of this pointer without immediately triggering change detection.

Convert this ResMut into a Mut. This allows keeping the change-detection feature of Mut while losing the specificity of ResMut for resources.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ResMut<'w, T>where
    T: Resource + ?Sized,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
174fn scheduled_spawner(
175    mut commands: Commands,
176    args: Res<Args>,
177    window: Single<&Window>,
178    mut scheduled: ResMut<BirdScheduled>,
179    mut counter: ResMut<BevyCounter>,
180    bird_resources: ResMut<BirdResources>,
181) {
182    if scheduled.waves > 0 {
183        let bird_resources = bird_resources.into_inner();
184        spawn_birds(
185            &mut commands,
186            args.into_inner(),
187            &window.resolution,
188            &mut counter,
189            scheduled.per_wave,
190            bird_resources,
191            None,
192            sc
...
```

Example 3 (javascript):
```javascript
50fn setup(
51    mut commands: Commands,
52    args: Res<Args>,
53    mesh_assets: ResMut<Assets<Mesh>>,
54    material_assets: ResMut<Assets<StandardMaterial>>,
55) {
56    let args = args.into_inner();
57    let material_assets = material_assets.into_inner();
58    let mesh_assets = mesh_assets.into_inner();
59    let n = args.grid_size;
60
61    // Camera
62    let w = n as f32;
63    commands.spawn((
64        Camera3d::default(),
65        Transform::from_xyz(w * 1.25, w + 1.0, w * 1.25)
66            .looking_at(Vec3::new(0.0, (w * -1.1) + 1.0, 0.0), Vec3::Y),
67    ));
68
69    // Ligh
...
```

Example 4 (javascript):
```javascript
138fn setup(
139    mut commands: Commands,
140    args: Res<Args>,
141    mesh_assets: ResMut<Assets<Mesh>>,
142    material_assets: ResMut<Assets<StandardMaterial>>,
143    images: ResMut<Assets<Image>>,
144) {
145    warn!(include_str!("warning_string.txt"));
146
147    let args = args.into_inner();
148    let images = images.into_inner();
149    let material_assets = material_assets.into_inner();
150    let mesh_assets = mesh_assets.into_inner();
151
152    let meshes = init_meshes(args, mesh_assets);
153
154    let material_textures = init_textures(args, images);
155    let materials = in
...
```

---

## Struct BVec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BVec4.html

**Contents:**
- Struct BVec4 Copy item path
- Fields§
- Implementations§
  - impl BVec4
    - pub const FALSE: BVec4
    - pub const TRUE: BVec4
    - pub const fn new(x: bool, y: bool, z: bool, w: bool) -> BVec4
    - pub const fn splat(v: bool) -> BVec4
    - pub const fn from_array(a: [bool; 4]) -> BVec4
    - pub fn bitmask(self) -> u32

A 4-dimensional bool vector mask.

Creates a new vector mask.

Creates a vector mask with all elements set to v.

Creates a new vector mask from a bool array.

Returns a bitmask with the lowest 4 bits set from the elements of self.

A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc.

Returns true if any of the elements are true, false otherwise.

Returns true if all the elements are true, false otherwise.

Tests the value at index.

Panics if index is greater than 3.

Sets the element at index.

Panics if index is greater than 3.

Deserialize expects a sequence of 4 values.

Serialize as a sequence of 4 values.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C, align(1))]pub struct BVec4 {
    pub x: bool,
    pub y: bool,
    pub z: bool,
    pub w: bool,
}
```

---

## Struct ShadowStyle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ShadowStyle.html

**Contents:**
- Struct ShadowStyle Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for ShadowStyle
    - fn clone(&self) -> ShadowStyle
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ShadowStyle
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for ShadowStyle
    - fn default() -> ShadowStyle

How much the shadow should spread outward.

Negative values will make the shadow shrink inwards. Percentage values are based on the width of the UI node.

Blurriness of the shadow

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ShadowStyle {
    pub color: Color,
    pub x_offset: Val,
    pub y_offset: Val,
    pub spread_radius: Val,
    pub blur_radius: Val,
}
```

---

## Struct Update Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.Update.html

**Contents:**
- Struct Update Copy item path
- Trait Implementations§
  - impl Clone for Update
    - fn clone(&self) -> Update
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Update
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Update
    - fn default() -> Update
  - impl Hash for Update

The schedule that contains any app logic that must run once per render frame. For most gameplay logic, consider using FixedUpdate instead.

Examples of systems that should run once per render frame include (but are not limited to):

See the FixedUpdate schedule for examples of systems that should not use this schedule. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Update;
```

---

## Struct Deferred Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Deferred.html

**Contents:**
- Struct Deferred Copy item path
- §Examples
- Implementations§
  - impl<T> Deferred<'_, T>where T: SystemBuffer,
    - pub fn reborrow(&mut self) -> Deferred<'_, T>
- Trait Implementations§
  - impl<'a, T> Deref for Deferred<'a, T>where T: SystemBuffer,
    - type Target = T
    - fn deref(&self) -> &<Deferred<'a, T> as Deref>::Target
  - impl<'a, T> DerefMut for Deferred<'a, T>where T: SystemBuffer,

A SystemParam that stores a buffer which gets applied to the World during ApplyDeferred. This is used internally by Commands to defer World mutations.

By using this type to defer mutations, you can avoid mutable World access within a system, which allows it to run in parallel with more systems.

Note that deferring mutations is not free, and should only be used if the gains in parallelization outweigh the time it takes to apply deferred mutations. In general, Deferred should only be used for mutations that are infrequent, or which otherwise take up a small portion of a system’s run-time.

Returns a Deferred<T> with a smaller lifetime. This is useful if you have &mut Deferred<T> but need Deferred<T>.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Deferred<'a, T>(/* private fields */)
where
    T: SystemBuffer;
```

Example 2 (javascript):
```javascript
// Tracks whether or not there is a threat the player should be aware of.
#[derive(Resource, Default)]
pub struct Alarm(bool);

#[derive(Component)]
pub struct Settlement {
    // ...
}

// A threat from inside the settlement.
#[derive(Component)]
pub struct Criminal;

// A threat from outside the settlement.
#[derive(Component)]
pub struct Monster;


use bevy_ecs::system::{Deferred, SystemBuffer, SystemMeta};

// Uses deferred mutations to allow signaling the alarm from multiple systems in parallel.
#[derive(Resource, Default)]
struct AlarmFlag(bool);

impl AlarmFlag {
    /// Sounds the alar
...
```

---

## Function vec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vec4.html

**Contents:**
- Function vec4 Copy item path
      - Examples found in repository?

Creates a 4-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn vec4(x: f32, y: f32, z: f32, w: f32) -> Vec4
```

Example 2 (javascript):
```javascript
52fn setup(mut commands: Commands, mut meshes: ResMut<Assets<Mesh>>) {
53    // Build a custom triangle mesh with colors
54    // We define a custom mesh because the examples only uses a limited
55    // set of vertex attributes for simplicity
56    let mesh = Mesh::new(
57        PrimitiveTopology::TriangleList,
58        RenderAssetUsages::default(),
59    )
60    .with_inserted_indices(Indices::U32(vec![0, 1, 2]))
61    .with_inserted_attribute(
62        Mesh::ATTRIBUTE_POSITION,
63        vec![
64            vec3(-0.5, -0.5, 0.0),
65            vec3(0.5, -0.5, 0.0),
66            vec3(0.0
...
```

Example 3 (unknown):
```unknown
180fn spawn_water(
181    commands: &mut Commands,
182    asset_server: &AssetServer,
183    meshes: &mut Assets<Mesh>,
184    water_materials: &mut Assets<ExtendedMaterial<StandardMaterial, Water>>,
185) {
186    commands.spawn((
187        Mesh3d(meshes.add(Plane3d::new(Vec3::Y, Vec2::splat(1.0)))),
188        MeshMaterial3d(water_materials.add(ExtendedMaterial {
189            base: StandardMaterial {
190                base_color: BLACK.into(),
191                perceptual_roughness: 0.0,
192                ..default()
193            },
194            extension: Water {
195               
...
```

---

## Struct DefaultUiCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DefaultUiCamera.html

**Contents:**
- Struct DefaultUiCamera Copy item path
- Implementations§
  - impl<'w, 's> DefaultUiCamera<'w, 's>
    - pub fn get(&self) -> Option<Entity>
- Trait Implementations§
  - impl SystemParam for DefaultUiCamera<'_, '_>
    - type State = FetchState
    - type Item<'w, 's> = DefaultUiCamera<'w, 's>
    - fn init_state( world: &mut World, ) -> <DefaultUiCamera<'_, '_> as SystemParam>::State
    - fn init_access( state: &<DefaultUiCamera<'_, '_> as SystemParam>::State, system_meta: &mut SystemMeta, component_access_set: &mut FilteredAccessSet, world: &mut World, )

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DefaultUiCamera<'w, 's> { /* private fields */ }
```

---

## Enum TorusKind Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.TorusKind.html

**Contents:**
- Enum TorusKind Copy item path
- Variants§
  - Ring
  - Horn
  - Spindle
  - Invalid
- Trait Implementations§
  - impl Clone for TorusKind
    - fn clone(&self) -> TorusKind
    - fn clone_from(&mut self, source: &Self)

The type of torus determined by the minor and major radii

A torus that has a ring. The major radius is greater than the minor radius

A torus that has no hole but also doesn’t intersect itself. The major radius is equal to the minor radius

A self-intersecting torus. The major radius is less than the minor radius

A torus with non-geometric properties like a minor or major radius that is non-positive, infinite, or NaN

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum TorusKind {
    Ring,
    Horn,
    Spindle,
    Invalid,
}
```

---

## Trait PluginGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/trait.PluginGroup.html

**Contents:**
- Trait PluginGroup Copy item path
- Required Methods§
    - fn build(self) -> PluginGroupBuilder
- Provided Methods§
    - fn name() -> String
    - fn set<T>(self, plugin: T) -> PluginGroupBuilderwhere T: Plugin,
      - Examples found in repository?
- Dyn Compatibility§
- Implementors§
  - impl PluginGroup for FeathersPlugins

Combines multiple Plugins into a single unit.

If you want an easier, but slightly more restrictive, method of implementing this trait, you may be interested in the plugin_group! macro.

Configures the Plugins that are to be added.

Configures a name for the PluginGroup which is primarily used for debugging.

Sets the value of the given Plugin, if it exists

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait PluginGroup: Sized {
    // Required method
    fn build(self) -> PluginGroupBuilder;

    // Provided methods
    fn name() -> String { ... }
    fn set<T>(self, plugin: T) -> PluginGroupBuilder
       where T: Plugin { ... }
}
```

Example 2 (unknown):
```unknown
5fn main() {
6    App::new()
7        .add_plugins(DefaultPlugins.set(PbrPlugin {
8            prepass_enabled: false,
9            ..default()
10        }))
11        .run();
12}
```

Example 3 (unknown):
```unknown
6fn main() {
7    App::new()
8        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
9            task_pool_options: TaskPoolOptions::with_num_threads(4),
10        }))
11        .run();
12}
```

Example 4 (unknown):
```unknown
8fn main() {
9    App::new()
10        .add_plugins(DefaultPlugins.set(WebAssetPlugin {
11            silence_startup_warning: true,
12        }))
13        .add_systems(Startup, setup)
14        .run();
15}
```

---

## Struct Polyline3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Polyline3d.html

**Contents:**
- Struct Polyline3d Copy item path
- Fields§
- Implementations§
  - impl Polyline3d
    - pub fn new(vertices: impl IntoIterator<Item = Vec3>) -> Polyline3d
      - Examples found in repository?
    - pub fn with_subdivisions( start: Vec3, end: Vec3, subdivisions: usize, ) -> Polyline3d
- Trait Implementations§
  - impl Bounded3d for Polyline3d
    - fn aabb_3d(&self, isometry: impl Into<Isometry3d>) -> Aabb3d

A series of connected line segments in 3D space.

The vertices of the polyline

Create a new Polyline3d from its vertices

Create a new Polyline3d from two endpoints with subdivision points. subdivisions = 0 creates a simple line with just start and end points. subdivisions = 1 adds one point in the middle, creating 2 segments, etc.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Polyline3d {
    pub vertices: Vec<Vec3>,
}
```

Example 2 (javascript):
```javascript
54fn setup(
55    mut commands: Commands,
56    mut meshes: ResMut<Assets<Mesh>>,
57    mut images: ResMut<Assets<Image>>,
58    mut materials: ResMut<Assets<StandardMaterial>>,
59) {
60    let debug_material = materials.add(StandardMaterial {
61        base_color_texture: Some(images.add(uv_debug_texture())),
62        ..default()
63    });
64
65    let shapes = [
66        meshes.add(Cuboid::default()),
67        meshes.add(Tetrahedron::default()),
68        meshes.add(Capsule3d::default()),
69        meshes.add(Torus::default()),
70        meshes.add(Cylinder::default()),
71        meshes.a
...
```

---

## Trait Luminance Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Luminance.html

**Contents:**
- Trait Luminance Copy item path
- Required Methods§
    - fn luminance(&self) -> f32
    - fn with_luminance(&self, value: f32) -> Self
    - fn darker(&self, amount: f32) -> Self
    - fn lighter(&self, amount: f32) -> Self
- Dyn Compatibility§
- Implementors§
  - impl Luminance for Color
  - impl Luminance for Hsla

Methods for changing the luminance of a color. Note that these methods are not guaranteed to produce consistent results across color spaces, but will be within a given space.

Return the luminance of this color (0.0 - 1.0).

Return a new version of this color with the given luminance. The resulting color will be clamped to the valid range for the color space; for some color spaces, clamping may cause the hue or chroma to change.

Return a darker version of this color. The amount should be between 0.0 and 1.0. The amount represents an absolute decrease in luminance, and is distributive: color.darker(a).darker(b) == color.darker(a + b). Colors are clamped to black if the amount would cause them to go below black.

For a relative decrease in luminance, you can simply mix() with black.

Return a lighter version of this color. The amount should be between 0.0 and 1.0. The amount represents an absolute increase in luminance, and is distributive: color.lighter(a).lighter(b) == color.lighter(a + b). Colors are clamped to white if the amount would cause them to go above white.

For a relative increase in luminance, you can simply mix() with white.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Luminance: Sized {
    // Required methods
    fn luminance(&self) -> f32;
    fn with_luminance(&self, value: f32) -> Self;
    fn darker(&self, amount: f32) -> Self;
    fn lighter(&self, amount: f32) -> Self;
}
```

---

## Enum GridAutoFlow Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GridAutoFlow.html

**Contents:**
- Enum GridAutoFlow Copy item path
- Variants§
  - Row
  - Column
  - RowDense
  - ColumnDense
- Implementations§
  - impl GridAutoFlow
    - pub const DEFAULT: GridAutoFlow = Self::Row
- Trait Implementations§

Controls whether grid items are placed row-wise or column-wise as well as whether the sparse or dense packing algorithm is used.

The “dense” packing algorithm attempts to fill in holes earlier in the grid, if smaller items come up later. This may cause items to appear out-of-order when doing so would fill in holes left by larger items.

Defaults to GridAutoFlow::Row.

https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow

Items are placed by filling each row in turn, adding new rows as necessary.

Items are placed by filling each column in turn, adding new columns as necessary.

Combines Row with the dense packing algorithm.

Combines Column with the dense packing algorithm.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GridAutoFlow {
    Row,
    Column,
    RowDense,
    ColumnDense,
}
```

---

## Struct PointerInputPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PointerInputPlugin.html

**Contents:**
- Struct PointerInputPlugin Copy item path
- Trait Implementations§
  - impl Plugin for PointerInputPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str
    - fn is_unique(&self) -> bool
- Auto Trait Implementations§

Adds mouse and touch inputs for picking pointers to your app. This is a default input plugin, that you can replace with your own plugin as needed.

Toggling mouse input or touch input can be done at runtime by modifying PointerInputSettings resource.

PointerInputSettings can be initialized with custom values, but will be initialized with default values if it is not present at the moment this is added to the app.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PointerInputPlugin;
```

---

## Struct LightGizmoConfigGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LightGizmoConfigGroup.html

**Contents:**
- Struct LightGizmoConfigGroup Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for LightGizmoConfigGroup
    - fn clone(&self) -> LightGizmoConfigGroup
    - fn clone_from(&mut self, source: &Self)
  - impl Default for LightGizmoConfigGroup
    - fn default() -> LightGizmoConfigGroup
  - impl FromArg for LightGizmoConfigGroup
    - type This<'from_arg> = LightGizmoConfigGroup

The GizmoConfigGroup used to configure the visualization of lights.

Draw a gizmo for all lights if true.

Default color strategy for all light gizmos.

Defaults to LightGizmoColor::MatchLightColor.

Color to use for drawing a PointLight gizmo when LightGizmoColor::ByLightType is used.

Color to use for drawing a SpotLight gizmo when LightGizmoColor::ByLightType is used.

Color to use for drawing a DirectionalLight gizmo when LightGizmoColor::ByLightType is used.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LightGizmoConfigGroup {
    pub draw_all: bool,
    pub color: LightGizmoColor,
    pub point_light_color: Color,
    pub spot_light_color: Color,
    pub directional_light_color: Color,
}
```

---

## Trait SystemSet Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SystemSet.html

**Contents:**
- Trait SystemSet Copy item path
  - §Defining new system sets
    - §Adding systems to system sets
- Required Methods§
    - fn dyn_clone(&self) -> Box<dyn SystemSet>
- Provided Methods§
    - fn system_type(&self) -> Option<TypeId>
    - fn is_anonymous(&self) -> bool
    - fn intern(&self) -> Interned<dyn SystemSet>where Self: Sized,
- Trait Implementations§

System sets are tag-like labels that can be used to group systems together.

This allows you to share configuration (like run conditions) across multiple systems, and order systems or system sets relative to conceptual groups of systems. To control the behavior of a system set as a whole, use Schedule::configure_sets, or the method of the same name on App.

Systems can belong to any number of system sets, reflecting multiple roles or facets that they might have. For example, you may want to annotate a system as “consumes input” and “applies forces”, and ensure that your systems are ordered correctly for both of those sets.

System sets can belong to any number of other system sets, allowing you to create nested hierarchies of system sets to group systems together. Configuration applied to system sets will flow down to their members (including other system sets), allowing you to set and modify the configuration in a single place.

Systems sets are also useful for exposing a consistent public API for dependencies to hook into across versions of your crate, allowing them to add systems to a specific set, or order relative to that set, without leaking implementation details of the exact systems involved.

To create a new system set, use the #[derive(SystemSet)] macro. Unit structs are a good choice for one-off sets.

When you want to define several related system sets, consider creating an enum system set. Each variant will be treated as a separate system set.

By convention, the listed order of the system set in the enum corresponds to the order in which the systems are run. Ordering must be explicitly added to ensure that this is the case, but following this convention will help avoid confusion.

To add systems to a system set, call in_set on the system function while adding it to your app or schedule.

Like usual, these methods can be chained with other configuration methods like before, or repeated to add systems to multiple sets.

Clones this SystemSet.

Returns Some if this system set is a SystemTypeSet.

Returns true if this system set is an AnonymousSet.

Returns an Interned value corresponding to self.

**Examples:**

Example 1 (unknown):
```unknown
pub trait SystemSet:
    Send
    + Sync
    + Debug
    + DynEq
    + DynHash {
    // Required method
    fn dyn_clone(&self) -> Box<dyn SystemSet>;

    // Provided methods
    fn system_type(&self) -> Option<TypeId> { ... }
    fn is_anonymous(&self) -> bool { ... }
    fn intern(&self) -> Interned<dyn SystemSet>
       where Self: Sized { ... }
}
```

Example 2 (unknown):
```unknown
#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
struct PhysicsSystems;
```

Example 3 (unknown):
```unknown
#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum CombatSystems {
   TargetSelection,
   DamageCalculation,
   Cleanup,
}
```

Example 4 (javascript):
```javascript
use bevy_ecs::prelude::*;

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum CombatSystems {
   TargetSelection,
   DamageCalculation,
   Cleanup,
}

fn target_selection() {}

fn enemy_damage_calculation() {}

fn player_damage_calculation() {}

let mut schedule = Schedule::default();
// Configuring the sets to run in order.
schedule.configure_sets((CombatSystems::TargetSelection, CombatSystems::DamageCalculation, CombatSystems::Cleanup).chain());

// Adding a single system to a set.
schedule.add_systems(target_selection.in_set(CombatSystems::TargetSelection));

// Adding multiple sy
...
```

---

## Struct MainSchedulePlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.MainSchedulePlugin.html

**Contents:**
- Struct MainSchedulePlugin Copy item path
- Trait Implementations§
  - impl Plugin for MainSchedulePlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str
    - fn is_unique(&self) -> bool
- Auto Trait Implementations§

Initializes the Main schedule, sub schedules, and resources for a given App.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MainSchedulePlugin;
```

---

## Struct MeshRayCastSettings Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshRayCastSettings.html

**Contents:**
- Struct MeshRayCastSettings Copy item path
- Fields§
- Implementations§
  - impl<'a> MeshRayCastSettings<'a>
    - pub fn with_filter( self, filter: &'a impl Fn(Entity) -> bool, ) -> MeshRayCastSettings<'a>
    - pub fn with_early_exit_test( self, early_exit_test: &'a impl Fn(Entity) -> bool, ) -> MeshRayCastSettings<'a>
    - pub fn with_visibility( self, visibility: RayCastVisibility, ) -> MeshRayCastSettings<'a>
    - pub fn always_early_exit(self) -> MeshRayCastSettings<'a>
    - pub fn never_early_exit(self) -> MeshRayCastSettings<'a>
- Trait Implementations§

Settings for a ray cast.

Determines how ray casting should consider Visibility.

A predicate that is applied for every entity that ray casts are performed against. Only entities that return true will be considered.

A function that is run every time a hit is found. Ray casting will continue to check for hits along the ray as long as this returns false.

Set the filter to apply to the ray cast.

Set the early exit test to apply to the ray cast.

Set the RayCastVisibility setting to apply to the ray cast.

This ray cast should exit as soon as the nearest hit is found.

This ray cast should check all entities whose AABB intersects the ray and return all hits.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshRayCastSettings<'a> {
    pub visibility: RayCastVisibility,
    pub filter: &'a dyn Fn(Entity) -> bool,
    pub early_exit_test: &'a dyn Fn(Entity) -> bool,
}
```

---

## Struct PickingPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PickingPlugin.html

**Contents:**
- Struct PickingPlugin Copy item path
- Trait Implementations§
  - impl Plugin for PickingPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str
    - fn is_unique(&self) -> bool
- Auto Trait Implementations§

This plugin sets up the core picking infrastructure. It receives input events, and provides the shared types used by other picking plugins.

Behavior of picking can be controlled by modifying PickingSettings.

PickingSettings will be initialized with default values if it is not present at the moment this is added to the app.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PickingPlugin;
```

---

## Trait ContainsEntity Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ContainsEntity.html

**Contents:**
- Trait ContainsEntity Copy item path
- Required Methods§
    - fn entity(&self) -> Entity
- Implementations on Foreign Types§
  - impl<T> ContainsEntity for &Twhere T: ContainsEntity,
    - fn entity(&self) -> Entity
  - impl<T> ContainsEntity for &mut Twhere T: ContainsEntity,
    - fn entity(&self) -> Entity
  - impl<T> ContainsEntity for Rc<T>where T: ContainsEntity,
    - fn entity(&self) -> Entity

A trait for types that contain an Entity.

This trait behaves similarly to Borrow<Entity>, but yielding Entity directly.

It should only be implemented when:

Returns the contained entity.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ContainsEntity {
    // Required method
    fn entity(&self) -> Entity;
}
```

---

## Derive Macro Event Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Event.html

**Contents:**
- Derive Macro Event Copy item path

Implement the Event trait.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Event)]
{
    // Attributes available to this derive:
    #[event]
}
```

---

## Struct ReflectFreelyMutableState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectFreelyMutableState.html

**Contents:**
- Struct ReflectFreelyMutableState Copy item path
- Implementations§
  - impl ReflectFreelyMutableState
    - pub fn set_next_state( &self, world: &mut World, state: &(dyn Reflect + 'static), registry: &TypeRegistry, )
- Trait Implementations§
  - impl Clone for ReflectFreelyMutableState
    - fn clone(&self) -> ReflectFreelyMutableState
    - fn clone_from(&mut self, source: &Self)
  - impl<S> FromType<S> for ReflectFreelyMutableStatewhere S: FreelyMutableState + Reflect + TypePath,
    - fn from_type() -> ReflectFreelyMutableState

A struct used to operate on the reflected FreelyMutableState trait of a type.

A ReflectFreelyMutableState for type T can be obtained via bevy_reflect::TypeRegistration::data.

Tentatively set a pending state transition to a reflected ReflectFreelyMutableState.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectFreelyMutableState(/* private fields */);
```

---

## Struct SmootherStepInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SmootherStepInCurve.html

**Contents:**
- Struct SmootherStepInCurve Copy item path
- Trait Implementations§
  - impl Clone for SmootherStepInCurve
    - fn clone(&self) -> SmootherStepInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SmootherStepInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as the first half of SmootherStepCurve.

This has f″(1) = 0, unlike CubicInCurve which starts similarly.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SmootherStepInCurve;
```

---

## Struct Remove Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Remove.html

**Contents:**
- Struct Remove Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Remove
    - fn clone(&self) -> Remove
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Remove
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl EntityEvent for Removewhere Remove: Send + Sync + 'static,
    - fn event_target(&self) -> Entity

Trigger emitted when a component is removed from an entity, and runs before the component is removed, so you can still access the component data. See ComponentHooks::on_remove for more information.

The entity this component was removed from.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Remove {
    pub entity: Entity,
}
```

---

## Function bvec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.bvec2.html

**Contents:**
- Function bvec2 Copy item path

Creates a 2-dimensional bool vector mask.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn bvec2(x: bool, y: bool) -> BVec2
```

---

## Trait System Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.System.html

**Contents:**
- Trait System Copy item path
- Required Associated Types§
    - type In: SystemInput
    - type Out
- Required Methods§
    - fn name(&self) -> DebugName
    - fn flags(&self) -> SystemStateFlags
    - unsafe fn run_unsafe( &mut self, input: <Self::In as SystemInput>::Inner<'_>, world: UnsafeWorldCell<'_>, ) -> Result<Self::Out, RunSystemError>
      - §Safety
    - fn refresh_hotpatch(&mut self)

An ECS system that can be added to a Schedule

Systems are functions with all arguments implementing SystemParam.

Systems are added to an application using App::add_systems(Update, my_system) or similar methods, and will generally run once per pass of the main loop.

Systems are executed in parallel, in opportunistic order; data access is managed automatically. It’s possible to specify explicit execution order between specific systems, see IntoScheduleConfigs.

Returns the system’s name.

Returns the SystemStateFlags of the system.

Runs the system with the given input in the world. Unlike System::run, this function can be called in parallel with other systems and may break Rust’s aliasing rules if used incorrectly, making it unsafe to call.

Unlike System::run, this will not apply deferred parameters, which must be independently applied by calling System::apply_deferred at later point in time.

Refresh the inner pointer based on the latest hot patch jump table

Applies any Deferred system parameters (or other system buffers) of this system to the world.

This is where Commands get applied.

Enqueues any Deferred system parameters (or other system buffers) of this system into the world’s command buffer.

Validates that all parameters can be acquired and that system can run without panic. Built-in executors use this to prevent invalid systems from running.

However calling and respecting System::validate_param_unsafe or its safe variant is not a strict requirement, both System::run and System::run_unsafe should provide their own safety mechanism to prevent undefined behavior.

This method has to be called directly before System::run_unsafe with no other (relevant) world mutations in between. Otherwise, while it won’t lead to any undefined behavior, the validity of the param may change.

Initialize the system.

Returns a FilteredAccessSet with the access required to run the system.

Checks any Ticks stored on this system and wraps their value if they get too old.

This method must be called periodically to ensure that change detection behaves correctly. When using bevy’s default configuration, this will be called for you as needed.

Gets the tick indicating the last time this system ran.

Overwrites the tick indicating the last time this system ran.

This is a complex and error-prone operation, that can have unexpected consequences on any system relying on this code. However, it can be an essential escape hatch when, for example, you are trying to synchroni

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait System:
    Send
    + Sync
    + 'static {
    type In: SystemInput;
    type Out;

Show 19 methods    // Required methods
    fn name(&self) -> DebugName;
    fn flags(&self) -> SystemStateFlags;
    unsafe fn run_unsafe(
        &mut self,
        input: <Self::In as SystemInput>::Inner<'_>,
        world: UnsafeWorldCell<'_>,
    ) -> Result<Self::Out, RunSystemError>;
    fn refresh_hotpatch(&mut self);
    fn apply_deferred(&mut self, world: &mut World);
    fn queue_deferred(&mut self, world: DeferredWorld<'_>);
    unsafe fn validate_param_unsafe(
        &mut self,
        w
...
```

---

## Struct SpawnWith Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpawnWith.html

**Contents:**
- Struct SpawnWith Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<R, F> SpawnableList<R> for SpawnWith<F>where R: Relationship, F: FnOnce(&mut RelatedSpawner<'_, R>) + Send + Sync + 'static,
    - fn spawn(this: MovingPtr<'_, SpawnWith<F>>, world: &mut World, entity: Entity)
    - fn size_hint(&self) -> usize
- Auto Trait Implementations§
  - impl<F> Freeze for SpawnWith<F>where F: Freeze,
  - impl<F> RefUnwindSafe for SpawnWith<F>where F: RefUnwindSafe,
  - impl<F> Send for SpawnWith<F>where F: Send,

A SpawnableList that spawns entities using a FnOnce with a RelatedSpawner as an argument:

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpawnWith<F>(pub F);
```

Example 2 (javascript):
```javascript
let mut world = World::new();
world.spawn((
    Name::new("Root"),
    Children::spawn((
        Spawn(Name::new("Child1")),
        SpawnWith(|parent: &mut RelatedSpawner<ChildOf>| {
            parent.spawn(Name::new("Child2"));
            parent.spawn(Name::new("Child3"));
        }),
    )),
));
```

---

## Function resource_equals Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_equals.html

**Contents:**
- Function resource_equals Copy item path
- §Panics
- §Example

Generates a SystemCondition-satisfying closure that returns true if the resource is equal to value.

The condition will panic if the resource does not exist.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_equals<T>(value: T) -> impl FnMut(Res<'_, T>)where
    T: Resource + PartialEq,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_equals` will only return true if the given resource equals the given value
    my_system.run_if(resource_equals(Counter(0))),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `Counter` is `0` so `my_system` can run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);

// `Counter` is no longer `0` so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Struct QuadraticOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuadraticOutCurve.html

**Contents:**
- Struct QuadraticOutCurve Copy item path
- Trait Implementations§
  - impl Clone for QuadraticOutCurve
    - fn clone(&self) -> QuadraticOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuadraticOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = -(t * (t - 2.0))

This is the Hermite interpolator for

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuadraticOutCurve;
```

---

## Struct ColorMaterial Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ColorMaterial.html

**Contents:**
- Struct ColorMaterial Copy item path
- Fields§
- Implementations§
  - impl ColorMaterial
    - pub fn from_color(color: impl Into<Color>) -> ColorMaterial
- Trait Implementations§
  - impl AsBindGroup for ColorMaterial
    - type Data = ()
    - type Param = (Res<'static, RenderAssets<GpuImage>>, Res<'static, FallbackImage>, Res<'static, RenderAssets<GpuShaderStorageBuffer>>)
    - fn label() -> Option<&'static str>

A 2d material that renders 2d meshes with a texture tinted by a uniform color

Creates a new material from a given color

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ColorMaterial {
    pub color: Color,
    pub alpha_mode: AlphaMode2d,
    pub uv_transform: Affine2,
    pub texture: Option<Handle<Image>>,
}
```

---

## Struct AnimationClip Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationClip.html

**Contents:**
- Struct AnimationClip Copy item path
- Implementations§
  - impl AnimationClip
    - pub fn curves( &self, ) -> &HashMap<AnimationTargetId, Vec<VariableCurve>, NoOpHash>
    - pub fn curves_mut( &mut self, ) -> &mut HashMap<AnimationTargetId, Vec<VariableCurve>, NoOpHash>
    - pub fn curves_for_target( &self, target_id: AnimationTargetId, ) -> Option<&Vec<VariableCurve>>
    - pub fn curves_for_target_mut( &mut self, target_id: AnimationTargetId, ) -> Option<&mut Vec<VariableCurve>>
    - pub fn duration(&self) -> f32
    - pub fn set_duration(&mut self, duration_sec: f32)
      - Examples found in repository?

A list of VariableCurves and the AnimationTargetIds to which they apply.

Because animation clips refer to targets by UUID, they can target any AnimationTarget with that ID.

VariableCurves for each animation target. Indexed by the AnimationTargetId.

Get mutable references of VariableCurves for each animation target. Indexed by the AnimationTargetId.

Gets the curves for a single animation target.

Returns None if this clip doesn’t animate the target.

Gets mutable references of the curves for a single animation target.

Returns None if this clip doesn’t animate the target.

Duration of the clip, represented in seconds.

Set the duration of the clip in seconds.

Adds an AnimationCurve to an AnimationTarget named by an AnimationTargetId.

If the curve extends beyond the current duration of this clip, this method lengthens this clip to include the entire time span that the curve covers.

For example, a curve with domain [2, 5] will extend the clip to cover [0, 5] when added and will produce the same output on the entire interval [0, 2] because these time values all get clamped to 2.

By contrast, a curve with domain [-10, ∞] will never extend the clip duration when added and will be sampled only on [0, duration], ignoring all negative time values.

Like add_curve_to_target, but adding a VariableCurve directly.

Under normal circumstances, that method is generally more convenient.

Add an EntityEvent with no AnimationTarget to this AnimationClip.

The event will be cloned and triggered on the AnimationPlayer entity once the time (in seconds) is reached in the animation.

See also add_event_to_target.

Add an EntityEvent to an AnimationTarget named by an AnimationTargetId.

The event will be cloned and triggered on the entity matching the target once the time (in seconds) is reached in the animation.

Use add_event instead if you don’t have a specific target.

Add an event function with no AnimationTarget to this AnimationClip.

The func will trigger on the AnimationPlayer entity once the time (in seconds) is reached in the animation.

For a simpler EntityEvent-based alternative, see AnimationClip::add_event. See also add_event_to_target.

Add an event function to an AnimationTarget named by an AnimationTargetId.

The func will trigger on the entity matching the target once the time (in seconds) is reached in the animation.

For a simpler EntityEvent-based alternative, see AnimationClip::add_event_to_target. Use add_event instead if you don’t have a specific 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationClip { /* private fields */ }
```

Example 2 (javascript):
```javascript
37fn setup(
38    mut commands: Commands,
39    mut animations: ResMut<Assets<AnimationClip>>,
40    mut graphs: ResMut<Assets<AnimationGraph>>,
41) {
42    // Camera
43    commands.spawn((
44        Camera2d,
45        Camera {
46            clear_color: ClearColorConfig::Custom(BLACK.into()),
47            ..Default::default()
48        },
49        Bloom {
50            intensity: 0.4,
51            ..Bloom::NATURAL
52        },
53    ));
54
55    // The text that will be changed by animation events.
56    commands.spawn((
57        MessageText,
58        Text2d::default(),
59        TextFo
...
```

Example 3 (javascript):
```javascript
36    fn create(
37        animation_graphs: &mut Assets<AnimationGraph>,
38        animation_clips: &mut Assets<AnimationClip>,
39    ) -> AnimationInfo {
40        // Create an ID that identifies the text node we're going to animate.
41        let animation_target_name = Name::new("Text");
42        let animation_target_id = AnimationTargetId::from_name(&animation_target_name);
43
44        // Allocate an animation clip.
45        let mut animation_clip = AnimationClip::default();
46
47        // Create a curve that animates font size.
48        animation_clip.add_curve_to_target(
49        
...
```

Example 4 (javascript):
```javascript
93    fn create(
94        animation_graphs: &mut Assets<AnimationGraph>,
95        animation_clips: &mut Assets<AnimationClip>,
96    ) -> AnimationInfo {
97        // Create an ID that identifies the text node we're going to animate.
98        let animation_target_name = Name::new("Cube");
99        let animation_target_id = AnimationTargetId::from_name(&animation_target_name);
100
101        // Allocate an animation clip.
102        let mut animation_clip = AnimationClip::default();
103
104        // Each leg of the translation motion should take 3 seconds.
105        let animation_domain =
...
```

---

## Enum PointerButton Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.PointerButton.html

**Contents:**
- Enum PointerButton Copy item path
- Variants§
  - Primary
  - Secondary
  - Middle
- Implementations§
  - impl PointerButton
    - pub fn iter() -> impl Iterator<Item = PointerButton>
- Trait Implementations§
  - impl Clone for PointerButton

The button that was just pressed or released

The primary pointer button

The secondary pointer button

The tertiary pointer button

Iterator over all buttons that a pointer can have.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum PointerButton {
    Primary,
    Secondary,
    Middle,
}
```

---

## Type Alias OnAdd Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.OnAdd.html

**Contents:**
- Type Alias OnAdd Copy item path
- Aliased Type§
- Fields§

Deprecated in favor of Add.

The entity this component was added to.

**Examples:**

Example 1 (unknown):
```unknown
pub type OnAdd = Add;
```

Example 2 (unknown):
```unknown
pub struct OnAdd {
    pub entity: Entity,
}
```

---

## Trait CurveWithTwoDerivatives Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derivatives/trait.CurveWithTwoDerivatives.html

**Contents:**
- Trait CurveWithTwoDerivatives Copy item path
- Required Methods§
    - fn with_two_derivatives(self) -> SampleTwoDerivativesWrapper<Self>
- Dyn Compatibility§
- Implementors§
  - impl<T, C> CurveWithTwoDerivatives<T> for Cwhere T: HasTangent, C: SampleTwoDerivatives<T> + CurveWithDerivative<T>,

Trait for curves that have a well-defined notion of second derivative, allowing for two derivatives to be extracted along with values.

This is implemented by implementing SampleTwoDerivatives.

This curve, but with its first two derivatives included in sampling.

Notably, the output type is a Curve<WithTwoDerivatives<T>>.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait CurveWithTwoDerivatives<T>: Sized + SampleTwoDerivatives<T>where
    T: HasTangent,{
    // Required method
    fn with_two_derivatives(self) -> SampleTwoDerivativesWrapper<Self>;
}
```

---

## Enum LineBreak Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.LineBreak.html

**Contents:**
- Enum LineBreak Copy item path
- Variants§
  - WordBoundary
  - AnyCharacter
  - WordOrCharacter
  - NoWrap
- Trait Implementations§
  - impl Clone for LineBreak
    - fn clone(&self) -> LineBreak
    - fn clone_from(&mut self, source: &Self)

Determines how lines will be broken when preventing text from running out of bounds.

Uses the Unicode Line Breaking Algorithm. Lines will be broken up at the nearest suitable word boundary, usually a space. This behavior suits most cases, as it keeps words intact across linebreaks.

Lines will be broken without discrimination on any character that would leave bounds. This is closer to the behavior one might expect from text in a terminal. However it may lead to words being broken up across linebreaks.

Wraps at the word level, or fallback to character level if a word can’t fit on a line by itself

No soft wrapping, where text is automatically broken up into separate lines when it overflows a boundary, will ever occur. Hard wrapping, where text contains an explicit linebreak such as the escape sequence \n, is still enabled.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum LineBreak {
    WordBoundary,
    AnyCharacter,
    WordOrCharacter,
    NoWrap,
}
```

---

## Struct BoxShadowSamples Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BoxShadowSamples.html

**Contents:**
- Struct BoxShadowSamples Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for BoxShadowSamples
    - fn clone(&self) -> BoxShadowSamples
    - fn clone_from(&mut self, source: &Self)
  - impl Component for BoxShadowSampleswhere BoxShadowSamples: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Number of shadow samples. A larger value will result in higher quality shadows. Default is 4, values higher than ~10 offer diminishing returns.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BoxShadowSamples(pub u32);
```

Example 2 (unknown):
```unknown
use bevy_camera::prelude::*;
use bevy_ecs::prelude::*;
use bevy_ui::prelude::*;
use bevy_ui_render::prelude::*;

fn spawn_camera(mut commands: Commands) {
    commands.spawn((
        Camera2d,
        BoxShadowSamples(6),
    ));
}
```

---

## Struct RationalSegment Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RationalSegment.html

**Contents:**
- Struct RationalSegment Copy item path
- Fields§
- Implementations§
  - impl<P> RationalSegment<P>where P: VectorSpace<Scalar = f32>,
    - pub fn position(&self, t: f32) -> P
    - pub fn velocity(&self, t: f32) -> P
    - pub fn acceleration(&self, t: f32) -> P
- Trait Implementations§
  - impl<P> Clone for RationalSegment<P>where P: Clone + VectorSpace,
    - fn clone(&self) -> RationalSegment<P>

A segment of a rational cubic curve, used to hold precomputed coefficients for fast interpolation. It is a Curve with domain [0, 1].

Note that the knot_span is used only by compound curves constructed by chaining these together.

The coefficients matrix of the cubic curve.

The homogeneous weight coefficients.

The width of the domain of this segment.

Instantaneous position of a point at parametric value t in [0, 1].

Instantaneous velocity of a point at parametric value t in [0, 1].

Instantaneous acceleration of a point at parametric value t in [0, 1].

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RationalSegment<P>where
    P: VectorSpace,{
    pub coeff: [P; 4],
    pub weight_coeff: [f32; 4],
    pub knot_span: f32,
}
```

---

## Enum AnimationNodeType Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AnimationNodeType.html

**Contents:**
- Enum AnimationNodeType Copy item path
- Variants§
  - Clip(Handle<AnimationClip>)
  - Blend
  - Add
- Trait Implementations§
  - impl Clone for AnimationNodeType
    - fn clone(&self) -> AnimationNodeType
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for AnimationNodeType

Animation node data specific to the type of node (clip, blend, or add).

In the case of clip nodes, this contains the actual animation clip associated with the node.

A clip node, which plays an animation clip.

These are always the leaves of the graph.

A blend node, which blends its children according to their weights.

The weights of all the children of this node are normalized to 1.0.

An additive blend node, which combines the animations of its children additively.

The weights of all the children of this node are not normalized to 1.0. Rather, each child is multiplied by its respective weight and added in sequence.

Add nodes are primarily useful for superimposing an animation for a portion of a rig on top of the main animation. For example, an add node could superimpose a weapon attack animation for a character’s limb on top of a running animation to produce an animation of a character attacking while running.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AnimationNodeType {
    Clip(Handle<AnimationClip>),
    Blend,
    Add,
}
```

---

## Struct RenderApp Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/render/struct.RenderApp.html

**Contents:**
- Struct RenderApp Copy item path
- Trait Implementations§
  - impl AppLabel for RenderAppwhere RenderApp: 'static + Send + Sync + Clone + Eq + Debug + Hash,
    - fn dyn_clone(&self) -> Box<dyn AppLabel>
    - fn intern(&self) -> Interned<dyn AppLabel>where Self: Sized,
  - impl Clone for RenderApp
    - fn clone(&self) -> RenderApp
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for RenderApp
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

A label for the rendering sub-app.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RenderApp;
```

---

## Struct Vec Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Vec.html

**Contents:**
- Struct Vec Copy item path
- §Examples
- §Indexing
- §Slicing
- §Capacity and reallocation
- §Guarantees
- Implementations§
  - impl<T> Vec<T>
    - pub const fn new() -> Vec<T>
      - §Examples

A contiguous growable array type, written as Vec<T>, short for ‘vector’.

The vec! macro is provided for convenient initialization:

It can also initialize each element of a Vec<T> with a given value. This may be more efficient than performing allocation and initialization in separate steps, especially when initializing a vector of zeros:

For more information, see Capacity and Reallocation.

Use a Vec<T> as an efficient stack:

The Vec type allows access to values by index, because it implements the Index trait. An example will be more explicit:

However be careful: if you try to access an index which isn’t in the Vec, your software will panic! You cannot do this:

Use get and get_mut if you want to check whether the index is in the Vec.

A Vec can be mutable. On the other hand, slices are read-only objects. To get a slice, use &. Example:

In Rust, it’s more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for String and &str.

The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vector’s length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.

For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10 more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur. However, if the vector’s length is increased to 11, it will have to reallocate, which can be slow. For this reason, it is recommended to use Vec::with_capacity whenever possible to specify how big the vector is expected to get.

Due to its incredibly fundamental nature, Vec makes a lot of guarantees about its design. This ensures that it’s as low-overhead as possible in the general case, and can be correctly manipulated in primitive ways by unsafe code. Note that these guarantees refer to an unqualified Vec<T>. If additional type parameters are added (e.g., to support custom allocators), overriding their defaults may change the behavior.

Most fundamentally, Vec is and always will be a (pointer, capacity, length) triplet. No more, no less. The order of these fields is completely unspecified, and you should use the appropriate methods to modify these. The pointer will never be null, so this

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Vec<T, A = Global>where
    A: Allocator,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
let mut vec = Vec::new();
vec.push(1);
vec.push(2);

assert_eq!(vec.len(), 2);
assert_eq!(vec[0], 1);

assert_eq!(vec.pop(), Some(2));
assert_eq!(vec.len(), 1);

vec[0] = 7;
assert_eq!(vec[0], 7);

vec.extend([1, 2, 3]);

for x in &vec {
    println!("{x}");
}
assert_eq!(vec, [7, 1, 2, 3]);
```

Example 3 (javascript):
```javascript
let mut vec1 = vec![1, 2, 3];
vec1.push(4);
let vec2 = Vec::from([1, 2, 3, 4]);
assert_eq!(vec1, vec2);
```

Example 4 (javascript):
```javascript
let vec = vec![0; 5];
assert_eq!(vec, [0, 0, 0, 0, 0]);

// The following is equivalent, but potentially slower:
let mut vec = Vec::with_capacity(5);
vec.resize(5, 0);
assert_eq!(vec, [0, 0, 0, 0, 0]);
```

---

## Struct Cancel Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Cancel.html

**Contents:**
- Struct Cancel Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Cancel
    - fn clone(&self) -> Cancel
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Cancel
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Cancel
    - type This<'from_arg> = Cancel

Fires when a pointer is canceled, and its current interaction state is dropped.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Cancel {
    pub hit: HitData,
}
```

---

## Struct Mut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mut.html

**Contents:**
- Struct Mut Copy item path
- Implementations§
  - impl<'w, T> Mut<'w, T>where T: ?Sized,
    - pub fn new( value: &'w mut T, added: &'w mut Tick, last_changed: &'w mut Tick, last_run: Tick, this_run: Tick, caller: MaybeLocation<&'w mut &'static Location<'static>>, ) -> Mut<'w, T>
    - pub fn set_ticks(&mut self, last_run: Tick, this_run: Tick)
  - impl<'w, T> Mut<'w, T>where T: ?Sized,
    - pub fn into_inner(self) -> &'w mut T
      - Examples found in repository?
    - pub fn reborrow(&mut self) -> Mut<'_, T>
    - pub fn map_unchanged<U>(self, f: impl FnOnce(&mut T) -> &mut U) -> Mut<'w, U>where U: ?Sized,

Unique mutable borrow of an entity’s component or of a resource.

This can be used in queries to access change detection from immutable query methods, as opposed to &mut T which only provides access to change detection from mutable query methods.

Creates a new change-detection enabled smart pointer. In almost all cases you do not need to call this method manually, as instances of Mut will be created by engine-internal code.

Many use-cases of this method would be better served by Mut::map_unchanged or Mut::reborrow.

Overwrite the last_run and this_run tick that are used for change detection.

This is an advanced feature. Muts are usually created by engine-internal code and consumed by end-user code.

Consume self and return a mutable reference to the contained value while marking self as “changed”.

Returns a Mut<> with a smaller lifetime. This is useful if you have &mut Mut <T>, but you need a Mut<T>.

Maps to an inner value by applying a function to the contained reference, without flagging a change.

You should never modify the argument passed to the closure – if you want to modify the data without flagging a change, consider using DetectChangesMut::bypass_change_detection to make your intent explicit.

Optionally maps to an inner value by applying a function to the contained reference. This is useful in a situation where you need to convert a Mut<T> to a Mut<U>, but only if T contains U.

As with map_unchanged, you should never modify the argument passed to the closure.

Optionally maps to an inner value by applying a function to the contained reference, returns an error on failure. This is useful in a situation where you need to convert a Mut<T> to a Mut<U>, but only if T contains U.

As with map_unchanged, you should never modify the argument passed to the closure.

Allows you access to the dereferenced value of this pointer without immediately triggering change detection.

Convert this NonSendMut into a Mut. This allows keeping the change-detection feature of Mut while losing the specificity of NonSendMut.

Convert this ResMut into a Mut. This allows keeping the change-detection feature of Mut while losing the specificity of ResMut for resources.

When Mut<T> is used in a query, it will be converted to Ref<T> when transformed into its read-only form, providing access to change detection methods.

By contrast &mut T will result in a Mut<T> item in mutable form to record mutations, but result in a bare &T in read-only form.

SAFETY: fetch accesses a

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Mut<'w, T>where
    T: ?Sized,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
#[derive(Component, Clone, Debug)]
struct Name(String);

#[derive(Component, Clone, Copy, Debug)]
struct Health(f32);

fn my_system(mut query: Query<(Mut<Name>, &mut Health)>) {
    // Mutable access provides change detection information for both parameters:
    // - `name` has type `Mut<Name>`
    // - `health` has type `Mut<Health>`
    for (name, health) in query.iter_mut() {
        println!("Name: {:?} (last changed {:?})", name, name.last_changed());
        println!("Health: {:?} (last changed: {:?})", health, health.last_changed());
    }

    // Immutable access only provides change d
...
```

Example 3 (javascript):
```javascript
173    fn get_mut<'a>(
174        &self,
175        entity: &'a mut AnimationEntityMut,
176    ) -> Result<&'a mut Self::Property, AnimationEvaluationError> {
177        let text_color = entity
178            .get_mut::<TextColor>()
179            .ok_or(AnimationEvaluationError::ComponentNotPresent(TypeId::of::<
180                TextColor,
181            >(
182            )))?
183            .into_inner();
184        match text_color.0 {
185            Color::Srgba(ref mut color) => Ok(color),
186            _ => Err(AnimationEvaluationError::PropertyNotPresent(TypeId::of::<
187            
...
```

Example 4 (javascript):
```javascript
215fn move_camera(
216    keyboard_input: Res<ButtonInput<KeyCode>>,
217    mut mouse_wheel_reader: MessageReader<MouseWheel>,
218    mut cameras: Query<&mut Transform, With<Camera3d>>,
219) {
220    let (mut zoom_delta, mut theta_delta) = (0.0, 0.0);
221
222    // Process zoom in and out via the keyboard.
223    if keyboard_input.pressed(KeyCode::KeyW) || keyboard_input.pressed(KeyCode::ArrowUp) {
224        zoom_delta -= CAMERA_KEYBOARD_ZOOM_SPEED;
225    } else if keyboard_input.pressed(KeyCode::KeyS) || keyboard_input.pressed(KeyCode::ArrowDown) {
226        zoom_delta += CAMERA_KEYBOARD_Z
...
```

---

## Enum VideoModeSelection Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.VideoModeSelection.html

**Contents:**
- Enum VideoModeSelection Copy item path
- Variants§
  - Current
  - Specific(VideoMode)
- Trait Implementations§
  - impl Clone for VideoModeSelection
    - fn clone(&self) -> VideoModeSelection
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for VideoModeSelection
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

References an exclusive fullscreen video mode.

Used when setting WindowMode::Fullscreen on a window.

Uses the video mode that the monitor is already in.

Uses a given crate::monitor::VideoMode. A list of video modes supported by the monitor is supplied by crate::monitor::Monitor::video_modes.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum VideoModeSelection {
    Current,
    Specific(VideoMode),
}
```

---

## Macro debug_once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.debug_once.html

**Contents:**
- Macro debug_once Copy item path

Call debug! once per call site.

Useful for logging within systems which are called every frame.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! debug_once {
    ($($arg:tt)+) => { ... };
}
```

---

## Struct PreStartup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PreStartup.html

**Contents:**
- Struct PreStartup Copy item path
- Trait Implementations§
  - impl Clone for PreStartup
    - fn clone(&self) -> PreStartup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PreStartup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PreStartup
    - fn default() -> PreStartup
  - impl Hash for PreStartup

The schedule that runs before Startup.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PreStartup;
```

---

## Trait AppGizmoBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AppGizmoBuilder.html

**Contents:**
- Trait AppGizmoBuilder Copy item path
- Required Methods§
    - fn init_gizmo_group<Config>(&mut self) -> &mut Selfwhere Config: GizmoConfigGroup,
    - fn insert_gizmo_config<Config>( &mut self, group: Config, config: GizmoConfig, ) -> &mut Selfwhere Config: GizmoConfigGroup,
- Dyn Compatibility§
- Implementors§
  - impl AppGizmoBuilder for App

A extension trait adding App::init_gizmo_group and App::insert_gizmo_config.

Registers GizmoConfigGroup in the app enabling the use of Gizmos<Config>.

Configurations can be set using the GizmoConfigStore Resource.

Insert a GizmoConfig into a specific GizmoConfigGroup.

This method should be preferred over AppGizmoBuilder::init_gizmo_group if and only if you need to configure fields upon initialization.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AppGizmoBuilder {
    // Required methods
    fn init_gizmo_group<Config>(&mut self) -> &mut Self
       where Config: GizmoConfigGroup;
    fn insert_gizmo_config<Config>(
        &mut self,
        group: Config,
        config: GizmoConfig,
    ) -> &mut Self
       where Config: GizmoConfigGroup;
}
```

---

## Struct Messages Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Messages.html

**Contents:**
- Struct Messages Copy item path
- §Example
- §Details
- Implementations§
  - impl<M> Messages<M>where M: Message,
    - pub fn oldest_message_count(&self) -> usize
    - pub fn write(&mut self, message: M) -> MessageId<M>
      - Examples found in repository?
    - pub fn write_batch( &mut self, messages: impl IntoIterator<Item = M>, ) -> WriteBatchIds<M> ⓘ
    - pub fn write_default(&mut self) -> MessageId<M>where M: Default,

A message collection that represents the messages that occurred within the last two Messages::update calls. Messages can be written to using a MessageWriter and are typically cheaply read using a MessageReader.

Each message can be consumed by multiple systems, in parallel, with consumption tracked by the MessageReader on a per-system basis.

If no ordering is applied between writing and reading systems, there is a risk of a race condition. This means that whether the messages arrive before or after the next Messages::update is unpredictable.

This collection is meant to be paired with a system that calls Messages::update exactly once per update/frame.

message_update_system is a system that does this, typically initialized automatically using add_message. MessageReaders are expected to read messages from this collection at least once per loop/frame. Messages will persist across a single frame boundary and so ordering of message producers and consumers is not critical (although poorly-planned ordering may cause accumulating lag). If messages are not handled by the end of the frame after they are updated, they will be dropped silently.

Messages is implemented using a variation of a double buffer strategy. Each call to update swaps buffers and clears out the oldest one.

The buffers in Messages will grow indefinitely if update is never called.

An alternative call pattern would be to call update manually across frames to control when messages are cleared. This complicates consumption and risks ever-expanding memory usage if not cleaned up, but can be done by adding your message as a resource instead of using add_message.

Example usage. Example usage standalone.

Returns the index of the oldest message stored in the message buffer.

Writes an message to the current message buffer. MessageReaders can then read the message. This method returns the ID of the written message.

Writes a list of messages all at once, which can later be read by MessageReaders. This is more efficient than writing each message individually. This method returns the IDs of the written messages.

Writes the default value of the message. Useful when the message is an empty struct. This method returns the ID of the written message.

“Sends” an message by writing it to the current message buffer. MessageReaders can then read the message. This method returns the ID of the sent message.

Sends a list of messages all at once, which can later be read by MessageReaders. This is more efficient 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Messages<E>where
    E: Message,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
use bevy_ecs::message::{Message, Messages};

#[derive(Message)]
struct MyMessage {
    value: usize
}

// setup
let mut messages = Messages::<MyMessage>::default();
let mut cursor = messages.get_cursor();

// run this once per update/frame
messages.update();

// somewhere else: write a message
messages.write(MyMessage { value: 1 });

// somewhere else: read the messages
for message in cursor.read(&messages) {
    assert_eq!(message.value, 1)
}

// messages are only processed once per reader
assert_eq!(cursor.read(&messages).count(), 0);
```

Example 3 (javascript):
```javascript
135fn send_and_receive_manual_message_reader(
136    // The `Local` `SystemParam` stores state inside the system itself, rather than in the world.
137    // `MessageCursor<T>` is the internal state of `MessageReader<T>`, which tracks which messages have been seen.
138    mut local_message_reader: Local<MessageCursor<DebugMessage>>,
139    // We can access the `Messages` resource mutably, allowing us to both read and write its contents.
140    mut messages: ResMut<Messages<DebugMessage>>,
141    frame_count: Res<FrameCount>,
142) {
143    println!(
144        "Sending and receiving messages for
...
```

---

## Struct Segment2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Segment2d.html

**Contents:**
- Struct Segment2d Copy item path
- Fields§
- Implementations§
  - impl Segment2d
    - pub const fn new(point1: Vec2, point2: Vec2) -> Segment2d
      - Examples found in repository?
    - pub fn from_direction_and_length(direction: Dir2, length: f32) -> Segment2d
      - Examples found in repository?
    - pub fn from_scaled_direction(scaled_direction: Vec2) -> Segment2d
    - pub fn from_ray_and_length(ray: Ray2d, length: f32) -> Segment2d

A line segment defined by two endpoints in 2D space.

The endpoints of the line segment.

Create a new Segment2d from its endpoints.

Create a new Segment2d centered at the origin with the given direction and length.

The endpoints will be at -direction * length / 2.0 and direction * length / 2.0.

Create a new Segment2d centered at the origin from a vector representing the direction and length of the line segment.

The endpoints will be at -scaled_direction / 2.0 and scaled_direction / 2.0.

Create a new Segment2d starting from the origin of the given ray, going in the direction of the ray for the given length.

The endpoints will be at ray.origin and ray.origin + length * ray.direction.

Get the position of the first endpoint of the line segment.

Get the position of the second endpoint of the line segment.

Compute the midpoint between the two endpoints of the line segment.

Compute the length of the line segment.

Compute the squared length of the line segment.

Compute the normalized direction pointing from the first endpoint to the second endpoint.

For the non-panicking version, see Segment2d::try_direction.

Panics if a valid direction could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Try to compute the normalized direction pointing from the first endpoint to the second endpoint.

Returns Err(InvalidDirectionError) if a valid direction could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Compute the vector from the first endpoint to the second endpoint.

Compute the normalized counterclockwise normal on the left-hand side of the line segment.

For the non-panicking version, see Segment2d::try_left_normal.

Panics if a valid normal could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Try to compute the normalized counterclockwise normal on the left-hand side of the line segment.

Returns Err(InvalidDirectionError) if a valid normal could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Compute the non-normalized counterclockwise normal on the left-hand side of the line segment.

The length of the normal is the distance between the endpoints.

Compute the normalized clockwise normal on the right-hand side of the line segment.

For the non-panicking version, see Segment2d::try_right_normal.

Panics if a valid normal could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Try t

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Segment2d {
    pub vertices: [Vec2; 2],
}
```

Example 2 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

Example 3 (unknown):
```unknown
202fn setup(mut commands: Commands) {
203    commands.spawn(Camera2d);
204
205    commands.spawn((
206        Transform::from_xyz(-OFFSET_X, OFFSET_Y, 0.),
207        Shape::Circle(Circle::new(45.)),
208        DesiredVolume::Aabb,
209        Intersects::default(),
210    ));
211
212    commands.spawn((
213        Transform::from_xyz(0., OFFSET_Y, 0.),
214        Shape::Rectangle(Rectangle::new(80., 80.)),
215        Spin,
216        DesiredVolume::Circle,
217        Intersects::default(),
218    ));
219
220    commands.spawn((
221        Transform::from_xyz(OFFSET_X, OFFSET_Y, 0.),
222       
...
```

---

## Function quat Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.quat.html

**Contents:**
- Function quat Copy item path

Creates a quaternion from x, y, z and w values.

This should generally not be called manually unless you know what you are doing. Use one of the other constructors instead such as identity or from_axis_angle.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn quat(x: f32, y: f32, z: f32, w: f32) -> Quat
```

---

## Struct Node Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Node.html

**Contents:**
- Struct Node Copy item path
    - §Flexbox
    - §CSS Grid
- §See also
- Fields§
  - §Example
  - §Example
- Implementations§
  - impl Node
    - pub const DEFAULT: Node

The base component for UI entities. It describes UI layout and style properties.

When defining new types of UI entities, require Node to make them behave like UI nodes.

Nodes can be laid out using either Flexbox or CSS Grid Layout.

See below for general learning resources and for documentation on the individual style properties.

Which layout algorithm to use when laying out this node’s contents:

https://developer.mozilla.org/en-US/docs/Web/CSS/display

Which part of a Node’s box length styles like width and height control

BoxSizing::BorderBox is generally considered more intuitive and is the default in Bevy even though it is not on the web.

See: https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing

Whether a node should be laid out in-flow with, or independently of its siblings:

https://developer.mozilla.org/en-US/docs/Web/CSS/position

Whether overflowing content should be displayed or clipped.

https://developer.mozilla.org/en-US/docs/Web/CSS/overflow

How much space in logical pixels should be reserved for scrollbars when overflow is set to scroll or auto on an axis.

How the bounds of clipped content should be determined

https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-clip-margin

The horizontal position of the left edge of the node.

https://developer.mozilla.org/en-US/docs/Web/CSS/left

The horizontal position of the right edge of the node.

https://developer.mozilla.org/en-US/docs/Web/CSS/right

The vertical position of the top edge of the node.

https://developer.mozilla.org/en-US/docs/Web/CSS/top

The vertical position of the bottom edge of the node.

https://developer.mozilla.org/en-US/docs/Web/CSS/bottom

The ideal width of the node. width is used when it is within the bounds defined by min_width and max_width.

https://developer.mozilla.org/en-US/docs/Web/CSS/width

The ideal height of the node. height is used when it is within the bounds defined by min_height and max_height.

https://developer.mozilla.org/en-US/docs/Web/CSS/height

The minimum width of the node. min_width is used if it is greater than width and/or max_width.

https://developer.mozilla.org/en-US/docs/Web/CSS/min-width

The minimum height of the node. min_height is used if it is greater than height and/or max_height.

https://developer.mozilla.org/en-US/docs/Web/CSS/min-height

The maximum width of the node. max_width is used if it is within the bounds defined by min_width and width.

https://developer.mozilla.org/en-US/docs/Web/CSS/max-width

The maxim

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Node {Show 40 fields
    pub display: Display,
    pub box_sizing: BoxSizing,
    pub position_type: PositionType,
    pub overflow: Overflow,
    pub scrollbar_width: f32,
    pub overflow_clip_margin: OverflowClipMargin,
    pub left: Val,
    pub right: Val,
    pub top: Val,
    pub bottom: Val,
    pub width: Val,
    pub height: Val,
    pub min_width: Val,
    pub min_height: Val,
    pub max_width: Val,
    pub max_height: Val,
    pub aspect_ratio: Option<f32>,
    pub align_items: AlignItems,
    pub justify_items: JustifyItems,
    pub align_self: AlignSelf,
    pub justi
...
```

Example 2 (javascript):
```javascript
let node = Node {
    margin: UiRect {
        left: Val::Percent(10.),
        right: Val::Percent(10.),
        top: Val::Percent(15.),
        bottom: Val::Percent(15.)
    },
    ..Default::default()
};
```

Example 3 (javascript):
```javascript
let node = Node {
    padding: UiRect {
        left: Val::Percent(1.),
        right: Val::Percent(2.),
        top: Val::Percent(3.),
        bottom: Val::Percent(4.)
    },
    ..Default::default()
};
```

---

## Enum RadialGradientShape Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.RadialGradientShape.html

**Contents:**
- Enum RadialGradientShape Copy item path
- Variants§
  - ClosestSide
  - FarthestSide
  - ClosestCorner
  - FarthestCorner
  - Circle(Val)
  - Ellipse(Val, Val)
- Implementations§
  - impl RadialGradientShape

A circle with radius equal to the distance from its center to the closest side

A circle with radius equal to the distance from its center to the farthest side

An ellipse with extents equal to the distance from its center to the nearest corner

An ellipse with extents equal to the distance from its center to the farthest corner

Resolve the physical dimensions of the end shape of the radial gradient

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum RadialGradientShape {
    ClosestSide,
    FarthestSide,
    ClosestCorner,
    FarthestCorner,
    Circle(Val),
    Ellipse(Val, Val),
}
```

---

## Struct OrthographicProjection Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.OrthographicProjection.html

**Contents:**
- Struct OrthographicProjection Copy item path
- §Examples
- Fields§
- Implementations§
  - impl OrthographicProjection
    - pub fn default_2d() -> OrthographicProjection
    - pub fn default_3d() -> OrthographicProjection
      - Examples found in repository?
- Trait Implementations§
  - impl CameraProjection for OrthographicProjection

Project a 3D space onto a 2D surface using parallel lines, i.e., unlike PerspectiveProjection, the size of objects remains the same regardless of their distance to the camera.

The volume contained in the projection is called the view frustum. Since the viewport is rectangular and projection lines are parallel, the view frustum takes the shape of a cuboid.

Note that the scale of the projection and the apparent size of objects are inversely proportional. As the size of the projection increases, the size of objects decreases.

Configure the orthographic projection to one world unit per 100 window pixels:

The distance of the near clipping plane in world units.

Objects closer than this will not be rendered.

The distance of the far clipping plane in world units.

Objects further than this will not be rendered.

Specifies the origin of the viewport as a normalized position from 0 to 1, where (0, 0) is the bottom left and (1, 1) is the top right. This determines where the camera’s position sits inside the viewport.

When the projection scales due to viewport resizing, the position of the camera, and thereby viewport_origin, remains at the same relative point.

Consequently, this is pivot point when scaling. With a bottom left pivot, the projection will expand upwards and to the right. With a top right pivot, the projection will expand downwards and to the left. Values in between will caused the projection to scale proportionally on each axis.

Defaults to (0.5, 0.5), which makes scaling affect opposite sides equally, keeping the center point of the viewport centered.

How the projection will scale to the viewport.

Defaults to ScalingMode::WindowSize, and works in concert with OrthographicProjection::scale to determine the final effect.

For simplicity, zooming should be done by changing OrthographicProjection::scale, rather than changing the parameters of the scaling mode.

Scales the projection.

As scale increases, the apparent size of objects decreases, and vice versa.

Note: scaling can be set by scaling_mode as well. This parameter scales on top of that.

This property is particularly useful in implementing zoom functionality.

Defaults to 1.0, which under standard settings corresponds to a 1:1 mapping of world units to rendered pixels. See ScalingMode::WindowSize for more information.

The area that the projection covers relative to viewport_origin.

Bevy’s camera_system automatically updates this value when the viewport is resized depending on Orthogr

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct OrthographicProjection {
    pub near: f32,
    pub far: f32,
    pub viewport_origin: Vec2,
    pub scaling_mode: ScalingMode,
    pub scale: f32,
    pub area: Rect,
}
```

Example 2 (javascript):
```javascript
let projection = Projection::Orthographic(OrthographicProjection {
    scaling_mode: ScalingMode::WindowSize,
    scale: 0.01,
    ..OrthographicProjection::default_2d()
});
```

Example 3 (javascript):
```javascript
263fn modify_projection(keys: Res<ButtonInput<KeyCode>>, mut query: Query<&mut Projection>) {
264    for mut projection in &mut query {
265        if keys.just_pressed(KeyCode::KeyO) {
266            match *projection {
267                Projection::Perspective(_) => {
268                    *projection = Projection::Orthographic(OrthographicProjection {
269                        scale: 0.002,
270                        ..OrthographicProjection::default_3d()
271                    });
272                }
273                _ => {
274                    *projection = Projection::Perspective(
...
```

Example 4 (unknown):
```unknown
13fn setup(
14    mut commands: Commands,
15    mut meshes: ResMut<Assets<Mesh>>,
16    mut materials: ResMut<Assets<StandardMaterial>>,
17) {
18    // camera
19    commands.spawn((
20        Camera3d::default(),
21        Projection::from(OrthographicProjection {
22            // 6 world units per pixel of window height.
23            scaling_mode: ScalingMode::FixedVertical {
24                viewport_height: 6.0,
25            },
26            ..OrthographicProjection::default_3d()
27        }),
28        Transform::from_xyz(5.0, 5.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
29    ));
30
31  
...
```

---

## Struct ElasticInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ElasticInCurve.html

**Contents:**
- Struct ElasticInCurve Copy item path
- Trait Implementations§
  - impl Clone for ElasticInCurve
    - fn clone(&self) -> ElasticInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ElasticInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = -2.0^(10.0 * t - 10.0) * sin((t * 10.0 - 10.75) * 2.0 * π / 3.0)

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ElasticInCurve;
```

---

## Attribute Macro bevy_main Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/attr.bevy_main.html

**Contents:**
- Attribute Macro bevy_main Copy item path

Generates the required main function boilerplate for Android.

**Examples:**

Example 1 (unknown):
```unknown
#[bevy_main]
```

---

## Function auto Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.auto.html

**Contents:**
- Function auto Copy item path
      - Examples found in repository?

Returns a Val::Auto where the value is automatically determined based on the context and other Node properties.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn auto() -> Val
```

Example 2 (javascript):
```javascript
154fn setup_image_viewer_scene(
155    mut commands: Commands,
156    mut meshes: ResMut<Assets<Mesh>>,
157    mut materials: ResMut<Assets<StandardMaterial>>,
158    camera_transform: Res<CameraTransform>,
159) {
160    let mut transform = camera_transform.0;
161    transform.translation += *transform.forward();
162
163    // exr/hdr viewer (exr requires enabling bevy feature)
164    commands.spawn((
165        Mesh3d(meshes.add(Rectangle::default())),
166        MeshMaterial3d(materials.add(StandardMaterial {
167            base_color_texture: None,
168            unlit: true,
169           
...
```

Example 3 (unknown):
```unknown
158fn setup_ui(mut commands: Commands) {
159    // Add help text.
160    commands.spawn((
161        Text::new("Click on a button to toggle animations for its associated bones"),
162        Node {
163            position_type: PositionType::Absolute,
164            left: px(12),
165            top: px(12),
166            ..default()
167        },
168    ));
169
170    // Add the buttons that allow the user to toggle mask groups on and off.
171    commands.spawn((
172        Node {
173            flex_direction: FlexDirection::Column,
174            position_type: PositionType::Absolute,
175   
...
```

Example 4 (javascript):
```javascript
139fn spawn_button_row(
140    parent: &mut ChildSpawnerCommands,
141    constraint: Constraint,
142    text_style: (TextFont, TextColor),
143) {
144    let label = match constraint {
145        Constraint::FlexBasis => "flex_basis",
146        Constraint::Width => "size",
147        Constraint::MinWidth => "min_size",
148        Constraint::MaxWidth => "max_size",
149    };
150
151    parent
152        .spawn((
153            Node {
154                flex_direction: FlexDirection::Column,
155                padding: UiRect::all(px(2)),
156                align_items: AlignItems::Stretch,
157
...
```

---

## Struct FixedPreUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FixedPreUpdate.html

**Contents:**
- Struct FixedPreUpdate Copy item path
- Trait Implementations§
  - impl Clone for FixedPreUpdate
    - fn clone(&self) -> FixedPreUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedPreUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedPreUpdate
    - fn default() -> FixedPreUpdate
  - impl Hash for FixedPreUpdate

The schedule that contains logic that must run before FixedUpdate.

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedPreUpdate;
```

---

## Trait EntityMapper Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.EntityMapper.html

**Contents:**
- Trait EntityMapper Copy item path
  - §Example
- Required Methods§
    - fn get_mapped(&mut self, source: Entity) -> Entity
    - fn set_mapped(&mut self, source: Entity, target: Entity)
- Trait Implementations§
  - impl EntityMapper for &mut dyn EntityMapper
    - fn get_mapped(&mut self, source: Entity) -> Entity
    - fn set_mapped(&mut self, source: Entity, target: Entity)
- Implementations on Foreign Types§

An implementor of this trait knows how to map an Entity into another Entity.

Usually this is done by using an EntityHashMap<Entity> to map source entities (mapper inputs) to the current world’s entities (mapper outputs).

More generally, this can be used to map Entity references between any two Worlds.

This is used by MapEntities implementors.

Returns the “target” entity that maps to the given source.

Maps the target entity to the given source. For some implementations this might not actually determine the result of EntityMapper::get_mapped.

**Examples:**

Example 1 (unknown):
```unknown
pub trait EntityMapper {
    // Required methods
    fn get_mapped(&mut self, source: Entity) -> Entity;
    fn set_mapped(&mut self, source: Entity, target: Entity);
}
```

Example 2 (unknown):
```unknown
pub struct SimpleEntityMapper {
  map: EntityHashMap<Entity>,
}

// Example implementation of EntityMapper where we map an entity to another entity if it exists
// in the underlying `EntityHashMap`, otherwise we just return the original entity.
impl EntityMapper for SimpleEntityMapper {
    fn get_mapped(&mut self, entity: Entity) -> Entity {
        self.map.get(&entity).copied().unwrap_or(entity)
    }

    fn set_mapped(&mut self, source: Entity, target: Entity) {
        self.map.insert(source, target);
    }
}
```

---

## Macro info_once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.info_once.html

**Contents:**
- Macro info_once Copy item path

Call info! once per call site.

Useful for logging within systems which are called every frame.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! info_once {
    ($($arg:tt)+) => { ... };
}
```

---

## Struct First Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.First.html

**Contents:**
- Struct First Copy item path
- Trait Implementations§
  - impl Clone for First
    - fn clone(&self) -> First
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for First
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for First
    - fn default() -> First
  - impl Hash for First

Runs first in the schedule.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct First;
```

---

## Struct Spawn Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Spawn.html

**Contents:**
- Struct Spawn Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<R, B> SpawnableList<R> for Spawn<B>where R: Relationship, B: Bundle,
    - fn spawn(this: MovingPtr<'_, Spawn<B>>, world: &mut World, entity: Entity)
    - fn size_hint(&self) -> usize
- Auto Trait Implementations§
  - impl<B> Freeze for Spawn<B>where B: Freeze,
  - impl<B> RefUnwindSafe for Spawn<B>where B: RefUnwindSafe,
  - impl<B> Send for Spawn<B>

A wrapper over a Bundle indicating that an entity should be spawned with that Bundle. This is intended to be used for hierarchical spawning via traits like SpawnableList and SpawnRelated.

Also see the children and related macros that abstract over the Spawn API.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Spawn<B>(pub B)
where
    B: Bundle;
```

Example 2 (javascript):
```javascript
let mut world = World::new();
world.spawn((
    Name::new("Root"),
    Children::spawn((
        Spawn(Name::new("Child1")),
        Spawn((
            Name::new("Child2"),
            Children::spawn(Spawn(Name::new("Grandchild"))),
        ))
    )),
));
```

---

## Struct ParamSet Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ParamSet.html

**Contents:**
- Struct ParamSet Copy item path
- §Examples
- Implementations§
  - impl<'w, 's, P0> ParamSet<'w, 's, (P0,)>where P0: SystemParam,
    - pub fn p0<'a>(&'a mut self) -> <P0 as SystemParam>::Item<'a, 'a>
  - impl<'w, 's, P0, P1> ParamSet<'w, 's, (P0, P1)>where P0: SystemParam, P1: SystemParam,
    - pub fn p0<'a>(&'a mut self) -> <P0 as SystemParam>::Item<'a, 'a>
      - Examples found in repository?
    - pub fn p1<'a>(&'a mut self) -> <P1 as SystemParam>::Item<'a, 'a>
      - Examples found in repository?

A collection of potentially conflicting SystemParams allowed by disjoint access.

Allows systems to safely access and interact with up to 8 mutually exclusive SystemParams, such as two queries that reference the same mutable data or an event reader and writer of the same type.

Each individual SystemParam can be accessed by using the functions p0(), p1(), …, p7(), according to the order they are defined in the ParamSet. This ensures that there’s either only one mutable reference to a parameter at a time or any number of immutable references.

The following system mutably accesses the same component two times, which is not allowed due to rust’s mutability rules.

Conflicting SystemParams like these can be placed in a ParamSet, which leverages the borrow checker to ensure that only one of the contained parameters are accessed at a given time.

Of course, ParamSets can be used with any kind of SystemParam, not just queries.

Gets exclusive access to the parameter at index 0 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 0 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 1 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 0 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 1 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 2 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 0 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 1 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 2 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 3 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 0 in this ParamSet. No other parameters may be accessed while this one is active.

Gets exclusive access to the parameter at index 1 in this ParamSet. No other parameters may be accessed while this one is a

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct ParamSet<'w, 's, T>where
    T: SystemParam,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
// This will panic at runtime when the system gets initialized.
fn bad_system(
    mut enemies: Query<&mut Health, With<Enemy>>,
    mut allies: Query<&mut Health, With<Ally>>,
) {
    // ...
}
```

Example 3 (unknown):
```unknown
// Given the following system
fn fancy_system(
    mut set: ParamSet<(
        Query<&mut Health, With<Enemy>>,
        Query<&mut Health, With<Ally>>,
    )>
) {
    // This will access the first `SystemParam`.
    for mut health in set.p0().iter_mut() {
        // Do your fancy stuff here...
    }

    // The second `SystemParam`.
    // This would fail to compile if the previous parameter was still borrowed.
    for mut health in set.p1().iter_mut() {
        // Do even fancier stuff here...
    }
}
```

Example 4 (javascript):
```javascript
fn message_system(
    mut set: ParamSet<(
        // PROBLEM: `MessageReader` and `MessageWriter` cannot be used together normally,
        // because they both need access to the same message queue.
        // SOLUTION: `ParamSet` allows these conflicting parameters to be used safely
        // by ensuring only one is accessed at a time.
        MessageReader<MyMessage>,
        MessageWriter<MyMessage>,
        // PROBLEM: `&World` needs read access to everything, which conflicts with
        // any mutable access in the same system.
        // SOLUTION: `ParamSet` ensures `&World` is only 
...
```

---

## Function ivec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.ivec2.html

**Contents:**
- Function ivec2 Copy item path

Creates a 2-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn ivec2(x: i32, y: i32) -> IVec2
```

---

## Struct FixedFirst Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FixedFirst.html

**Contents:**
- Struct FixedFirst Copy item path
- Trait Implementations§
  - impl Clone for FixedFirst
    - fn clone(&self) -> FixedFirst
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedFirst
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedFirst
    - fn default() -> FixedFirst
  - impl Hash for FixedFirst

Runs first in the FixedMain schedule.

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedFirst;
```

---

## Function interval Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.interval.html

**Contents:**
- Function interval Copy item path
      - Examples found in repository?

Create an Interval with a given start and end. Alias of Interval::new.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn interval(
    start: f32,
    end: f32,
) -> Result<Interval, InvalidIntervalError>
```

Example 2 (javascript):
```javascript
93    fn create(
94        animation_graphs: &mut Assets<AnimationGraph>,
95        animation_clips: &mut Assets<AnimationClip>,
96    ) -> AnimationInfo {
97        // Create an ID that identifies the text node we're going to animate.
98        let animation_target_name = Name::new("Cube");
99        let animation_target_id = AnimationTargetId::from_name(&animation_target_name);
100
101        // Allocate an animation clip.
102        let mut animation_clip = AnimationClip::default();
103
104        // Each leg of the translation motion should take 3 seconds.
105        let animation_domain =
...
```

---

## Struct ExponentialOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ExponentialOutCurve.html

**Contents:**
- Struct ExponentialOutCurve Copy item path
- Trait Implementations§
  - impl Clone for ExponentialOutCurve
    - fn clone(&self) -> ExponentialOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ExponentialOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) ≈ 1.0 - 2.0^(-10.0 * t)

As with ExponentialIn, the precise definition adjusts it slightly

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ExponentialOutCurve;
```

---

## Struct UiScale Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiScale.html

**Contents:**
- Struct UiScale Copy item path
- Tuple Fields§
- Methods from Deref<Target = f32>§
    - pub const RADIX: u32 = 2u32
    - pub const MANTISSA_DIGITS: u32 = 24u32
    - pub const DIGITS: u32 = 6u32
    - pub const EPSILON: f32 = 1.1920929E-7f32
    - pub const MIN: f32 = -3.40282347E+38f32
    - pub const MIN_POSITIVE: f32 = 1.17549435E-38f32
    - pub const MAX: f32 = 3.40282347E+38f32

The current scale of the UI.

A multiplier to fixed-sized ui values. Note: This will only affect fixed ui values like Val::Px

Returns the ordering between self and other.

Unlike the standard partial comparison between floating point numbers, this comparison always produces an ordering in accordance to the totalOrder predicate as defined in the IEEE 754 (2008 revision) floating point standard. The values are ordered in the following sequence:

The ordering established by this function does not always agree with the PartialOrd and PartialEq implementations of f32. For example, they consider negative and positive zero equal, while total_cmp doesn’t.

The interpretation of the signaling NaN bit follows the definition in the IEEE 754 standard, which may not match the interpretation by some of the older, non-conformant (e.g. MIPS) hardware implementations.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiScale(pub f32);
```

Example 2 (javascript):
```javascript
struct GoodBoy {
    name: String,
    weight: f32,
}

let mut bois = vec![
    GoodBoy { name: "Pucci".to_owned(), weight: 0.1 },
    GoodBoy { name: "Woofer".to_owned(), weight: 99.0 },
    GoodBoy { name: "Yapper".to_owned(), weight: 10.0 },
    GoodBoy { name: "Chonk".to_owned(), weight: f32::INFINITY },
    GoodBoy { name: "Abs. Unit".to_owned(), weight: f32::NAN },
    GoodBoy { name: "Floaty".to_owned(), weight: -5.0 },
];

bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));

// `f32::NAN` could be positive or negative, which will affect the sort order.
if f32::NAN.is_sign_negative() {

...
```

---

## Function resource_added Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_added.html

**Contents:**
- Function resource_added Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the resource of the given type has been added since the condition was last checked.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_added<T>(res: Option<Res<'_, T>>) -> boolwhere
    T: Resource,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_added` will only return true if the
    // given resource was just added
    my_system.run_if(resource_added::<Counter>),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

world.init_resource::<Counter>();

// `Counter` was just added so `my_system` will run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);

// `Counter` was not just added so `my_system` will not run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Struct Dir3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Dir3.html

**Contents:**
- Struct Dir3 Copy item path
- Implementations§
  - impl Dir3
    - pub const X: Dir3
    - pub const Y: Dir3
    - pub const Z: Dir3
    - pub const NEG_X: Dir3
    - pub const NEG_Y: Dir3
    - pub const NEG_Z: Dir3
    - pub const AXES: [Dir3; 3]

A normalized vector pointing in a direction in 3D space

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

The directional axes.

Create a direction from a finite, nonzero Vec3, normalizing it.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Create a Dir3 from a Vec3 that is already normalized.

value must be normalized, i.e its length must be 1.0.

Create a direction from a finite, nonzero Vec3, normalizing it and also returning its original length.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Create a direction from its x, y, and z components.

Returns Err(InvalidDirectionError) if the length of the vector formed by the components is zero (or very close to zero), infinite, or NaN.

Create a direction from its x, y, and z components, assuming the resulting vector is normalized.

The vector produced from x, y, and z must be normalized, i.e its length must be 1.0.

Returns the inner Vec3

Performs a spherical linear interpolation between self and rhs based on the value s.

This corresponds to interpolating between the two directions at a constant angular velocity.

When s == 0.0, the result will be equal to self. When s == 1.0, the result will be equal to rhs.

Returns self after an approximate normalization, assuming the value is already nearly normalized. Useful for preventing numerical error accumulation.

The following seemingly benign code would start accumulating errors over time, leading to dir eventually not being normalized anymore.

Instead, do the following.

Converts self to [x, y, z]

Moves towards rhs based on the value d.

When d is 0.0, the result will be equal to self. When d is equal to self.distance(rhs), the result will be equal to rhs. Will not go past rhs.

Returns some vector that is orthogonal to the given one.

The input vector must be finite and non-zero.

The output vector is not necessarily unit length. For that use Self::any_orthonormal_vector() instead.

Returns any unit vector that is orthogonal to the given one.

The input vector must be unit length.

Will panic if self is not normalized when glam_assert is enabled.

Given a u

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Dir3(/* private fields */);
```

Example 2 (javascript):
```javascript
23fn bouncing_raycast(
24    mut ray_cast: MeshRayCast,
25    mut gizmos: Gizmos,
26    time: Res<Time>,
27    // The ray map stores rays cast by the cursor
28    ray_map: Res<RayMap>,
29) {
30    // Cast an automatically moving ray and bounce it off of surfaces
31    let t = ops::cos((time.elapsed_secs() - 4.0).max(0.0) * LASER_SPEED) * PI;
32    let ray_pos = Vec3::new(ops::sin(t), ops::cos(3.0 * t) * 0.5, ops::cos(t)) * 0.5;
33    let ray_dir = Dir3::new(-ray_pos).unwrap();
34    let ray = Ray3d::new(ray_pos, ray_dir);
35    gizmos.sphere(ray_pos, 0.1, Color::WHITE);
36    bounce_ray(ray, &
...
```

Example 3 (javascript):
```javascript
92fn move_target(
93    mut target: Single<&mut Transform, With<TargetSphere>>,
94    target_speed: Res<TargetSphereSpeed>,
95    mut target_pos: ResMut<TargetPosition>,
96    time: Res<Time>,
97    mut rng: ResMut<RandomSource>,
98) {
99    match Dir3::new(target_pos.0 - target.translation) {
100        // The target and the present position of the target sphere are far enough to have a well-
101        // defined direction between them, so let's move closer:
102        Ok(dir) => {
103            let delta_time = time.delta_secs();
104            let abs_delta = (target_pos.0 - target.transl
...
```

Example 4 (javascript):
```javascript
13fn draw_cursor(
14    camera_query: Single<(&Camera, &GlobalTransform)>,
15    ground: Single<&GlobalTransform, With<Ground>>,
16    window: Single<&Window>,
17    mut gizmos: Gizmos,
18) {
19    let (camera, camera_transform) = *camera_query;
20
21    if let Some(cursor_position) = window.cursor_position()
22        // Calculate a ray pointing from the camera into the world based on the cursor's position.
23        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
24        // Calculate if and at what distance the ray is hitting the ground plane.
25        && let 
...
```

---

## Module tonemapping Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/core_pipeline/tonemapping/index.html

**Contents:**
- Module tonemapping Copy item path
- Structs§
- Enums§
- Functions§

bevy::core_pipelineModule tonemapping Copy item pathSource Structs§TonemappingLuts3D LUT (look up table) textures used for tonemappingTonemappingNodeTonemappingPipelineTonemappingPipelineKeyTonemappingPipelineKeyFlagsVarious flags describing what tonemapping needs to do.TonemappingPluginViewTonemappingPipelineEnums§DebandDitherEnables a debanding shader that applies dithering to mitigate color banding in the final image for a given Camera entity.TonemappingOptionally enables a tonemapping shader that attempts to map linear input stimulus into a perceptually uniform image for a given Camera entity.Functions§get_lut_bind_group_layout_entriesget_lut_bindingsinit_tonemapping_pipelinelut_placeholderprepare_view_tonemapping_pipelines

---

## Enum AppExit Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AppExit.html

**Contents:**
- Enum AppExit Copy item path
- §Portability
- Variants§
  - Success
  - Error(NonZero<u8>)
- Implementations§
  - impl AppExit
    - pub const fn error() -> AppExit
      - Examples found in repository?
    - pub const fn is_success(&self) -> bool

A Message that indicates the App should exit. If one or more of these are present at the end of an update, the runner will end and (maybe) return control to the caller.

This message can be used to detect when an exit is requested. Make sure that systems listening for this message run before the current update ends.

This type is roughly meant to map to a standard definition of a process exit code (0 means success, not 0 means error). Due to portability concerns (see ExitCode and process::exit) we only allow error codes between 1 and 255.

App exited without any problems.

The App experienced an unhandleable error. Holds the exit code we expect our app to return.

Creates a AppExit::Error with an error code of 1.

Returns true if self is a AppExit::Success.

Returns true if self is a AppExit::Error.

Creates a AppExit from a code.

When code is 0 a AppExit::Success is constructed otherwise a AppExit::Error is constructed.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AppExit {
    Success,
    Error(NonZero<u8>),
}
```

Example 2 (unknown):
```unknown
154fn setup(
155    mut commands: Commands,
156    asset_server: Res<AssetServer>,
157    app_status: Res<AppStatus>,
158    render_device: Res<RenderDevice>,
159    render_adapter: Res<RenderAdapter>,
160    mut meshes: ResMut<Assets<Mesh>>,
161    mut materials: ResMut<Assets<ExtendedMaterial<StandardMaterial, CustomDecalExtension>>>,
162) {
163    // Error out if clustered decals aren't supported on the current platform.
164    if !decal::clustered::clustered_decals_are_usable(&render_device, &render_adapter) {
165        error!("Clustered decals aren't usable on this platform.");
166      
...
```

Example 3 (unknown):
```unknown
143fn setup(
144    mut commands: Commands,
145    asset_server: Res<AssetServer>,
146    app_status: Res<AppStatus>,
147    render_device: Res<RenderDevice>,
148    render_adapter: Res<RenderAdapter>,
149    mut meshes: ResMut<Assets<Mesh>>,
150    mut materials: ResMut<Assets<StandardMaterial>>,
151) {
152    // Error out if clustered decals (and so light textures) aren't supported on the current platform.
153    if !decal::clustered::clustered_decals_are_usable(&render_device, &render_adapter) {
154        error!("Light textures aren't usable on this platform.");
155        commands.write_m
...
```

---

## Module vec Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/vec/index.html

**Contents:**
- Module vec Copy item path
- §Examples
- §Memory layout
- Structs§

A contiguous growable array type with heap-allocated contents, written Vec<T>.

Vectors have O(1) indexing, amortized O(1) push (to the end) and O(1) pop (from the end).

Vectors ensure they never allocate more than isize::MAX bytes.

You can explicitly create a Vec with Vec::new:

…or by using the vec! macro:

You can push values onto the end of a vector (which will grow the vector as needed):

Popping values works in much the same way:

Vectors also support indexing (through the Index and IndexMut traits):

When the type is non-zero-sized and the capacity is nonzero, Vec uses the Global allocator for its allocation. It is valid to convert both ways between such a Vec and a raw pointer allocated with the Global allocator, provided that the Layout used with the allocator is correct for a sequence of capacity elements of the type, and the first len values pointed to by the raw pointer are valid. More precisely, a ptr: *mut T that has been allocated with the Global allocator with Layout::array::<T>(capacity) may be converted into a vec using Vec::<T>::from_raw_parts(ptr, len, capacity). Conversely, the memory backing a value: *mut T obtained from Vec::<T>::as_mut_ptr may be deallocated using the Global allocator with the same layout.

For zero-sized types (ZSTs), or when the capacity is zero, the Vec pointer must be non-null and sufficiently aligned. The recommended way to build a Vec of ZSTs if vec! cannot be used is to use ptr::NonNull::dangling.

**Examples:**

Example 1 (javascript):
```javascript
let v: Vec<i32> = Vec::new();
```

Example 2 (javascript):
```javascript
let v: Vec<i32> = vec![];

let v = vec![1, 2, 3, 4, 5];

let v = vec![0; 10]; // ten zeroes
```

Example 3 (javascript):
```javascript
let mut v = vec![1, 2];

v.push(3);
```

Example 4 (javascript):
```javascript
let mut v = vec![1, 2];

let two = v.pop();
```

---

## Trait StateScopedMessagesAppExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.StateScopedMessagesAppExt.html

**Contents:**
- Trait StateScopedMessagesAppExt Copy item path
- Required Methods§
    - fn clear_messages_on_exit<M>(&mut self, state: impl States) -> &mut Selfwhere M: Message,
    - fn clear_messages_on_enter<M>(&mut self, state: impl States) -> &mut Selfwhere M: Message,
- Dyn Compatibility§
- Implementors§
  - impl StateScopedMessagesAppExt for App
  - impl StateScopedMessagesAppExt for SubApp

Extension trait for App adding methods for registering state scoped messages.

Clears a Message when exiting the specified state.

Note that message cleanup is ambiguously ordered relative to DespawnOnExit entity cleanup, and the OnExit schedule for the target state. All of these (state scoped entities and messages cleanup, and OnExit) occur within schedule StateTransition and system set StateTransitionSystems::ExitSchedules.

Clears a Message when entering the specified state.

Note that message cleanup is ambiguously ordered relative to DespawnOnEnter entity cleanup, and the OnEnter schedule for the target state. All of these (state scoped entities and messages cleanup, and OnEnter) occur within schedule StateTransition and system set StateTransitionSystems::EnterSchedules.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait StateScopedMessagesAppExt {
    // Required methods
    fn clear_messages_on_exit<M>(&mut self, state: impl States) -> &mut Self
       where M: Message;
    fn clear_messages_on_enter<M>(&mut self, state: impl States) -> &mut Self
       where M: Message;
}
```

---

## Function vec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vec3.html

**Contents:**
- Function vec3 Copy item path
      - Examples found in repository?

Creates a 3-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn vec3(x: f32, y: f32, z: f32) -> Vec3
```

Example 2 (javascript):
```javascript
15const CAMERA_FOCAL_POINT: Vec3 = vec3(0.0, 0.3, 0.0);
```

Example 3 (javascript):
```javascript
14const CAMERA_INITIAL_POSITION: Vec3 = vec3(-0.4, 0.0, 0.0);
15
16/// The current settings of the app, as chosen by the user.
17#[derive(Resource)]
18struct AppStatus {
19    /// Which type of light is in the scene.
20    light_mode: LightMode,
21    /// Whether anisotropy is enabled.
22    anisotropy_enabled: bool,
23    /// Which mesh is visible
24    visible_scene: Scene,
25}
26
27/// Which type of light we're using: a directional light, a point light, or an
28/// environment map.
29#[derive(Clone, Copy, PartialEq, Default)]
30enum LightMode {
31    /// A rotating directional light.
32    
...
```

Example 4 (javascript):
```javascript
115const INITIAL_SPHERE_POSITION: Vec3 = vec3(0.0, 0.5233223, 0.0);
116
117fn main() {
118    App::new()
119        .add_plugins(DefaultPlugins.set(WindowPlugin {
120            primary_window: Some(Window {
121                title: "Bevy Mixed Lighting Example".into(),
122                ..default()
123            }),
124            ..default()
125        }))
126        .add_plugins(MeshPickingPlugin)
127        .insert_resource(AmbientLight {
128            color: ClearColor::default().0,
129            brightness: 10000.0,
130            affects_lightmapped_meshes: true,
131        })
132 
...
```

---

## Trait ToOwned Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ToOwned.html

**Contents:**
- Trait ToOwned Copy item path
- Required Associated Types§
    - type Owned: Borrow<Self>
- Required Methods§
    - fn to_owned(&self) -> Self::Owned
      - §Examples
- Provided Methods§
    - fn clone_into(&self, target: &mut Self::Owned)
      - §Examples
- Dyn Compatibility§

A generalization of Clone to borrowed data.

Some types make it possible to go from borrowed to owned, usually by implementing the Clone trait. But Clone works only for going from &T to T. The ToOwned trait generalizes Clone to construct owned data from any borrow of a given type.

The resulting type after obtaining ownership.

Creates owned data from borrowed data, usually by cloning.

Uses borrowed data to replace owned data, usually by cloning.

This is borrow-generalized version of Clone::clone_from.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ToOwned {
    type Owned: Borrow<Self>;

    // Required method
    fn to_owned(&self) -> Self::Owned;

    // Provided method
    fn clone_into(&self, target: &mut Self::Owned) { ... }
}
```

Example 2 (javascript):
```javascript
let s: &str = "a";
let ss: String = s.to_owned();

let v: &[i32] = &[1, 2];
let vv: Vec<i32> = v.to_owned();
```

Example 3 (javascript):
```javascript
let mut s: String = String::new();
"hello".clone_into(&mut s);

let mut v: Vec<i32> = Vec::new();
[1, 2][..].clone_into(&mut v);
```

---

## Trait IntoScheduleConfigs Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.IntoScheduleConfigs.html

**Contents:**
- Trait IntoScheduleConfigs Copy item path
- §Usage notes
- §Examples
- Required Methods§
    - fn into_configs(self) -> ScheduleConfigs<T>
- Provided Methods§
    - fn in_set(self, set: impl SystemSet) -> ScheduleConfigs<T>
      - Examples found in repository?
    - fn before<M>(self, set: impl IntoSystemSet<M>) -> ScheduleConfigs<T>
      - Examples found in repository?

Types that can convert into a ScheduleConfigs.

This trait is implemented for “systems” (functions whose arguments all implement SystemParam), or tuples thereof. It is a common entry point for system configurations.

This trait should only be used as a bound for trait implementations or as an argument to a function. If system configs need to be returned from a function or stored somewhere, use ScheduleConfigs instead of this trait.

Convert into a ScheduleConfigs.

Add these systems to the provided set.

Runs before all systems in set. If self has any systems that produce Commands or other Deferred operations, all systems in set will see their effect.

If automatically inserting ApplyDeferred like this isn’t desired, use before_ignore_deferred instead.

Calling .chain is often more convenient and ensures that all systems are added to the schedule. Please check the caveats section of .after for details.

Run after all systems in set. If set has any systems that produce Commands or other Deferred operations, all systems in self will see their effect.

If automatically inserting ApplyDeferred like this isn’t desired, use after_ignore_deferred instead.

Calling .chain is often more convenient and ensures that all systems are added to the schedule.

If you configure two Systems like (GameSystem::A).after(GameSystem::B) or (GameSystem::A).before(GameSystem::B), the GameSystem::B will not be automatically scheduled.

This means that the system GameSystem::A and the system or systems in GameSystem::B will run independently of each other if GameSystem::B was never explicitly scheduled with configure_sets If that is the case, .after/.before will not provide the desired behavior and the systems can run in parallel or in any order determined by the scheduler. Only use after(GameSystem::B) and before(GameSystem::B) when you know that B has already been scheduled for you, e.g. when it was provided by Bevy or a third-party dependency, or you manually scheduled it somewhere else in your app.

Another caveat is that if GameSystem::B is placed in a different schedule than GameSystem::A, any ordering calls between them—whether using .before, .after, or .chain—will be silently ignored.

Run before all systems in set.

Unlike before, this will not cause the systems in set to wait for the deferred effects of self to be applied.

Run after all systems in set.

Unlike after, this will not wait for the deferred effects of systems in set to be applied.

Add a run condition to each 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait IntoScheduleConfigs<T, Marker>: Sizedwhere
    T: Schedulable<Metadata = GraphInfo, GroupMetadata = Chain>,{
    // Required method
    fn into_configs(self) -> ScheduleConfigs<T>;

    // Provided methods
    fn in_set(self, set: impl SystemSet) -> ScheduleConfigs<T> { ... }
    fn before<M>(self, set: impl IntoSystemSet<M>) -> ScheduleConfigs<T> { ... }
    fn after<M>(self, set: impl IntoSystemSet<M>) -> ScheduleConfigs<T> { ... }
    fn before_ignore_deferred<M>(
        self,
        set: impl IntoSystemSet<M>,
    ) -> ScheduleConfigs<T> { ... }
    fn after_ignore_deferred<M>(
...
```

Example 2 (unknown):
```unknown
fn handle_input() {}

fn update_camera() {}
fn update_character() {}

app.add_systems(
    Update,
    (
        handle_input,
        (update_camera, update_character).after(handle_input)
    )
);
```

Example 3 (unknown):
```unknown
22fn main() {
23    App::new()
24        .add_plugins(DefaultPlugins)
25        .add_systems(Startup, setup)
26        .add_systems(Update, rotator_system)
27        .add_systems(First, drive_diegetic_pointer.in_set(PickingSystems::Input))
28        .run();
29}
```

Example 4 (javascript):
```javascript
153    fn build(&self, app: &mut App) {
154        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
155            return;
156        };
157
158        render_app.add_systems(
159            Render,
160            print_visible_light_count.in_set(RenderSystems::Prepare),
161        );
162    }
```

---

## Struct ImagePlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ImagePlugin.html

**Contents:**
- Struct ImagePlugin Copy item path
- Fields§
- Implementations§
  - impl ImagePlugin
    - pub fn default_linear() -> ImagePlugin
    - pub fn default_nearest() -> ImagePlugin
      - Examples found in repository?
- Trait Implementations§
  - impl Default for ImagePlugin
    - fn default() -> ImagePlugin

Adds the Image as an asset and makes sure that they are extracted and prepared for the GPU.

The default image sampler to use when ImageSampler is set to Default.

Creates image settings with linear sampling by default.

Creates image settings with nearest sampling by default.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ImagePlugin {
    pub default_sampler: ImageSamplerDescriptor,
}
```

Example 2 (unknown):
```unknown
6fn main() {
7    App::new()
8        .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest())) // prevents blurry sprites
9        .add_systems(Startup, setup)
10        .add_systems(Update, animate_sprite)
11        .run();
12}
```

Example 3 (unknown):
```unknown
7fn main() {
8    App::new()
9        .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest()))
10        .add_systems(Startup, (setup, setup_atlas))
11        .add_systems(Update, (move_sprite, animate_sprite))
12        .run();
13}
```

Example 4 (unknown):
```unknown
27fn main() {
28    App::new()
29        .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest()))
30        .add_systems(Startup, (setup_camera, setup_sprite, setup_mesh))
31        .add_systems(Update, (rotate, fit_canvas))
32        .run();
33}
```

---

## Function expire_completed_transitions Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.expire_completed_transitions.html

**Contents:**
- Function expire_completed_transitions Copy item path

A system that removed transitions that have completed from the AnimationTransitions object.

**Examples:**

Example 1 (unknown):
```unknown
pub fn expire_completed_transitions(
    query: Query<'_, '_, (&mut AnimationTransitions, &mut AnimationPlayer)>,
)
```

---

## Enum EulerRot Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.EulerRot.html

**Contents:**
- Enum EulerRot Copy item path
- Variants§
  - ZYX
  - ZXY
  - YXZ
  - YZX
  - XYZ
  - XZY
  - ZYZ
  - ZXZ

Euler rotation sequences.

The three elemental rotations may be extrinsic (rotations about the axes xyz of the original coordinate system, which is assumed to remain motionless), or intrinsic (rotations about the axes of the rotating coordinate system XYZ, solidary with the moving body, which changes its orientation after each elemental rotation).

Intrinsic three-axis rotation ZYX

Intrinsic three-axis rotation ZXY

Intrinsic three-axis rotation YXZ

Intrinsic three-axis rotation YZX

Intrinsic three-axis rotation XYZ

Intrinsic three-axis rotation XZY

Intrinsic two-axis rotation ZYZ

Intrinsic two-axis rotation ZXZ

Intrinsic two-axis rotation YXY

Intrinsic two-axis rotation YZY

Intrinsic two-axis rotation XYX

Intrinsic two-axis rotation XZX

Extrinsic three-axis rotation ZYX

Extrinsic three-axis rotation ZXY

Extrinsic three-axis rotation YXZ

Extrinsic three-axis rotation YZX

Extrinsic three-axis rotation XYZ

Extrinsic three-axis rotation XZY

Extrinsic two-axis rotation ZYZ

Extrinsic two-axis rotation ZXZ

Extrinsic two-axis rotation YXY

Extrinsic two-axis rotation YZY

Extrinsic two-axis rotation XYX

Extrinsic two-axis rotation XZX

Default YXZ as yaw (y-axis), pitch (x-axis), roll (z-axis).

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum EulerRot {
Show 24 variants    ZYX,
    ZXY,
    YXZ,
    YZX,
    XYZ,
    XZY,
    ZYZ,
    ZXZ,
    YXY,
    YZY,
    XYX,
    XZX,
    ZYXEx,
    ZXYEx,
    YXZEx,
    YZXEx,
    XYZEx,
    XZYEx,
    ZYZEx,
    ZXZEx,
    YXYEx,
    YZYEx,
    XYXEx,
    XZXEx,
}
```

Example 2 (javascript):
```javascript
let m_intrinsic = Mat3::from_rotation_x(i) * Mat3::from_rotation_y(j) * Mat3::from_rotation_z(k);
let n_intrinsic = Mat3::from_euler(EulerRot::XYZ, i, j, k);
assert!(m_intrinsic.abs_diff_eq(n_intrinsic, 2e-6));

let m_extrinsic = Mat3::from_rotation_z(k) * Mat3::from_rotation_y(j) * Mat3::from_rotation_x(i);
let n_extrinsic = Mat3::from_euler(EulerRot::XYZEx, i, j, k);
assert!(m_extrinsic.abs_diff_eq(n_extrinsic, 2e-6));
```

---

## Type Alias EventWriter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.EventWriter.html

**Contents:**
- Type Alias EventWriter Copy item path
- Aliased Type§

This is deprecated. See MessageWriter

**Examples:**

Example 1 (unknown):
```unknown
pub type EventWriter<'w, E> = MessageWriter<'w, E>;
```

Example 2 (unknown):
```unknown
pub struct EventWriter<'w, E> { /* private fields */ }
```

---

## Struct EasingCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EasingCurve.html

**Contents:**
- Struct EasingCurve Copy item path
- §Example
- Implementations§
  - impl<T> EasingCurve<T>
    - pub fn new(start: T, end: T, ease_fn: EaseFunction) -> EasingCurve<T>
      - Examples found in repository?
- Trait Implementations§
  - impl<T> Clone for EasingCurve<T>where T: Clone,
    - fn clone(&self) -> EasingCurve<T>
    - fn clone_from(&mut self, source: &Self)

A Curve that is defined by

The resulting curve’s domain is always the unit interval.

Create a linear curve that interpolates between 2.0 and 4.0.

sample the curve at various points. This will return None if the parameter is outside the unit interval.

sample_clamped will clamp the parameter to the unit interval, so it always returns a value.

EasingCurve can be used with any type that implements the Ease trait. This includes many math types, like vectors and rotations.

As a shortcut, an EasingCurve between 0.0 and 1.0 can be replaced by EaseFunction.

Given a start and end value, create a curve parametrized over the unit interval that connects them, using the given ease function to determine the form of the curve in between.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct EasingCurve<T> { /* private fields */ }
```

Example 2 (javascript):
```javascript
let c = EasingCurve::new(2.0, 4.0, EaseFunction::Linear);
```

Example 3 (unknown):
```unknown
assert_eq!(c.sample(-1.0), None);
assert_eq!(c.sample(0.0), Some(2.0));
assert_eq!(c.sample(0.5), Some(3.0));
assert_eq!(c.sample(1.0), Some(4.0));
assert_eq!(c.sample(2.0), None);
```

Example 4 (unknown):
```unknown
assert_eq!(c.sample_clamped(-1.0), 2.0);
assert_eq!(c.sample_clamped(0.0), 2.0);
assert_eq!(c.sample_clamped(0.5), 3.0);
assert_eq!(c.sample_clamped(1.0), 4.0);
assert_eq!(c.sample_clamped(2.0), 4.0);
```

---

## Derive Macro EntityEvent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.EntityEvent.html

**Contents:**
- Derive Macro EntityEvent Copy item path

Cheat sheet for derive syntax, see full explanation on EntityEvent trait docs.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(EntityEvent)]
{
    // Attributes available to this derive:
    #[entity_event]
    #[event_target]
}
```

Example 2 (unknown):
```unknown
#[derive(EntityEvent)]
/// Enable propagation, which defaults to using the ChildOf component
#[entity_event(propagate)]
/// Enable propagation using the given Traversal implementation
#[entity_event(propagate = &'static ChildOf)]
/// Always propagate
#[entity_event(auto_propagate)]
struct MyEvent;
```

---

## Trait Vec4Swizzles Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Vec4Swizzles.html

**Contents:**
- Trait Vec4Swizzles Copy item path
- Required Associated Types§
    - type Vec2
    - type Vec3
- Required Methods§
    - fn xx(self) -> Self::Vec2
    - fn xy(self) -> Self::Vec2
    - fn with_xy(self, rhs: Self::Vec2) -> Self
    - fn xz(self) -> Self::Vec2
    - fn with_xz(self, rhs: Self::Vec2) -> Self

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Vec4Swizzles:
    Sized
    + Copy
    + Clone {
    type Vec2;
    type Vec3;

Show 372 methods    // Required methods
    fn xx(self) -> Self::Vec2;
    fn xy(self) -> Self::Vec2;
    fn with_xy(self, rhs: Self::Vec2) -> Self;
    fn xz(self) -> Self::Vec2;
    fn with_xz(self, rhs: Self::Vec2) -> Self;
    fn xw(self) -> Self::Vec2;
    fn with_xw(self, rhs: Self::Vec2) -> Self;
    fn yx(self) -> Self::Vec2;
    fn with_yx(self, rhs: Self::Vec2) -> Self;
    fn yy(self) -> Self::Vec2;
    fn yz(self) -> Self::Vec2;
    fn with_yz(self, rhs: Self::Vec2) -> Self;
    fn yw(self) ->
...
```

---

## Struct SpritePickingSettings Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpritePickingSettings.html

**Contents:**
- Struct SpritePickingSettings Copy item path
- Fields§
- Trait Implementations§
  - impl Default for SpritePickingSettings
    - fn default() -> SpritePickingSettings
  - impl FromArg for SpritePickingSettings
    - type This<'from_arg> = SpritePickingSettings
    - fn from_arg( arg: Arg<'_>, ) -> Result<<SpritePickingSettings as FromArg>::This<'_>, ArgError>
  - impl FromReflect for SpritePickingSettings
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<SpritePickingSettings>

Runtime settings for the SpritePickingPlugin.

When set to true sprite picking will only consider cameras marked with SpritePickingCamera. Defaults to false. Regardless of this setting, only sprites marked with Pickable will be considered.

This setting is provided to give you fine-grained control over which cameras should be used by the sprite picking backend at runtime.

Should the backend count transparent pixels as part of the sprite for picking purposes or should it use the bounding box of the sprite alone.

Defaults to an inclusive alpha threshold of 0.1

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpritePickingSettings {
    pub require_markers: bool,
    pub picking_mode: SpritePickingMode,
}
```

---

## Trait ReadOnlySystem Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ReadOnlySystem.html

**Contents:**
- Trait ReadOnlySystem Copy item path
- §Safety
- Provided Methods§
    - fn run_readonly( &mut self, input: <Self::In as SystemInput>::Inner<'_>, world: &World, ) -> Result<Self::Out, RunSystemError>
- Implementors§
  - impl<A, B> ReadOnlySystem for PipeSystem<A, B>where A: ReadOnlySystem, B: ReadOnlySystem, <B as System>::In: for<'a> SystemInput<Inner<'a> = <A as System>::Out>,
  - impl<Func, A, B> ReadOnlySystem for CombinatorSystem<Func, A, B>where Func: Combine<A, B> + 'static, A: ReadOnlySystem, B: ReadOnlySystem,
  - impl<Func, S> ReadOnlySystem for AdapterSystem<Func, S>where Func: Adapt<S>, S: ReadOnlySystem,
  - impl<Marker, Out, F> ReadOnlySystem for FunctionSystem<Marker, Out, F>where Marker: 'static, Out: 'static, F: SystemParamFunction<Marker>, <F as SystemParamFunction<Marker>>::Out: IntoResult<Out>, <F as SystemParamFunction<Marker>>::Param: ReadOnlySystemParam,

System types that do not modify the World when run. This is implemented for any systems whose parameters all implement ReadOnlySystemParam.

Note that systems which perform deferred mutations (such as with Commands) may implement this trait.

This must only be implemented for system types which do not mutate the World when System::run_unsafe is called.

Runs this system with the given input in the world.

Unlike System::run, this can be called with a shared reference to the world, since this system is known not to modify the world.

SAFETY: Both systems are read-only, so any system created by piping them will only read from the world.

SAFETY: Both systems are read-only, so any system created by combining them will only read from the world.

SAFETY: F’s param is ReadOnlySystemParam, so this system will only read from the world.

**Examples:**

Example 1 (unknown):
```unknown
pub unsafe trait ReadOnlySystem: System {
    // Provided method
    fn run_readonly(
        &mut self,
        input: <Self::In as SystemInput>::Inner<'_>,
        world: &World,
    ) -> Result<Self::Out, RunSystemError> { ... }
}
```

---

## Struct Hwba Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Hwba.html

**Contents:**
- Struct Hwba Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Hwba
    - pub const fn new(hue: f32, whiteness: f32, blackness: f32, alpha: f32) -> Hwba
      - §Arguments
    - pub const fn hwb(hue: f32, whiteness: f32, blackness: f32) -> Hwba
      - §Arguments
    - pub const fn with_whiteness(self, whiteness: f32) -> Hwba

Color in Hue-Whiteness-Blackness (HWB) color space with alpha. Further information on this color model can be found on Wikipedia.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The hue channel. [0.0, 360.0]

The whiteness channel. [0.0, 1.0]

The blackness channel. [0.0, 1.0]

The alpha channel. [0.0, 1.0]

Construct a new Hwba color from components.

Construct a new Hwba color from (h, s, l) components, with the default alpha (1.0).

Return a copy of this color with the whiteness channel set to the given value.

Return a copy of this color with the blackness channel set to the given value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Hwba {
    pub hue: f32,
    pub whiteness: f32,
    pub blackness: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

---

## Trait Mix Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Mix.html

**Contents:**
- Trait Mix Copy item path
- Required Methods§
    - fn mix(&self, other: &Self, factor: f32) -> Self
- Provided Methods§
    - fn mix_assign(&mut self, other: Self, factor: f32)
- Dyn Compatibility§
- Implementors§
  - impl Mix for Color
  - impl Mix for Hsla
  - impl Mix for Hsva

Linear interpolation of two colors within a given color space.

Linearly interpolate between this and another color, by factor. Factor should be between 0.0 and 1.0.

Linearly interpolate between this and another color, by factor, storing the result in this color. Factor should be between 0.0 and 1.0.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Mix: Sized {
    // Required method
    fn mix(&self, other: &Self, factor: f32) -> Self;

    // Provided method
    fn mix_assign(&mut self, other: Self, factor: f32) { ... }
}
```

---

## Enum HexColorError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.HexColorError.html

**Contents:**
- Enum HexColorError Copy item path
- Variants§
  - Parse(ParseIntError)
  - Length
  - Char(char)
- Trait Implementations§
  - impl Debug for HexColorError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for HexColorError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>

Error returned if a hex string could not be parsed as a color.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum HexColorError {
    Parse(ParseIntError),
    Length,
    Char(char),
}
```

---

## Struct Or Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Or.html

**Contents:**
- Struct Or Copy item path
- §Examples
- Trait Implementations§
  - impl QueryFilter for Or<()>
    - const IS_ARCHETYPAL: bool = true
    - unsafe fn filter_fetch( state: &<Or<()> as WorldQuery>::State, fetch: &mut <Or<()> as WorldQuery>::Fetch<'_>, entity: Entity, table_row: TableRow, ) -> bool
  - impl<F> QueryFilter for Or<(F₁, F₂, …, Fₙ)>where F: QueryFilter,
    - const IS_ARCHETYPAL: bool
    - unsafe fn filter_fetch( state: &<Or<(F,)> as WorldQuery>::State, fetch: &mut <Or<(F,)> as WorldQuery>::Fetch<'_>, entity: Entity, table_row: TableRow, ) -> bool
  - impl WorldQuery for Or<()>

A filter that tests if any of the given filters apply.

This is useful for example if a system with multiple components in a query only wants to run when one or more of the components have changed.

The And equivalent to this filter is a tuple testing that all the contained filters apply instead.

This trait is implemented for tuples up to 16 items long.

SAFETY: QueryFilter::filter_fetch accesses are a subset of the subqueries’ accesses This is sound because update_component_access adds accesses according to the implementations of all the subqueries. update_component_access replace the filters with a disjunction where every element is a conjunction of the previous filters and the filters of one of the subqueries. This is sound because matches_component_set returns a disjunction of the results of the subqueries’ implementations.

This trait is implemented for tuples up to 16 items long. SAFETY: QueryFilter::filter_fetch accesses are a subset of the subqueries’ accesses This is sound because update_component_access adds accesses according to the implementations of all the subqueries. update_component_access replace the filters with a disjunction where every element is a conjunction of the previous filters and the filters of one of the subqueries. This is sound because matches_component_set returns a disjunction of the results of the subqueries’ implementations.

This trait is implemented for tuples up to 16 items long.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Or<T>(/* private fields */);
```

Example 2 (unknown):
```unknown
fn print_cool_entity_system(query: Query<Entity, Or<(Changed<Color>, Changed<Node>)>>) {
    for entity in &query {
        println!("Entity {} got a new style or color", entity);
    }
}
```

---

## Macro info_span Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.info_span.html

**Contents:**
- Macro info_span Copy item path
- §Examples

Constructs a span at the info level.

Fields and attributes are set using the same syntax as the span! macro.

See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! info_span {
    (target: $target:expr, parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, parent: $parent:expr, $name:expr) => { ... };
    (parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (parent: $parent:expr, $name:expr) => { ... };
    (target: $target:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, $name:expr) => { ... };
    ($name:expr, $($field:tt)*) => { ... };
    ($name:expr) => { ... };
}
```

Example 2 (unknown):
```unknown
info_span!("my_span");
// is equivalent to:
span!(Level::INFO, "my_span");
```

Example 3 (javascript):
```javascript
let span = info_span!("my span");
span.in_scope(|| {
    // do work inside the span...
});
```

---

## Type Alias TextUiWriter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.TextUiWriter.html

**Contents:**
- Type Alias TextUiWriter Copy item path
- Aliased Type§

UI alias for TextWriter.

**Examples:**

Example 1 (unknown):
```unknown
pub type TextUiWriter<'w, 's> = TextWriter<'w, 's, Text>;
```

Example 2 (unknown):
```unknown
pub struct TextUiWriter<'w, 's> { /* private fields */ }
```

---

## Struct EnvironmentMapLight Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EnvironmentMapLight.html

**Contents:**
- Struct EnvironmentMapLight Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for EnvironmentMapLight
    - fn clone(&self) -> EnvironmentMapLight
    - fn clone_from(&mut self, source: &Self)
  - impl Component for EnvironmentMapLightwhere EnvironmentMapLight: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

A pair of cubemap textures that represent the surroundings of a specific area in space.

See bevy_pbr::environment_map for detailed information.

The blurry image that represents diffuse radiance surrounding a region.

The typically-sharper, mipmapped image that represents specular radiance surrounding a region.

Scale factor applied to the diffuse and specular light generated by this component.

After applying this multiplier, the resulting values should be in units of cd/m^2.

See also https://google.github.io/filament/Filament.html#lighting/imagebasedlights/iblunit.

World space rotation applied to the environment light cubemaps. This is useful for users who require a different axis, such as the Z-axis, to serve as the vertical axis.

Whether the light from this environment map contributes diffuse lighting to meshes with lightmaps.

Set this to false if your lightmap baking tool bakes the diffuse light from this environment light into the lightmaps in order to avoid counting the radiance from this environment map twice.

By default, this is set to true.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct EnvironmentMapLight {
    pub diffuse_map: Handle<Image>,
    pub specular_map: Handle<Image>,
    pub intensity: f32,
    pub rotation: Quat,
    pub affects_lightmapped_mesh_diffuse: bool,
}
```

---

## Enum AssetMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AssetMode.html

**Contents:**
- Enum AssetMode Copy item path
- Variants§
  - Unprocessed
  - Processed
- Trait Implementations§
  - impl Debug for AssetMode
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
- Auto Trait Implementations§
  - impl Freeze for AssetMode
  - impl RefUnwindSafe for AssetMode

Controls whether or not assets are pre-processed before being loaded.

This setting is controlled by setting AssetPlugin::mode.

When building on web, asset preprocessing can cause problems due to the lack of filesystem access. See bevy#10157 for context.

Loads assets from their AssetSource’s default AssetReader without any “preprocessing”.

Assets will be “pre-processed”. This enables assets to be imported / converted / optimized ahead of time.

Assets will be read from their unprocessed AssetSource (defaults to the assets folder), processed according to their AssetMeta, and written to their processed AssetSource (defaults to the imported_assets/Default folder).

By default, this assumes the processor has already been run. It will load assets from their final processed AssetReader.

When developing an app, you should enable the asset_processor cargo feature, which will run the asset processor at startup. This should generally be used in combination with the file_watcher cargo feature, which enables hot-reloading of assets that have changed. When both features are enabled, changes to “original/source assets” will be detected, the asset will be re-processed, and then the final processed asset will be hot-reloaded in the app.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AssetMode {
    Unprocessed,
    Processed,
}
```

---

## Macro warn_once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.warn_once.html

**Contents:**
- Macro warn_once Copy item path

Call warn! once per call site.

Useful for logging within systems which are called every frame.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! warn_once {
    ($($arg:tt)+) => { ... };
}
```

---

## Derive Macro SubStates Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.SubStates.html

**Contents:**
- Derive Macro SubStates Copy item path

Implements the SubStates trait for a type - see the trait docs for an example usage.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(SubStates)]
{
    // Attributes available to this derive:
    #[states]
    #[source]
}
```

---

## Trait SystemParamBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SystemParamBuilder.html

**Contents:**
- Trait SystemParamBuilder Copy item path
- §List of Builders
- §Safety
- Required Methods§
    - fn build(self, world: &mut World) -> <P as SystemParam>::State
- Provided Methods§
    - fn build_state(self, world: &mut World) -> SystemState<P>
      - Examples found in repository?
- Dyn Compatibility§
- Implementations on Foreign Types§

A builder that can create a SystemParam.

See the documentation for individual builders for more examples.

ParamBuilder can be used for parameters that don’t require any special building. Using a ParamBuilder will build the system parameter the same way it would be initialized in an ordinary system.

ParamBuilder also provides factory methods that return a ParamBuilder typed as impl SystemParamBuilder<P> for common system parameters that can be used to guide closure parameter inference.

QueryParamBuilder can build a Query to add additional filters, or to configure the components available to FilteredEntityRef or FilteredEntityMut. You can also use a QueryState to build a Query.

LocalBuilder can build a Local to supply the initial value for the Local.

FilteredResourcesParamBuilder can build a FilteredResources, and FilteredResourcesMutParamBuilder can build a FilteredResourcesMut, to configure the resources that can be accessed.

DynParamBuilder can build a DynSystemParam to determine the type of the inner parameter, and to supply any SystemParamBuilder it needs.

Tuples of builders can build tuples of parameters, one builder for each element. Note that since systems require a tuple as a parameter, the outer builder for a system will always be a tuple.

A Vec of builders can build a Vec of parameters, one builder for each element.

A ParamSetBuilder can build a ParamSet. This can wrap either a tuple or a Vec, one builder for each element.

A custom system param created with #[derive(SystemParam)] can be buildable if it includes a #[system_param(builder)] attribute. See the documentation for SystemParam derives.

The implementor must ensure that the state returned from SystemParamBuilder::build is valid for P. Note that the exact safety requirements depend on the implementation of SystemParam, so if Self is not a local type then you must call SystemParam::init_state or another SystemParamBuilder::build.

Registers any World access used by this SystemParam and creates a new instance of this param’s State.

Create a SystemState from a SystemParamBuilder. To create a system, call SystemState::build_system on the result.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

This trait is implemented for tuples up to 17 items long.

**Examples:**

Example 1 (unknown):
```unknown
pub unsafe trait SystemParamBuilder<P>: Sizedwhere
    P: SystemParam,{
    // Required method
    fn build(self, world: &mut World) -> <P as SystemParam>::State;

    // Provided method
    fn build_state(self, world: &mut World) -> SystemState<P> { ... }
}
```

Example 2 (javascript):
```javascript
fn some_system(param: MyParam) {}

fn build_system(builder: impl SystemParamBuilder<MyParam>) {
    let mut world = World::new();
    // To build a system, create a tuple of `SystemParamBuilder`s
    // with a builder for each parameter.
    // Note that the builder for a system must be a tuple,
    // even if there is only one parameter.
    (builder,)
        .build_state(&mut world)
        .build_system(some_system);
}

fn build_closure_system_infer(builder: impl SystemParamBuilder<MyParam>) {
    let mut world = World::new();
    // Closures can be used in addition to named functions.
   
...
```

Example 3 (javascript):
```javascript
80fn stress_test(num_entities: u32, num_components: u32, num_systems: u32) {
81    let mut rng = ChaCha8Rng::seed_from_u64(42);
82    let mut app = App::default();
83    let world = app.world_mut();
84
85    // register a bunch of components
86    let component_ids: Vec<ComponentId> = (1..=num_components)
87        .map(|i| {
88            world.register_component_with_descriptor(
89                // SAFETY:
90                // * We don't implement a drop function
91                // * u8 is Sync and Send
92                unsafe {
93                    ComponentDescriptor::new_with_layout(
...
```

---

## Function not Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.not.html

**Contents:**
- Function not Copy item path
- §Example
      - Examples found in repository?

Generates a SystemCondition that inverses the result of passed one.

**Examples:**

Example 1 (unknown):
```unknown
pub fn not<Marker, TOut, T>(
    condition: T,
) -> AdapterSystem<NotMarker, <T as IntoSystem<(), TOut, Marker>>::System>where
    TOut: Not,
    T: IntoSystem<(), TOut, Marker>,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `not` will inverse any condition you pass in.
    // Since the condition we choose always returns true
    // this system will never run
    my_system.run_if(not(always)),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

fn always() -> bool {
    true
}

app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 0);
```

Example 3 (javascript):
```javascript
45    fn build(&self, app: &mut App) {
46        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
47            return;
48        };
49        render_app
50            .add_systems(
51                RenderStartup,
52                (init_compute_pipeline, add_compute_render_graph_node),
53            )
54            .add_systems(
55                Render,
56                prepare_bind_group
57                    .in_set(RenderSystems::PrepareBindGroups)
58                    // We don't need to recreate the bind group every frame
59                    .run_if(not(resource_exists:
...
```

Example 4 (javascript):
```javascript
34    fn build(&self, app: &mut App) {
35        app.add_systems(Startup, build_stepping_hint);
36        if cfg!(not(feature = "bevy_debug_stepping")) {
37            return;
38        }
39
40        // create and insert our debug schedule into the main schedule order.
41        // We need an independent schedule so we have access to all other
42        // schedules through the `Stepping` resource
43        app.init_schedule(DebugSchedule);
44        let mut order = app.world_mut().resource_mut::<MainScheduleOrder>();
45        order.insert_after(Update, DebugSchedule);
46
47        // create
...
```

---

## Struct First Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.First.html

**Contents:**
- Struct First Copy item path
- Trait Implementations§
  - impl Clone for First
    - fn clone(&self) -> First
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for First
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for First
    - fn default() -> First
  - impl Hash for First

Runs first in the schedule.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct First;
```

---

## Struct ReflectFromWorld Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectFromWorld.html

**Contents:**
- Struct ReflectFromWorld Copy item path
- Implementations§
  - impl ReflectFromWorld
    - pub fn from_world(&self, world: &mut World) -> Box<dyn Reflect>
    - pub fn new(fns: ReflectFromWorldFns) -> ReflectFromWorld
    - pub fn fn_pointers(&self) -> &ReflectFromWorldFns
- Trait Implementations§
  - impl Clone for ReflectFromWorld
    - fn clone(&self) -> ReflectFromWorld
    - fn clone_from(&mut self, source: &Self)

A struct used to operate on the reflected FromWorld trait of a type.

A ReflectFromWorld for type T can be obtained via bevy_reflect::TypeRegistration::data.

Constructs default reflected FromWorld from world using from_world().

Create a custom implementation of ReflectFromWorld.

This is an advanced feature, useful for scripting implementations, that should not be used by most users unless you know what you are doing.

Usually you should derive Reflect and add the #[reflect(FromWorld)] bundle to generate a ReflectFromWorld implementation automatically.

See ReflectFromWorldFns for more information.

The underlying function pointers implementing methods on ReflectFromWorld.

This is useful when you want to keep track locally of an individual function pointer.

Calling TypeRegistry::get followed by TypeRegistration::data::<ReflectFromWorld> can be costly if done several times per frame. Consider cloning ReflectFromWorld and keeping it between frames, cloning a ReflectFromWorld is very cheap.

If you only need a subset of the methods on ReflectFromWorld, use fn_pointers to get the underlying ReflectFromWorldFns and copy the subset of function pointers you care about.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectFromWorld(/* private fields */);
```

---

## Struct If Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.If.html

**Contents:**
- Struct If Copy item path
- §Example
- Tuple Fields§
- Implementations§
  - impl<T> If<T>
    - pub fn into_inner(self) -> T
- Trait Implementations§
  - impl<T> Debug for If<T>where T: Debug,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<T> Deref for If<T>

A SystemParam that wraps another parameter and causes its system to skip instead of failing when the parameter is invalid.

The inner value is pub, so you can also obtain it by destructuring the parameter:

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct If<T>(pub T);
```

Example 2 (javascript):
```javascript
// This system will fail if `SomeResource` is not present.
fn fails_on_missing_resource(res: Res<SomeResource>) {}

// This system will skip without error if `SomeResource` is not present.
fn skips_on_missing_resource(res: If<Res<SomeResource>>) {
    // The inner parameter is available using `Deref`
    let some_resource: &SomeResource = &res;
}
```

Example 3 (javascript):
```javascript
fn skips_on_missing_resource(If(res): If<Res<SomeResource>>) {
    let some_resource: Res<SomeResource> = res;
}
```

---

## Struct CursorLeft Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CursorLeft.html

**Contents:**
- Struct CursorLeft Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for CursorLeft
    - fn clone(&self) -> CursorLeft
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for CursorLeft
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'de> Deserialize<'de> for CursorLeft
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<CursorLeft, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,

An event that is sent whenever the user’s cursor leaves a window.

Window that the cursor left.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CursorLeft {
    pub window: Entity,
}
```

---

## Function last_transition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.last_transition.html

**Contents:**
- Function last_transition Copy item path

Returns the latest state transition event of type S, if any are available.

**Examples:**

Example 1 (unknown):
```unknown
pub fn last_transition<S>(
    reader: MessageReader<'_, '_, StateTransitionEvent<S>>,
) -> Option<StateTransitionEvent<S>>where
    S: States,
```

---

## Struct BorderRect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BorderRect.html

**Contents:**
- Struct BorderRect Copy item path
- Fields§
- Implementations§
  - impl BorderRect
    - pub const ZERO: BorderRect
    - pub const fn all(extent: f32) -> BorderRect
      - Examples found in repository?
    - pub const fn axes(horizontal: f32, vertical: f32) -> BorderRect
- Trait Implementations§
  - impl Add for BorderRect

Defines the extents of the border of a rectangle.

This struct is used to represent thickness or offsets from the edges of a rectangle (left, right, top, and bottom), with values increasing inwards.

Extent of the border along the left edge

Extent of the border along the right edge

Extent of the border along the top edge

Extent of the border along the bottom edge

An empty border with zero thickness along each edge

Creates a border with the same extent along each edge

Creates a new border with the left and right extents equal to horizontal, and top and bottom extents equal to vertical.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BorderRect {
    pub left: f32,
    pub right: f32,
    pub top: f32,
    pub bottom: f32,
}
```

Example 2 (javascript):
```javascript
44fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
45    let image = asset_server.load("textures/fantasy_ui_borders/panel-border-010.png");
46
47    let slicer = TextureSlicer {
48        border: BorderRect::all(22.0),
49        center_scale_mode: SliceScaleMode::Stretch,
50        sides_scale_mode: SliceScaleMode::Stretch,
51        max_corner_scale: 1.0,
52    };
53    // ui camera
54    commands.spawn(Camera2d);
55    commands
56        .spawn(Node {
57            width: percent(100),
58            height: percent(100),
59            align_items: AlignItems::Center,
60    
...
```

Example 3 (javascript):
```javascript
17fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
18    let image = asset_server.load_with_settings(
19        "textures/fantasy_ui_borders/numbered_slices.png",
20        |settings: &mut ImageLoaderSettings| {
21            // Need to use nearest filtering to avoid bleeding between the slices with tiling
22            settings.sampler = ImageSampler::nearest();
23        },
24    );
25
26    let slicer = TextureSlicer {
27        // `numbered_slices.png` is 48 pixels square. `BorderRect::square(16.)` insets the slicing line from each edge by 16 pixels, resulting in nine sli
...
```

Example 4 (javascript):
```javascript
560    pub fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
561        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Slice)));
562        let image = asset_server.load("textures/fantasy_ui_borders/numbered_slices.png");
563
564        let slicer = TextureSlicer {
565            border: BorderRect::all(16.0),
566            center_scale_mode: SliceScaleMode::Tile { stretch_value: 1.0 },
567            sides_scale_mode: SliceScaleMode::Tile { stretch_value: 1.0 },
568            ..default()
569        };
570        commands
571            .spawn((
572                Nod
...
```

---

## Struct Release Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Release.html

**Contents:**
- Struct Release Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Release
    - fn clone(&self) -> Release
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Release
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Release
    - type This<'from_arg> = Release

Fires when a pointer button is released over the target entity.

Pointer button lifted to trigger this event.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Release {
    pub button: PointerButton,
    pub hit: HitData,
}
```

---

## Struct With Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.With.html

**Contents:**
- Struct With Copy item path
- §Examples
- Trait Implementations§
  - impl<T> QueryFilter for With<T>where T: Component,
    - const IS_ARCHETYPAL: bool = true
    - unsafe fn filter_fetch( _state: &<With<T> as WorldQuery>::State, _fetch: &mut <With<T> as WorldQuery>::Fetch<'_>, _entity: Entity, _table_row: TableRow, ) -> bool
  - impl<T> WorldQuery for With<T>where T: Component,
    - const IS_DENSE: bool
    - type Fetch<'w> = ()
    - type State = ComponentId

Filter that selects entities with a component T.

This can be used in a Query if entities are required to have the component T but you don’t actually care about components value.

This is the negation of Without.

SAFETY: update_component_access does not add any accesses. This is sound because QueryFilter::filter_fetch does not access any components. update_component_access adds a With filter for T. This is sound because matches_component_set returns whether the set contains the component.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct With<T>(/* private fields */);
```

Example 2 (unknown):
```unknown
fn compliment_entity_system(query: Query<&Name, With<IsBeautiful>>) {
    for name in &query {
        println!("{} is looking lovely today!", name.name);
    }
}
```

---

## Type Alias OnReplace Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.OnReplace.html

**Contents:**
- Type Alias OnReplace Copy item path
- Aliased Type§
- Fields§

Deprecated in favor of Replace.

The entity that held this component before it was replaced.

**Examples:**

Example 1 (unknown):
```unknown
pub type OnReplace = Replace;
```

Example 2 (unknown):
```unknown
pub struct OnReplace {
    pub entity: Entity,
}
```

---

## Struct Button Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Button.html

**Contents:**
- Struct Button Copy item path
- Trait Implementations§
  - impl Clone for Button
    - fn clone(&self) -> Button
    - fn clone_from(&mut self, source: &Self)
  - impl Component for Buttonwhere Button: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

Marker struct for buttons

Required Components: Node, FocusPolicy, Interaction.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Button;
```

---

## Type Alias RumbleSystem Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.RumbleSystem.html

**Contents:**
- Type Alias RumbleSystem Copy item path
- Aliased Type§

Deprecated alias for RumbleSystems.

**Examples:**

Example 1 (unknown):
```unknown
pub type RumbleSystem = RumbleSystems;
```

Example 2 (unknown):
```unknown
pub struct RumbleSystem;
```

---

## Derive Macro AppLabel Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/derive.AppLabel.html

**Contents:**
- Derive Macro AppLabel Copy item path

Generates an impl of the AppLabel trait.

This does not work for unions.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(AppLabel)]
```

---

## Type Alias AnimationNodeIndex Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.AnimationNodeIndex.html

**Contents:**
- Type Alias AnimationNodeIndex Copy item path
- Aliased Type§

The index of either an animation or blend node in the animation graph.

These indices are the way that animation players identify each animation.

**Examples:**

Example 1 (unknown):
```unknown
pub type AnimationNodeIndex = NodeIndex;
```

Example 2 (unknown):
```unknown
pub struct AnimationNodeIndex(/* private fields */);
```

---

## Trait FromReflect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.FromReflect.html

**Contents:**
- Trait FromReflect Copy item path
- Required Methods§
    - fn from_reflect(reflect: &(dyn PartialReflect + 'static)) -> Option<Self>
- Provided Methods§
    - fn take_from_reflect( reflect: Box<dyn PartialReflect>, ) -> Result<Self, Box<dyn PartialReflect>>
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl FromReflect for &'static str
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<&'static str>
  - impl FromReflect for &'static Location<'static>

A trait that enables types to be dynamically constructed from reflected data.

It’s recommended to use the derive macro rather than manually implementing this trait.

FromReflect allows dynamic proxy types, like DynamicStruct, to be used to generate their concrete counterparts. It can also be used to partially or fully clone a type (depending on whether it has ignored fields or not).

In some cases, this trait may even be required. Deriving Reflect on an enum requires all its fields to implement FromReflect. Additionally, some complex types like Vec<T> require that their element types implement this trait. The reason for such requirements is that some operations require new data to be constructed, such as swapping to a new variant or pushing data to a homogeneous list.

See the crate-level documentation to see how this trait can be used.

Constructs a concrete instance of Self from a reflected value.

Attempts to downcast the given value to Self using, constructing the value using from_reflect if that fails.

This method is more efficient than using from_reflect for cases where the given value is likely a boxed instance of Self (i.e. Box<Self>) rather than a boxed dynamic type (e.g. DynamicStruct, DynamicList, etc.).

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait FromReflect: Sized + Reflect {
    // Required method
    fn from_reflect(reflect: &(dyn PartialReflect + 'static)) -> Option<Self>;

    // Provided method
    fn take_from_reflect(
        reflect: Box<dyn PartialReflect>,
    ) -> Result<Self, Box<dyn PartialReflect>> { ... }
}
```

---

## Trait GizmoConfigGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.GizmoConfigGroup.html

**Contents:**
- Trait GizmoConfigGroup Copy item path
- Dyn Compatibility§
- Implementors§
  - impl GizmoConfigGroup for ErasedGizmoConfigGroupwhere ErasedGizmoConfigGroup: Reflect + TypePath + Default,
  - impl GizmoConfigGroup for AabbGizmoConfigGroupwhere AabbGizmoConfigGroup: Reflect + TypePath + Default,
  - impl GizmoConfigGroup for DefaultGizmoConfigGroupwhere DefaultGizmoConfigGroup: Reflect + TypePath + Default,
  - impl GizmoConfigGroup for LightGizmoConfigGroupwhere LightGizmoConfigGroup: Reflect + TypePath + Default,

A trait used to create gizmo configs groups.

Here you can store additional configuration for you gizmo group not covered by GizmoConfig

Make sure to derive Default + Reflect and register in the app using app.init_gizmo_group::<T>()

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait GizmoConfigGroup:
    Reflect
    + TypePath
    + Default { }
```

---

## Struct Triangle2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Triangle2d.html

**Contents:**
- Struct Triangle2d Copy item path
- Fields§
- Implementations§
  - impl Triangle2d
    - pub const fn new(a: Vec2, b: Vec2, c: Vec2) -> Triangle2d
      - Examples found in repository?
    - pub fn winding_order(&self) -> WindingOrder
    - pub fn circumcircle(&self) -> (Circle, Vec2)
    - pub fn is_degenerate(&self) -> bool
    - pub fn is_acute(&self) -> bool

A triangle in 2D space

The vertices of the triangle

Create a new Triangle2d from points a, b, and c

Get the WindingOrder of the triangle

Compute the circle passing through all three vertices of the triangle. The vector in the returned tuple is the circumcenter.

Checks if the triangle is degenerate, meaning it has zero area.

A triangle is degenerate if the cross product of the vectors ab and ac has a length less than 10e-7. This indicates that the three vertices are collinear or nearly collinear.

Checks if the triangle is acute, meaning all angles are less than 90 degrees

Checks if the triangle is obtuse, meaning one angle is greater than 90 degrees

Reverse the WindingOrder of the triangle by swapping the first and last vertices.

This triangle but reversed.

Returns the default Triangle2d with the vertices [0.0, 0.5], [-0.5, -0.5], and [0.5, -0.5].

Get the area of the triangle

Get the perimeter of the triangle

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Triangle2d {
    pub vertices: [Vec2; 3],
}
```

Example 2 (unknown):
```unknown
54fn setup(
55    mut commands: Commands,
56    mut meshes: ResMut<Assets<Mesh>>,
57    mut materials: ResMut<Assets<ColorMaterial>>,
58) {
59    // Triangle: Never renders a wireframe
60    commands.spawn((
61        Mesh2d(meshes.add(Triangle2d::new(
62            Vec2::new(0.0, 50.0),
63            Vec2::new(-50.0, -50.0),
64            Vec2::new(50.0, -50.0),
65        ))),
66        MeshMaterial2d(materials.add(Color::BLACK)),
67        Transform::from_xyz(-150.0, 0.0, 0.0),
68        NoWireframe2d,
69    ));
70    // Rectangle: Follows global wireframe setting
71    commands.spawn((
72  
...
```

Example 3 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 4 (unknown):
```unknown
202fn setup(mut commands: Commands) {
203    commands.spawn(Camera2d);
204
205    commands.spawn((
206        Transform::from_xyz(-OFFSET_X, OFFSET_Y, 0.),
207        Shape::Circle(Circle::new(45.)),
208        DesiredVolume::Aabb,
209        Intersects::default(),
210    ));
211
212    commands.spawn((
213        Transform::from_xyz(0., OFFSET_Y, 0.),
214        Shape::Rectangle(Rectangle::new(80., 80.)),
215        Spin,
216        DesiredVolume::Circle,
217        Intersects::default(),
218    ));
219
220    commands.spawn((
221        Transform::from_xyz(OFFSET_X, OFFSET_Y, 0.),
222       
...
```

---

## Struct OverflowClipMargin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.OverflowClipMargin.html

**Contents:**
- Struct OverflowClipMargin Copy item path
- Fields§
- Implementations§
  - impl OverflowClipMargin
    - pub const DEFAULT: OverflowClipMargin
    - pub const fn content_box() -> OverflowClipMargin
      - Examples found in repository?
    - pub const fn padding_box() -> OverflowClipMargin
      - Examples found in repository?
    - pub const fn border_box() -> OverflowClipMargin

The bounds of the visible area when a UI node is clipped.

Visible unclipped area

Width of the margin on each edge of the visual box in logical pixels. The width of the margin will be zero if a negative value is set.

Clip any content that overflows outside the content box

Clip any content that overflows outside the padding box

Clip any content that overflows outside the border box

Add a margin on each edge of the visual box in logical pixels. The width of the margin will be zero if a negative value is set.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct OverflowClipMargin {
    pub visual_box: OverflowClipBox,
    pub margin: f32,
}
```

Example 2 (javascript):
```javascript
12fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
13    commands.spawn(Camera2d);
14
15    let image = asset_server.load("branding/icon.png");
16
17    commands
18        .spawn((
19            Node {
20                width: percent(100),
21                height: percent(100),
22                align_items: AlignItems::Center,
23                justify_content: JustifyContent::Center,
24                row_gap: px(40),
25                flex_direction: FlexDirection::Column,
26                ..default()
27            },
28            BackgroundColor(ANTIQUE_WHITE.into()),
...
```

Example 3 (javascript):
```javascript
12fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
13    commands.spawn(Camera2d);
14
15    let image = asset_server.load("branding/icon.png");
16
17    commands
18        .spawn((
19            Node {
20                width: percent(100),
21                height: percent(100),
22                align_items: AlignItems::Center,
23                justify_content: JustifyContent::Center,
24                row_gap: px(40),
25                flex_direction: FlexDirection::Column,
26                ..default()
27            },
28            BackgroundColor(ANTIQUE_WHITE.into()),
...
```

Example 4 (javascript):
```javascript
12fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
13    commands.spawn(Camera2d);
14
15    let image = asset_server.load("branding/icon.png");
16
17    commands
18        .spawn((
19            Node {
20                width: percent(100),
21                height: percent(100),
22                align_items: AlignItems::Center,
23                justify_content: JustifyContent::Center,
24                row_gap: px(40),
25                flex_direction: FlexDirection::Column,
26                ..default()
27            },
28            BackgroundColor(ANTIQUE_WHITE.into()),
...
```

---

## Trait DynEq Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/trait.DynEq.html

**Contents:**
- Trait DynEq Copy item path
- Required Methods§
    - fn dyn_eq(&self, other: &(dyn DynEq + 'static)) -> bool
- Implementors§
  - impl<T> DynEq for Twhere T: Any + Eq,

An object safe version of Eq. This trait is automatically implemented for any 'static type that implements Eq.

This method tests for self and other values to be equal.

Implementers should avoid returning true when the underlying types are not the same.

**Examples:**

Example 1 (unknown):
```unknown
pub trait DynEq: Any {
    // Required method
    fn dyn_eq(&self, other: &(dyn DynEq + 'static)) -> bool;
}
```

---

## Struct Hsva Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Hsva.html

**Contents:**
- Struct Hsva Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Hsva
    - pub const fn new(hue: f32, saturation: f32, value: f32, alpha: f32) -> Hsva
      - §Arguments
    - pub const fn hsv(hue: f32, saturation: f32, value: f32) -> Hsva
      - §Arguments
    - pub const fn with_saturation(self, saturation: f32) -> Hsva

Color in Hue-Saturation-Value (HSV) color space with alpha. Further information on this color model can be found on Wikipedia.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The hue channel. [0.0, 360.0]

The saturation channel. [0.0, 1.0]

The value channel. [0.0, 1.0]

The alpha channel. [0.0, 1.0]

Construct a new Hsva color from components.

Construct a new Hsva color from (h, s, v) components, with the default alpha (1.0).

Return a copy of this color with the saturation channel set to the given value.

Return a copy of this color with the value channel set to the given value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Hsva {
    pub hue: f32,
    pub saturation: f32,
    pub value: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

---

## Struct QuarticInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuarticInOutCurve.html

**Contents:**
- Struct QuarticInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for QuarticInOutCurve
    - fn clone(&self) -> QuarticInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuarticInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as QuarticIn for t < 0.5 and as QuarticOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuarticInOutCurve;
```

---

## Function state_exists Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.state_exists.html

**Contents:**
- Function state_exists Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the state machine exists.

**Examples:**

Example 1 (unknown):
```unknown
pub fn state_exists<S>(current_state: Option<Res<'_, State<S>>>) -> boolwhere
    S: States,
```

Example 2 (unknown):
```unknown
#[derive(States, Clone, Copy, Default, Eq, PartialEq, Hash, Debug)]
enum GameState {
    #[default]
    Playing,
    Paused,
}

app.add_systems(Update,
    // `state_exists` will only return true if the
    // given state exists
    my_system.run_if(state_exists::<GameState>),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `GameState` does not yet exist so `my_system` won't run
app.update();
assert_eq!(app.world().resource::<Counter>().0, 0);

app.init_state::<GameState>();

// `GameState` now exists so `my_system` will run
app.update();
assert_eq!(app.world().resou
...
```

---

## Struct Capsule2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Capsule2d.html

**Contents:**
- Struct Capsule2d Copy item path
- Fields§
- Implementations§
  - impl Capsule2d
    - pub const fn new(radius: f32, length: f32) -> Capsule2d
      - Examples found in repository?
    - pub const fn to_inner_rectangle(&self) -> Rectangle
- Trait Implementations§
  - impl Bounded2d for Capsule2d
    - fn aabb_2d(&self, isometry: impl Into<Isometry2d>) -> Aabb2d

A 2D capsule primitive, also known as a stadium or pill shape.

A two-dimensional capsule is defined as a neighborhood of points at a distance (radius) from a line

The radius of the capsule

Half the height of the capsule, excluding the semicircles

Create a new Capsule2d from a radius and length

Get the part connecting the semicircular ends of the capsule as a Rectangle

Returns the default Capsule2d with a radius of 0.5 and a half-height of 0.5, excluding the semicircles.

Get the area of the capsule

Get the perimeter of the capsule

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Capsule2d {
    pub radius: f32,
    pub half_length: f32,
}
```

Example 2 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 3 (unknown):
```unknown
202fn setup(mut commands: Commands) {
203    commands.spawn(Camera2d);
204
205    commands.spawn((
206        Transform::from_xyz(-OFFSET_X, OFFSET_Y, 0.),
207        Shape::Circle(Circle::new(45.)),
208        DesiredVolume::Aabb,
209        Intersects::default(),
210    ));
211
212    commands.spawn((
213        Transform::from_xyz(0., OFFSET_Y, 0.),
214        Shape::Rectangle(Rectangle::new(80., 80.)),
215        Spin,
216        DesiredVolume::Circle,
217        Intersects::default(),
218    ));
219
220    commands.spawn((
221        Transform::from_xyz(OFFSET_X, OFFSET_Y, 0.),
222       
...
```

Example 4 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

---

## Struct WindowPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.WindowPlugin.html

**Contents:**
- Struct WindowPlugin Copy item path
- Fields§
- Trait Implementations§
  - impl Default for WindowPlugin
    - fn default() -> WindowPlugin
  - impl Plugin for WindowPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

A Plugin that defines an interface for windowing support in Bevy.

Settings for the primary window.

Some(custom_window) will spawn an entity with custom_window and PrimaryWindow as components. None will not spawn a primary window.

Defaults to Some(Window::default()).

Note that if there are no windows the App will exit (by default) due to exit_on_all_closed.

Settings for the cursor on the primary window.

Defaults to Some(CursorOptions::default()).

Has no effect if WindowPlugin::primary_window is None.

Whether to exit the app when there are no open windows.

If disabling this, ensure that you send the bevy_app::AppExit event when the app should exit. If this does not occur, you will create ‘headless’ processes (processes without windows), which may surprise your users. It is recommended to leave this setting to either ExitCondition::OnAllClosed or ExitCondition::OnPrimaryClosed.

ExitCondition::OnAllClosed will add exit_on_all_closed to Update. ExitCondition::OnPrimaryClosed will add exit_on_primary_closed to Update.

Whether to close windows when they are requested to be closed (i.e. when the close button is pressed).

If true, this plugin will add close_when_requested to Update. If this system (or a replacement) is not running, the close button will have no effect. This may surprise your users. It is recommended to leave this setting as true.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WindowPlugin {
    pub primary_window: Option<Window>,
    pub primary_cursor_options: Option<CursorOptions>,
    pub exit_condition: ExitCondition,
    pub close_when_requested: bool,
}
```

---

## Trait Command Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Command.html

**Contents:**
- Trait Command Copy item path
- §Usage
- Required Methods§
    - fn apply(self, world: &mut World) -> Out
- Implementors§
  - impl<F, Out> Command<Out> for Fwhere F: FnOnce(&mut World) -> Out + Send + 'static,

Should be used with Commands::queue.

The Out generic parameter is the returned “output” of the command.

Applies this command, causing it to mutate the provided world.

This method is used to define what a command “does” when it is ultimately applied. Because this method takes self, you can store data or settings on the type that implements this trait. This data is set by the system or other source of the command, and then ultimately read in this method.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Command<Out = ()>: Send + 'static {
    // Required method
    fn apply(self, world: &mut World) -> Out;
}
```

Example 2 (javascript):
```javascript
// Our world resource
#[derive(Resource, Default)]
struct Counter(u64);

// Our custom command
struct AddToCounter(u64);

impl Command for AddToCounter {
    fn apply(self, world: &mut World) {
        let mut counter = world.get_resource_or_insert_with(Counter::default);
        counter.0 += self.0;
    }
}

fn some_system(mut commands: Commands) {
    commands.queue(AddToCounter(42));
}
```

---

## Struct ReflectDefault Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectDefault.html

**Contents:**
- Struct ReflectDefault Copy item path
- Implementations§
  - impl ReflectDefault
    - pub fn default(&self) -> Box<dyn Reflect>
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for ReflectDefault
    - fn clone(&self) -> ReflectDefault
    - fn clone_from(&mut self, source: &Self)
  - impl<T> FromType<T> for ReflectDefaultwhere T: Reflect + Default,

A struct used to provide the default value of a type.

A ReflectDefault for type T can be obtained via FromType::from_type.

Returns the default value for a type.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectDefault { /* private fields */ }
```

Example 2 (javascript):
```javascript
12fn main() {
13    #[derive(Reflect, Default, PartialEq, Debug)]
14    #[reflect(Identifiable, Default)]
15    struct Player {
16        id: u32,
17    }
18
19    #[reflect_trait]
20    trait Identifiable {
21        fn id(&self) -> u32;
22    }
23
24    impl Identifiable for Player {
25        fn id(&self) -> u32 {
26            self.id
27        }
28    }
29
30    // Normally, when instantiating a type, you get back exactly that type.
31    // This is because the type is known at compile time.
32    // We call this the "concrete" or "canonical" type.
33    let player: Player = Player { id: 
...
```

---

## Struct Last Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.Last.html

**Contents:**
- Struct Last Copy item path
- Trait Implementations§
  - impl Clone for Last
    - fn clone(&self) -> Last
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Last
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Last
    - fn default() -> Last
  - impl Hash for Last

Runs last in the schedule.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Last;
```

---

## Struct Oklaba Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Oklaba.html

**Contents:**
- Struct Oklaba Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Oklaba
    - pub const fn new(lightness: f32, a: f32, b: f32, alpha: f32) -> Oklaba
      - §Arguments
    - pub const fn lab(lightness: f32, a: f32, b: f32) -> Oklaba
      - §Arguments
    - pub const fn with_lightness(self, lightness: f32) -> Oklaba

Color in Oklab color space, with alpha

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The ‘lightness’ channel. [0.0, 1.0]

The ‘a’ channel. [-1.0, 1.0]

The ‘b’ channel. [-1.0, 1.0]

The alpha channel. [0.0, 1.0]

Construct a new Oklaba color from components.

Construct a new Oklaba color from (l, a, b) components, with the default alpha (1.0).

Return a copy of this color with the ‘lightness’ channel set to the given value.

Return a copy of this color with the ‘a’ channel set to the given value.

Return a copy of this color with the ‘b’ channel set to the given value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Oklaba {
    pub lightness: f32,
    pub a: f32,
    pub b: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

---

## Struct PropagateSet Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PropagateSet.html

**Contents:**
- Struct PropagateSet Copy item path
- Trait Implementations§
  - impl<C> Clone for PropagateSet<C>where C: Clone + Component + PartialEq,
    - fn clone(&self) -> PropagateSet<C>
    - fn clone_from(&mut self, source: &Self)
  - impl<C> Debug for PropagateSet<C>where C: Component + Clone + PartialEq,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<C> Default for PropagateSet<C>where C: Component + Clone + PartialEq,
    - fn default() -> PropagateSet<C>
  - impl<C> Hash for PropagateSet<C>where C: Component + Clone + PartialEq,

The set in which propagation systems are added. You can schedule your logic relative to this set.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PropagateSet<C>where
    C: Component + Clone + PartialEq,{ /* private fields */ }
```

---

## Struct AngularColorStop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AngularColorStop.html

**Contents:**
- Struct AngularColorStop Copy item path
- Fields§
- Implementations§
  - impl AngularColorStop
    - pub fn new(color: impl Into<Color>, angle: f32) -> AngularColorStop
    - pub fn auto(color: impl Into<Color>) -> AngularColorStop
      - Examples found in repository?
    - pub const fn with_hint(self, hint: f32) -> AngularColorStop
- Trait Implementations§
  - impl Clone for AngularColorStop

An angular color stop for a conic gradient

The angle of the stop. Angles are relative to the start of the gradient and not other stops. If set to None the angle of the stop will be interpolated between the explicit stops or 0 and 2 PI degrees if there no explicit stops. Given angles are clamped to between 0., and TAU. This means that a list of stops:

Resulting in a black to red gradient, not white to blue.

Normalized angle between this and the following stop of the interpolation midpoint.

An angular stop without an explicit angle. The angles of automatic stops are interpolated evenly between explicit stops.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AngularColorStop {
    pub color: Color,
    pub angle: Option<f32>,
    pub hint: f32,
}
```

Example 2 (javascript):
```javascript
let stops = [
    AngularColorStop::new(Color::WHITE, 0.),
    AngularColorStop::new(Color::BLACK, -1.),
    AngularColorStop::new(RED, 2. * TAU),
    AngularColorStop::new(BLUE, TAU),
];
```

Example 3 (javascript):
```javascript
let stops = [
    AngularColorStop::new(Color::WHITE, 0.),
    AngularColorStop::new(Color::BLACK, 0.),
    AngularColorStop::new(RED, TAU),
    AngularColorStop::new(BLUE, TAU),
];
```

Example 4 (unknown):
```unknown
16fn setup(mut commands: Commands) {
17    commands.spawn(Camera2d);
18    commands
19        .spawn(Node {
20            display: Display::Grid,
21            width: percent(100),
22            height: percent(100),
23
24            ..Default::default()
25        })
26        .with_children(|commands| {
27            commands.spawn((
28                Node {
29                    width: percent(100),
30                    height: percent(100),
31                    ..Default::default()
32                },
33                BackgroundColor(Color::BLACK),
34                BackgroundGradient(v
...
```

---

## Struct QueryBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QueryBuilder.html

**Contents:**
- Struct QueryBuilder Copy item path
- Implementations§
  - impl<'w, D, F> QueryBuilder<'w, D, F>where D: QueryData, F: QueryFilter,
    - pub fn new(world: &'w mut World) -> QueryBuilder<'w, D, F>
      - Examples found in repository?
    - pub fn world(&self) -> &World
    - pub fn world_mut(&mut self) -> &mut World
    - pub fn extend_access(&mut self, access: FilteredAccess)
    - pub fn data<T>(&mut self) -> &mut QueryBuilder<'w, D, F>where T: QueryData,
    - pub fn filter<T>(&mut self) -> &mut QueryBuilder<'w, D, F>where T: QueryFilter,

Builder struct to create QueryState instances at runtime.

Creates a new builder with the accesses required for Q and F

Returns a reference to the world passed to Self::new.

Returns a mutable reference to the world passed to Self::new.

Adds access to self’s underlying FilteredAccess respecting Self::or and Self::and

Adds accesses required for T to self.

Adds filter from T to self.

Adds With<T> to the FilteredAccess of self.

Adds With<T> to the FilteredAccess of self from a runtime ComponentId.

Adds Without<T> to the FilteredAccess of self.

Adds Without<T> to the FilteredAccess of self from a runtime ComponentId.

Adds &T to the FilteredAccess of self.

Adds &mut T to the FilteredAccess of self.

Takes a function over mutable access to a QueryBuilder, calls that function on an empty builder and then adds all accesses from that builder to self as optional.

Takes a function over mutable access to a QueryBuilder, calls that function on an empty builder and then adds all accesses from that builder to self.

Primarily used when inside a Self::or closure to group several terms.

Takes a function over mutable access to a QueryBuilder, calls that function on an empty builder, all accesses added to that builder will become terms in an or expression.

Returns a reference to the FilteredAccess that will be provided to the built Query.

Transmute the existing builder adding required accesses. This will maintain all existing accesses.

If including a filter type see Self::transmute_filtered

Transmute the existing builder adding required accesses. This will maintain all existing accesses.

Create a QueryState with the accesses of the builder.

Takes &mut self to access the inner world reference while initializing state for the new QueryState

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QueryBuilder<'w, D = (), F = ()>where
    D: QueryData,
    F: QueryFilter,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
let mut world = World::new();
let entity_a = world.spawn((A, B)).id();
let entity_b = world.spawn((A, C)).id();

// Instantiate the builder using the type signature of the iterator you will consume
let mut query = QueryBuilder::<(Entity, &B)>::new(&mut world)
// Add additional terms through builder methods
    .with::<A>()
    .without::<C>()
    .build();

// Consume the QueryState
let (entity, b) = query.single(&world).unwrap();
```

Example 3 (javascript):
```javascript
51fn main() {
52    let mut world = World::new();
53    let mut lines = std::io::stdin().lines();
54    let mut component_names = HashMap::<String, ComponentId>::new();
55    let mut component_info = HashMap::<ComponentId, ComponentInfo>::new();
56
57    println!("{PROMPT}");
58    loop {
59        print!("\n> ");
60        let _ = std::io::stdout().flush();
61        let Some(Ok(line)) = lines.next() else {
62            return;
63        };
64
65        if line.is_empty() {
66            return;
67        };
68
69        let Some((first, rest)) = line.trim().split_once(|c: char| c.is_whitesp
...
```

Example 4 (javascript):
```javascript
216fn parse_term<Q: QueryData>(
217    str: &str,
218    builder: &mut QueryBuilder<Q>,
219    components: &HashMap<String, ComponentId>,
220) {
221    let mut matched = false;
222    let str = str.trim();
223    match str.chars().next() {
224        // Optional term
225        Some('?') => {
226            builder.optional(|b| parse_term(&str[1..], b, components));
227            matched = true;
228        }
229        // Reference term
230        Some('&') => {
231            let mut parts = str.split_whitespace();
232            let first = parts.next().unwrap();
233            if first == 
...
```

---

## Struct PostUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PostUpdate.html

**Contents:**
- Struct PostUpdate Copy item path
- Trait Implementations§
  - impl Clone for PostUpdate
    - fn clone(&self) -> PostUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PostUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PostUpdate
    - fn default() -> PostUpdate
  - impl Hash for PostUpdate

The schedule that contains logic that must run after Update. For example, synchronizing “local transforms” in a hierarchy to “global” absolute transforms. This enables the PostUpdate transform-sync system to react to “local transform” changes in Update without the Update systems needing to know about (or add scheduler dependencies for) the “global transform sync system”.

PostUpdate exists to do “engine/plugin response work” to things that happened in Update. PostUpdate abstracts out “implementation details” from users defining systems in Update.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PostUpdate;
```

---

## Type Alias Text2dWriter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.Text2dWriter.html

**Contents:**
- Type Alias Text2dWriter Copy item path
- Aliased Type§

2d alias for TextWriter.

**Examples:**

Example 1 (unknown):
```unknown
pub type Text2dWriter<'w, 's> = TextWriter<'w, 's, Text2d>;
```

Example 2 (unknown):
```unknown
pub struct Text2dWriter<'w, 's> { /* private fields */ }
```

---

## Struct EntityCommands Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EntityCommands.html

**Contents:**
- Struct EntityCommands Copy item path
- §Note
- §Fallible
- §Error handling
- Implementations§
  - impl<'a> EntityCommands<'a>
    - pub fn with_children( &mut self, func: impl FnOnce(&mut RelatedSpawnerCommands<'_, ChildOf>), ) -> &mut EntityCommands<'a>
      - Examples found in repository?
    - pub fn add_children(&mut self, children: &[Entity]) -> &mut EntityCommands<'a>
      - Examples found in repository?

A list of commands that will be run to modify an Entity.

Most Commands (and thereby EntityCommands) are deferred: when you call the command, if it requires mutable access to the World (that is, if it removes, adds, or changes something), it’s not executed immediately.

Instead, the command is added to a “command queue.” The command queue is applied later when the ApplyDeferred system runs. Commands are executed one-by-one so that each command can have exclusive access to the World.

Due to their deferred nature, an entity you’re trying to change with an EntityCommand can be despawned by the time the command is executed.

All deferred entity commands will check whether the entity exists at the time of execution and will return an error if it doesn’t.

An EntityCommand can return a Result, which will be passed to an error handler if the Result is an error.

The default error handler panics. It can be configured via the DefaultErrorHandler resource.

Alternatively, you can customize the error handler for a specific command by calling EntityCommands::queue_handled.

The error module provides some simple error handlers for convenience.

Spawns children of this entity (with a ChildOf relationship) by taking a function that operates on a ChildSpawner.

Adds the given children to this entity

Removes all the children from this entity. See also clear_related

Insert children at specific index. See also insert_related.

Insert children at specific index. See also insert_related.

Adds the given child to this entity

Removes the relationship between this entity and the given entities.

Removes the relationship between this entity and the given entity.

Replaces the children on this entity with a new list of children.

Replaces all the related entities with a new set of entities.

Failing to maintain the functions invariants may lead to erratic engine behavior including random crashes. Refer to EntityWorldMut::replace_related_with_difference for a list of these invariants.

Panics when debug assertions are enabled if an invariant is broken and the command is executed.

Spawns the passed bundle and adds it to this entity as a child.

For efficient spawning of multiple children, use with_children.

Spawns a entity related to this entity (with the R relationship) by taking a bundle

Spawns entities related to this entity (with the R relationship) by taking a function that operates on a RelatedSpawner.

Relates the given entities to this entity with the relation R.

See 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct EntityCommands<'a> { /* private fields */ }
```

Example 2 (unknown):
```unknown
27fn setup(mut commands: Commands) {
28    commands
29        .spawn((Name::new("Goblin"), HitPoints(50)))
30        .observe(take_damage)
31        .with_children(|parent| {
32            parent
33                .spawn((Name::new("Helmet"), Armor(5)))
34                .observe(block_attack);
35            parent
36                .spawn((Name::new("Socks"), Armor(10)))
37                .observe(block_attack);
38            parent
39                .spawn((Name::new("Shirt"), Armor(15)))
40                .observe(block_attack);
41        });
42}
```

Example 3 (javascript):
```javascript
144fn print_logs(
145    mut log_message_reader: MessageReader<LogMessage>,
146    mut commands: Commands,
147    log_viewer_root: Single<Entity, With<LogViewerRoot>>,
148) {
149    let root_entity = *log_viewer_root;
150
151    commands.entity(root_entity).with_children(|child| {
152        for log_message in log_message_reader.read() {
153            child.spawn((
154                Text::default(),
155                children![
156                    (
157                        TextSpan::new(format!("{:5} ", log_message.level)),
158                        TextColor(level_color(&log_message
...
```

Example 4 (javascript):
```javascript
85fn setup(mut commands: Commands, asset_server: Res<AssetServer>, mut state: ResMut<State>) {
86    let font_handle = asset_server.load("fonts/FiraSans-Bold.ttf");
87    state.handle = font_handle.clone();
88    commands.spawn(Camera2d);
89    commands
90        .spawn((
91            Node {
92                position_type: PositionType::Absolute,
93                bottom: Val::ZERO,
94                ..default()
95            },
96            BackgroundColor(Color::NONE),
97        ))
98        .with_children(|parent| {
99            parent.spawn((
100                Text::new("a"),
101     
...
```

---

## Struct ExponentialInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ExponentialInCurve.html

**Contents:**
- Struct ExponentialInCurve Copy item path
- Trait Implementations§
  - impl Clone for ExponentialInCurve
    - fn clone(&self) -> ExponentialInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ExponentialInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) ≈ 2.0^(10.0 * (t - 1.0))

The precise definition adjusts it slightly so it hits both (0, 0) and (1, 1): f(t) = 2.0^(10.0 * t - A) - B, where A = log₂(2¹⁰-1) and B = 1/(2¹⁰-1).

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ExponentialInCurve;
```

---

## Function resource_removed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_removed.html

**Contents:**
- Function resource_removed Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the resource of the given type has been removed since the condition was last checked.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_removed<T>(
    res: Option<Res<'_, T>>,
    existed: Local<'_, bool>,
) -> boolwhere
    T: Resource,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_removed` will only return true if the
    // given resource was just removed
    my_system.run_if(resource_removed::<MyResource>),
);

#[derive(Resource, Default)]
struct MyResource;

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

world.init_resource::<MyResource>();

// `MyResource` hasn't just been removed so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 0);

world.remove_resource::<MyResource>();

// `MyResource` was just removed so `my_system` will run
app.run(&mut world);
assert_eq!(world.resourc
...
```

---

## Struct StandardMaterial Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.StandardMaterial.html

**Contents:**
- Struct StandardMaterial Copy item path
- Fields§
    - §Notes
    - §Performance
  - §Notes
  - §Usage
    - §Limitations
    - §Performance
- Implementations§
  - impl StandardMaterial

A material with “standard” properties used in PBR lighting. Standard property values with pictures here: https://google.github.io/filament/notes/material_properties.html.

May be created directly from a Color or an Image.

The color of the surface of the material before lighting.

Doubles as diffuse albedo for non-metallic, specular for metallic and a mix for everything in between. If used together with a base_color_texture, this is factored into the final base color as base_color * base_color_texture_value.

Defaults to Color::WHITE.

The UV channel to use for the StandardMaterial::base_color_texture.

Defaults to UvChannel::Uv0.

The texture component of the material’s color before lighting. The actual pre-lighting color is base_color * this_texture.

See base_color for details.

You should set base_color to Color::WHITE (the default) if you want the texture to show as-is.

Setting base_color to something else than white will tint the texture. For example, setting base_color to pure red will tint the texture red.

Color the material “emits” to the camera.

This is typically used for monitor screens or LED lights. Anything that can be visible even in darkness.

The emissive color is added to what would otherwise be the material’s visible color. This means that for a light emissive value, in darkness, you will mostly see the emissive component.

The default emissive color is LinearRgba::BLACK, which doesn’t add anything to the material color.

Emissive strength is controlled by the value of the color channels, while the hue is controlled by their relative values.

As a result, channel values for emissive colors can exceed 1.0. For instance, a base_color of LinearRgba::rgb(1.0, 0.0, 0.0) represents the brightest red for objects that reflect light, but an emissive color like LinearRgba::rgb(1000.0, 0.0, 0.0) can be used to create intensely bright red emissive effects.

This results in a final luminance value when multiplied by the value of the greyscale emissive texture (which ranges from 0 for black to 1 for white). Luminance is a measure of the amount of light emitted per unit area, and can be thought of as the “brightness” of the effect. In Bevy, we treat these luminance values as the physical units of cd/m², aka nits.

Increasing the emissive strength of the color will impact visual effects like bloom, but it’s important to note that an emissive material won’t typically light up surrounding areas like a light source, it just adds a value to the color see

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct StandardMaterial {Show 60 fields
    pub base_color: Color,
    pub base_color_channel: UvChannel,
    pub base_color_texture: Option<Handle<Image>>,
    pub emissive: LinearRgba,
    pub emissive_exposure_weight: f32,
    pub emissive_channel: UvChannel,
    pub emissive_texture: Option<Handle<Image>>,
    pub perceptual_roughness: f32,
    pub metallic: f32,
    pub metallic_roughness_channel: UvChannel,
    pub metallic_roughness_texture: Option<Handle<Image>>,
    pub reflectance: f32,
    pub specular_tint: Color,
    pub diffuse_transmission: f32,
    pub diffuse_transmission_
...
```

Example 2 (javascript):
```javascript
fn load_normal_map(asset_server: Res<AssetServer>) {
    let normal_handle: Handle<Image> = asset_server.load_with_settings(
        "textures/parallax_example/cube_normal.png",
        // The normal map texture is in linear color space. Lighting won't look correct
        // if `is_srgb` is `true`, which is the default.
        |settings: &mut ImageLoaderSettings| settings.is_srgb = false,
    );
}
```

---

## Trait Saturation Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Saturation.html

**Contents:**
- Trait Saturation Copy item path
- Required Methods§
    - fn with_saturation(&self, saturation: f32) -> Self
    - fn saturation(&self) -> f32
    - fn set_saturation(&mut self, saturation: f32)
- Dyn Compatibility§
- Implementors§
  - impl Saturation for Color
  - impl Saturation for Hsla
  - impl Saturation for Hsva

Trait for manipulating the saturation of a color.

When working with color spaces that do not have native saturation components the operations are performed in Hsla.

Return a new version of this color with the saturation channel set to the given value.

Return the saturation of this color [0.0, 1.0].

Sets the saturation of this color.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Saturation: Sized {
    // Required methods
    fn with_saturation(&self, saturation: f32) -> Self;
    fn saturation(&self) -> f32;
    fn set_saturation(&mut self, saturation: f32);
}
```

---

## Struct QuadraticInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuadraticInCurve.html

**Contents:**
- Struct QuadraticInCurve Copy item path
- Trait Implementations§
  - impl Clone for QuadraticInCurve
    - fn clone(&self) -> QuadraticInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuadraticInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

This is the Hermite interpolator for

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuadraticInCurve;
```

---

## Struct HierarchyPropagatePlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.HierarchyPropagatePlugin.html

**Contents:**
- Struct HierarchyPropagatePlugin Copy item path
- Implementations§
  - impl<C, F, R> HierarchyPropagatePlugin<C, F, R>where C: Component + Clone + PartialEq, F: QueryFilter, R: Relationship,
    - pub fn new(schedule: impl ScheduleLabel) -> HierarchyPropagatePlugin<C, F, R>
- Trait Implementations§
  - impl<C, F, R> Plugin for HierarchyPropagatePlugin<C, F, R>where C: Component + Clone + PartialEq, F: QueryFilter + 'static, R: Relationship,
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

Plugin to automatically propagate a component value to all direct and transient relationship targets (e.g. bevy_ecs::hierarchy::Children) of entities with a Propagate component.

The plugin Will maintain the target component over hierarchy changes, adding or removing C when a relationship R (e.g. ChildOf) is added to or removed from a relationship tree with a Propagate<C> source, or if the Propagate<C> component is added, changed or removed.

Optionally you can include a query filter F to restrict the entities that are updated. Note that the filter is not rechecked dynamically: changes to the filter state will not be picked up until the Propagate component is touched, or the hierarchy is changed. All members of the tree between source and target must match the filter for propagation to reach a given target. Individual entities can be skipped or terminate the propagation with the PropagateOver and PropagateStop components.

The schedule can be configured via HierarchyPropagatePlugin::new. You should be sure to schedule your logic relative to this set: making changes that modify component values before this logic, and reading the propagated values after it.

Construct the plugin. The propagation systems will be placed in the specified schedule.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct HierarchyPropagatePlugin<C, F = (), R = ChildOf>where
    C: Component + Clone + PartialEq,
    F: QueryFilter,
    R: Relationship,{ /* private fields */ }
```

---

## Trait Vec2Swizzles Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Vec2Swizzles.html

**Contents:**
- Trait Vec2Swizzles Copy item path
- Required Associated Types§
    - type Vec3
    - type Vec4
- Required Methods§
    - fn xx(self) -> Self
    - fn yx(self) -> Self
    - fn yy(self) -> Self
    - fn xxx(self) -> Self::Vec3
    - fn xxy(self) -> Self::Vec3

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Vec2Swizzles:
    Sized
    + Copy
    + Clone {
    type Vec3;
    type Vec4;

Show 28 methods    // Required methods
    fn xx(self) -> Self;
    fn yx(self) -> Self;
    fn yy(self) -> Self;
    fn xxx(self) -> Self::Vec3;
    fn xxy(self) -> Self::Vec3;
    fn xyx(self) -> Self::Vec3;
    fn xyy(self) -> Self::Vec3;
    fn yxx(self) -> Self::Vec3;
    fn yxy(self) -> Self::Vec3;
    fn yyx(self) -> Self::Vec3;
    fn yyy(self) -> Self::Vec3;
    fn xxxx(self) -> Self::Vec4;
    fn xxxy(self) -> Self::Vec4;
    fn xxyx(self) -> Self::Vec4;
    fn xxyy(self) -> Self::Vec4;
    fn x
...
```

Example 2 (javascript):
```javascript
22fn draw_cursor(
23    camera_query: Single<(&Camera, &GlobalTransform)>,
24    window: Single<&Window>,
25    mut gizmos: Gizmos,
26) {
27    let (camera, camera_transform) = *camera_query;
28
29    if let Some(cursor_position) = window.cursor_position()
30        // Calculate a world position based on the cursor's position.
31        && let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_position)
32        // To test Camera::world_to_viewport, convert result back to viewport space and then back to world space.
33        && let Ok(viewport_check) = camera.world_to_viewp
...
```

---

## Enum ScalingMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ScalingMode.html

**Contents:**
- Enum ScalingMode Copy item path
- Variants§
  - FillCenter
  - FillStart
  - FillEnd
  - FitCenter
  - FitStart
  - FitEnd
- Trait Implementations§
  - impl Clone for ScalingMode

Represents various modes for proportional scaling of a texture.

Can be used in SpriteImageMode::Scale.

Scale the texture uniformly (maintain the texture’s aspect ratio) so that both dimensions (width and height) of the texture will be equal to or larger than the corresponding dimension of the target rectangle. Fill sprite with a centered texture.

Scales the texture to fill the target rectangle while maintaining its aspect ratio. One dimension of the texture will match the rectangle’s size, while the other dimension may exceed it. The exceeding portion is aligned to the start:

Scales the texture to fill the target rectangle while maintaining its aspect ratio. One dimension of the texture will match the rectangle’s size, while the other dimension may exceed it. The exceeding portion is aligned to the end:

Scaling the texture will maintain the original aspect ratio and ensure that the original texture fits entirely inside the rect. At least one axis (x or y) will fit exactly. The result is centered inside the rect.

Scaling the texture will maintain the original aspect ratio and ensure that the original texture fits entirely inside rect. At least one axis (x or y) will fit exactly. Aligns the result to the left and top edges of rect.

Scaling the texture will maintain the original aspect ratio and ensure that the original texture fits entirely inside rect. At least one axis (x or y) will fit exactly. Aligns the result to the right and bottom edges of rect.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ScalingMode {
    FillCenter,
    FillStart,
    FillEnd,
    FitCenter,
    FitStart,
    FitEnd,
}
```

---

## Trait Primitive2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Primitive2d.html

**Contents:**
- Trait Primitive2d Copy item path
- Implementors§
  - impl Primitive2d for Annulus
  - impl Primitive2d for Arc2d
  - impl Primitive2d for Capsule2d
  - impl Primitive2d for Circle
  - impl Primitive2d for CircularSector
  - impl Primitive2d for CircularSegment
  - impl Primitive2d for ConvexPolygon
  - impl Primitive2d for Dir2

A marker trait for 2D primitives

**Examples:**

Example 1 (unknown):
```unknown
pub trait Primitive2d { }
```

---

## Trait CurveResampleExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.CurveResampleExt.html

**Contents:**
- Trait CurveResampleExt Copy item path
- Provided Methods§
    - fn resample<I>( &self, segments: usize, interpolation: I, ) -> Result<SampleCurve<T, I>, ResamplingError>where I: Fn(&T, &T, f32) -> T,
      - §Errors
      - §Example
    - fn resample_auto( &self, segments: usize, ) -> Result<SampleAutoCurve<T>, ResamplingError>where T: StableInterpolate,
      - §Errors
    - fn resample_uneven<I>( &self, sample_times: impl IntoIterator<Item = f32>, interpolation: I, ) -> Result<UnevenSampleCurve<T, I>, ResamplingError>where I: Fn(&T, &T, f32) -> T,
      - §Errors
    - fn resample_uneven_auto( &self, sample_times: impl IntoIterator<Item = f32>, ) -> Result<UnevenSampleAutoCurve<T>, ResamplingError>where T: StableInterpolate,

Extension trait implemented by curves, allowing access to generic resampling methods as well as those based on stable interpolation.

This trait is automatically implemented for all curves.

For more information, see the module-level documentation.

Resample this Curve to produce a new one that is defined by interpolation over equally spaced sample values, using the provided interpolation to interpolate between adjacent samples. The curve is interpolated on segments segments between samples. For example, if segments is 1, only the start and end points of the curve are used as samples; if segments is 2, a sample at the midpoint is taken as well, and so on.

The interpolation takes two values by reference together with a scalar parameter and produces an owned value. The expectation is that interpolation(&x, &y, 0.0) and interpolation(&x, &y, 1.0) are equivalent to x and y respectively.

If segments is zero or if this curve has unbounded domain, then a ResamplingError is returned.

Resample this Curve to produce a new one that is defined by interpolation over equally spaced sample values, using automatic interpolation to interpolate between adjacent samples. The curve is interpolated on segments segments between samples. For example, if segments is 1, only the start and end points of the curve are used as samples; if segments is 2, a sample at the midpoint is taken as well, and so on.

If segments is zero or if this curve has unbounded domain, a ResamplingError is returned.

Resample this Curve to produce a new one that is defined by interpolation over samples taken at a given set of times. The given interpolation is used to interpolate adjacent samples, and the sample_times are expected to contain at least two valid times within the curve’s domain interval.

Redundant sample times, non-finite sample times, and sample times outside of the domain are filtered out. With an insufficient quantity of data, a ResamplingError is returned.

The domain of the produced curve stretches between the first and last sample times of the iterator.

The interpolation takes two values by reference together with a scalar parameter and produces an owned value. The expectation is that interpolation(&x, &y, 0.0) and interpolation(&x, &y, 1.0) are equivalent to x and y respectively.

If sample_times doesn’t contain at least two distinct times after filtering, a ResamplingError is returned.

Resample this Curve to produce a new one that is defined by automatic interpolation over samp

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait CurveResampleExt<T>: Curve<T> {
    // Provided methods
    fn resample<I>(
        &self,
        segments: usize,
        interpolation: I,
    ) -> Result<SampleCurve<T, I>, ResamplingError>
       where I: Fn(&T, &T, f32) -> T { ... }
    fn resample_auto(
        &self,
        segments: usize,
    ) -> Result<SampleAutoCurve<T>, ResamplingError>
       where T: StableInterpolate { ... }
    fn resample_uneven<I>(
        &self,
        sample_times: impl IntoIterator<Item = f32>,
        interpolation: I,
    ) -> Result<UnevenSampleCurve<T, I>, ResamplingError>
       where I:
...
```

Example 2 (javascript):
```javascript
let quarter_rotation = FunctionCurve::new(interval(0.0, 90.0).unwrap(), |t| Rot2::degrees(t));
// A curve which only stores three data points and uses `nlerp` to interpolate them:
let resampled_rotation = quarter_rotation.resample(3, |x, y, t| x.nlerp(*y, t));
```

---

## Struct LinearGradient Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LinearGradient.html

**Contents:**
- Struct LinearGradient Copy item path
- Fields§
- Implementations§
  - impl LinearGradient
    - pub const TO_TOP: f32 = 0f32
    - pub const TO_TOP_RIGHT: f32 = 0.785398185f32
    - pub const TO_RIGHT: f32 = 1.57079637f32
    - pub const TO_BOTTOM_RIGHT: f32 = 2.3561945f32
    - pub const TO_BOTTOM: f32 = 3.14159274f32
    - pub const TO_BOTTOM_LEFT: f32 = 3.92699099f32

https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient

The color space used for interpolation.

The direction of the gradient in radians. An angle of 0. points upward, with the value increasing in the clockwise direction.

The list of color stops

Angle of a linear gradient transitioning from bottom to top

Angle of a linear gradient transitioning from bottom-left to top-right

Angle of a linear gradient transitioning from left to right

Angle of a linear gradient transitioning from top-left to bottom-right

Angle of a linear gradient transitioning from top to bottom

Angle of a linear gradient transitioning from top-right to bottom-left

Angle of a linear gradient transitioning from right to left

Angle of a linear gradient transitioning from bottom-right to top-left

Create a new linear gradient

A linear gradient transitioning from bottom to top

A linear gradient transitioning from bottom-left to top-right

A linear gradient transitioning from left to right

A linear gradient transitioning from top-left to bottom-right

A linear gradient transitioning from top to bottom

A linear gradient transitioning from top-right to bottom-left

A linear gradient transitioning from right to left

A linear gradient transitioning from bottom-right to top-left

A linear gradient with the given angle in degrees

Interpolate in the given color_space.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LinearGradient {
    pub color_space: InterpolationColorSpace,
    pub angle: f32,
    pub stops: Vec<ColorStop>,
}
```

Example 2 (javascript):
```javascript
83fn setup(mut commands: Commands, args: Res<Args>) {
84    commands.spawn(Camera2d);
85
86    let rows_to_spawn = args.gradient_count.div_ceil(COLS);
87
88    // Create a grid of gradients
89    commands
90        .spawn(Node {
91            width: percent(100),
92            height: percent(100),
93            display: Display::Grid,
94            grid_template_columns: RepeatedGridTrack::flex(COLS as u16, 1.0),
95            grid_template_rows: RepeatedGridTrack::flex(rows_to_spawn as u16, 1.0),
96            ..default()
97        })
98        .with_children(|parent| {
99            for i i
...
```

Example 3 (unknown):
```unknown
16fn setup(mut commands: Commands) {
17    commands.spawn(Camera2d);
18    commands
19        .spawn(Node {
20            display: Display::Grid,
21            width: percent(100),
22            height: percent(100),
23
24            ..Default::default()
25        })
26        .with_children(|commands| {
27            commands.spawn((
28                Node {
29                    width: percent(100),
30                    height: percent(100),
31                    ..Default::default()
32                },
33                BackgroundColor(Color::BLACK),
34                BackgroundGradient(v
...
```

Example 4 (javascript):
```javascript
31fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
32    // Camera
33    commands.spawn((Camera2d, IsDefaultUiCamera, BoxShadowSamples(6)));
34
35    // root node
36    commands
37        .spawn(Node {
38            width: percent(100),
39            height: percent(100),
40            justify_content: JustifyContent::SpaceBetween,
41            ..default()
42        })
43        .insert(Pickable::IGNORE)
44        .with_children(|parent| {
45            // left vertical fill (border)
46            parent
47                .spawn((
48                    Node {
49             
...
```

---

## Struct Triangle3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Triangle3d.html

**Contents:**
- Struct Triangle3d Copy item path
- Fields§
- Implementations§
  - impl Triangle3d
    - pub const fn new(a: Vec3, b: Vec3, c: Vec3) -> Triangle3d
    - pub fn normal(&self) -> Result<Dir3, InvalidDirectionError>
      - §Errors
    - pub fn is_degenerate(&self) -> bool
    - pub fn is_acute(&self) -> bool
    - pub fn is_obtuse(&self) -> bool

A 3D triangle primitive.

The vertices of the triangle.

Create a new Triangle3d from points a, b, and c.

Get the normal of the triangle in the direction of the right-hand rule, assuming the vertices are ordered in a counter-clockwise direction.

The normal is computed as the cross product of the vectors ab and ac.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Checks if the triangle is degenerate, meaning it has zero area.

A triangle is degenerate if the cross product of the vectors ab and ac has a length less than 10e-7. This indicates that the three vertices are collinear or nearly collinear.

Checks if the triangle is acute, meaning all angles are less than 90 degrees

Checks if the triangle is obtuse, meaning one angle is greater than 90 degrees

Reverse the triangle by swapping the first and last vertices.

This triangle but reversed.

Get the centroid of the triangle.

This function finds the geometric center of the triangle by averaging the vertices: centroid = (a + b + c) / 3.

Get the largest side of the triangle.

Returns the two points that form the largest side of the triangle.

Get the circumcenter of the triangle.

Get the bounding box of the triangle.

Get the bounding sphere of the triangle.

The Triangle3d implements the minimal bounding sphere calculation. For acute triangles, the circumcenter is used as the center of the sphere. For the others, the bounding sphere is the minimal sphere that contains the largest side of the triangle.

Returns the default Triangle3d with the vertices [0.0, 0.5, 0.0], [-0.5, -0.5, 0.0], and [0.5, -0.5, 0.0].

Get the area of the triangle.

Get the perimeter of the triangle.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Triangle3d {
    pub vertices: [Vec3; 3],
}
```

---

## Trait ColorToPacked Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ColorToPacked.html

**Contents:**
- Trait ColorToPacked Copy item path
- Required Methods§
    - fn to_u8_array(self) -> [u8; 4]
    - fn to_u8_array_no_alpha(self) -> [u8; 3]
    - fn from_u8_array(color: [u8; 4]) -> Self
    - fn from_u8_array_no_alpha(color: [u8; 3]) -> Self
- Dyn Compatibility§
- Implementors§
  - impl ColorToPacked for LinearRgba
  - impl ColorToPacked for Srgba

Trait with methods for converting colors to packed non-color types

Convert to [u8; 4] where that makes sense (Srgba is most relevant)

Convert to [u8; 3] where that makes sense (Srgba is most relevant)

Convert from [u8; 4] where that makes sense (Srgba is most relevant)

Convert to [u8; 3] where that makes sense (Srgba is most relevant)

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ColorToPacked {
    // Required methods
    fn to_u8_array(self) -> [u8; 4];
    fn to_u8_array_no_alpha(self) -> [u8; 3];
    fn from_u8_array(color: [u8; 4]) -> Self;
    fn from_u8_array_no_alpha(color: [u8; 3]) -> Self;
}
```

---

## Struct SpawnScene Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpawnScene.html

**Contents:**
- Struct SpawnScene Copy item path
- Trait Implementations§
  - impl Clone for SpawnScene
    - fn clone(&self) -> SpawnScene
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for SpawnScene
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for SpawnScene
    - fn default() -> SpawnScene
  - impl Hash for SpawnScene

The schedule that contains scene spawning.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpawnScene;
```

---

## Struct Val2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Val2.html

**Contents:**
- Struct Val2 Copy item path
- Fields§
- Implementations§
  - impl Val2
    - pub const ZERO: Val2
    - pub const fn px(x: f32, y: f32) -> Val2
      - Examples found in repository?
    - pub const fn percent(x: f32, y: f32) -> Val2
    - pub const fn new(x: Val, y: Val) -> Val2
    - pub fn resolve( &self, scale_factor: f32, base_size: Vec2, viewport_size: Vec2, ) -> Vec2

A pair of Vals used to represent a 2-dimensional size or offset.

Translate the node along the x-axis. Val::Percent values are resolved based on the computed width of the Ui Node. Val::Auto is resolved to 0..

Translate the node along the y-axis. Val::Percent values are resolved based on the computed height of the UI Node. Val::Auto is resolved to 0..

Creates a new Val2 where both components are in logical pixels

Creates a new Val2 where both components are percentage values

Resolves this Val2 from the given scale_factor, parent_size, and viewport_size.

Component values of Val::Auto are resolved to 0.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Val2 {
    pub x: Val,
    pub y: Val,
}
```

Example 2 (javascript):
```javascript
74fn translation_system(
75    time: Res<Time>,
76    input: Res<ButtonInput<KeyCode>>,
77    mut translation_query: Query<&mut UiTransform, With<TargetNode>>,
78) {
79    let controls = [
80        (KeyCode::ArrowLeft, -Vec2::X),
81        (KeyCode::ArrowRight, Vec2::X),
82        (KeyCode::ArrowUp, -Vec2::Y),
83        (KeyCode::ArrowDown, Vec2::Y),
84    ];
85    for &(key_code, direction) in &controls {
86        if input.pressed(key_code) {
87            for mut transform in translation_query.iter_mut() {
88                let d = direction * 50.0 * time.delta_secs();
89                le
...
```

Example 3 (javascript):
```javascript
16fn setup(mut commands: Commands) {
17    commands.spawn(Camera2d);
18    commands
19        .spawn((Node {
20            display: Display::Grid,
21            align_self: AlignSelf::Center,
22            justify_self: JustifySelf::Center,
23            ..Default::default()
24        }, Pickable::IGNORE, BackgroundColor(Color::srgb(0.4, 0.4, 0.4))))
25        .with_children(|parent| {
26            let tile_colors = [
27                Color::srgb(0.2, 0.2, 0.8),
28                Color::srgb(0.8, 0.2, 0.2)
29            ];
30            for column in 0..COLUMNS {
31                for row in
...
```

---

## Macro error_span Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.error_span.html

**Contents:**
- Macro error_span Copy item path
- §Examples

Constructs a span at the error level.

Fields and attributes are set using the same syntax as the span! macro.

See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! error_span {
    (target: $target:expr, parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, parent: $parent:expr, $name:expr) => { ... };
    (parent: $parent:expr, $name:expr, $($field:tt)*) => { ... };
    (parent: $parent:expr, $name:expr) => { ... };
    (target: $target:expr, $name:expr, $($field:tt)*) => { ... };
    (target: $target:expr, $name:expr) => { ... };
    ($name:expr, $($field:tt)*) => { ... };
    ($name:expr) => { ... };
}
```

Example 2 (unknown):
```unknown
error_span!("my_span");
// is equivalent to:
span!(Level::ERROR, "my_span");
```

Example 3 (javascript):
```javascript
let span = error_span!("my span");
span.in_scope(|| {
    // do work inside the span...
});
```

---

## Derive Macro FromReflect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.FromReflect.html

**Contents:**
- Derive Macro FromReflect Copy item path
- §Field Attributes
  - §#[reflect(ignore)]
  - §#[reflect(default)]

Derives the FromReflect trait.

The #[reflect(ignore)] attribute is shared with the #[derive(Reflect)] macro and has much of the same functionality in that it denotes that a field will be ignored by the reflection API.

The only major difference is that using it with this derive requires that the field implements [Default]. Without this requirement, there would be no way for FromReflect to automatically construct missing fields that have been ignored.

If a field cannot be read, this attribute specifies a default value to be used in its place.

By default, this attribute denotes that the field’s type implements [Default]. However, it can also take in a path string to a user-defined function that will return the default value. This takes the form: #[reflect(default = "path::to::my_function")] where my_function is a parameterless function that must return some default value for the type.

Specifying a custom default can be used to give different fields their own specialized defaults, or to remove the Default requirement on fields marked with #[reflect(ignore)]. Additionally, either form of this attribute can be used to fill in fields that are simply missing, such as when converting a partially-constructed dynamic type to a concrete one.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(FromReflect)]
{
    // Attributes available to this derive:
    #[reflect]
}
```

---

## Struct Rectangle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Rectangle.html

**Contents:**
- Struct Rectangle Copy item path
- Fields§
- Implementations§
  - impl Rectangle
    - pub const fn new(width: f32, height: f32) -> Rectangle
      - Examples found in repository?
    - pub const fn from_size(size: Vec2) -> Rectangle
      - Examples found in repository?
    - pub fn from_corners(point1: Vec2, point2: Vec2) -> Rectangle
    - pub const fn from_length(length: f32) -> Rectangle

A rectangle primitive, which is like a square, except that the width and height can be different

Half of the width and height of the rectangle

Create a new Rectangle from a full width and height

Create a new Rectangle from a given full size

Create a new Rectangle from two corner points

Create a Rectangle from a single length. The resulting Rectangle will be the same size in every direction.

Get the size of the rectangle

Finds the point on the rectangle that is closest to the given point.

If the point is outside the rectangle, the returned point will be on the perimeter of the rectangle. Otherwise, it will be inside the rectangle and returned as is.

Returns the default Rectangle with a half-width and half-height of 0.5.

Get the area of the rectangle

Get the perimeter of the rectangle

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Rectangle {
    pub half_size: Vec2,
}
```

Example 2 (javascript):
```javascript
136fn setup_color_gradient_scene(
137    mut commands: Commands,
138    mut meshes: ResMut<Assets<Mesh>>,
139    mut materials: ResMut<Assets<ColorGradientMaterial>>,
140    camera_transform: Res<CameraTransform>,
141) {
142    let mut transform = camera_transform.0;
143    transform.translation += *transform.forward();
144
145    commands.spawn((
146        Mesh3d(meshes.add(Rectangle::new(0.7, 0.7))),
147        MeshMaterial3d(materials.add(ColorGradientMaterial {})),
148        transform,
149        Visibility::Hidden,
150        SceneNumber(2),
151    ));
152}
```

Example 3 (unknown):
```unknown
31fn setup_scene(
32    mut commands: Commands,
33    mut meshes: ResMut<Assets<Mesh>>,
34    mut materials: ResMut<Assets<ColorMaterial>>,
35) {
36    // World where we move the player
37    commands.spawn((
38        Mesh2d(meshes.add(Rectangle::new(1000., 700.))),
39        MeshMaterial2d(materials.add(Color::srgb(0.2, 0.2, 0.3))),
40    ));
41
42    // Player
43    commands.spawn((
44        Player,
45        Mesh2d(meshes.add(Circle::new(25.))),
46        MeshMaterial2d(materials.add(Color::srgb(6.25, 9.4, 9.1))), // RGB values exceed 1 to achieve a bright color for the bloom effect
47   
...
```

Example 4 (javascript):
```javascript
65fn spawn_fake_player(
66    mut commands: Commands,
67    mut meshes: ResMut<Assets<Mesh>>,
68    mut materials: ResMut<Assets<ColorMaterial>>,
69    chunk: Single<&TilemapChunk>,
70) {
71    let mut transform = chunk.calculate_tile_transform(UVec2::new(0, 0));
72    transform.translation.z = 1.;
73
74    commands.spawn((
75        Mesh2d(meshes.add(Rectangle::new(8., 8.))),
76        MeshMaterial2d(materials.add(Color::from(RED_400))),
77        transform,
78        MovePlayer,
79    ));
80
81    let mut transform = chunk.calculate_tile_transform(UVec2::new(5, 6));
82    transform.translati
...
```

---

## Enum EaseFunction Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.EaseFunction.html

**Contents:**
- Enum EaseFunction Copy item path
- §Example
- Variants (Non-exhaustive)§
  - Linear
  - QuadraticIn
  - QuadraticOut
  - QuadraticInOut
  - CubicIn
  - CubicOut
  - CubicInOut

Curve functions over the unit interval, commonly used for easing transitions.

EaseFunction can be used on its own to interpolate between 0.0 and 1.0. It can also be combined with EasingCurve to interpolate between other intervals and types, including vectors and rotations.

sample the smoothstep function at various points. This will return None if the parameter is outside the unit interval.

sample_clamped will clamp the parameter to the unit interval, so it always returns a value.

This is the Hermite interpolator for

f(t) = -(t * (t - 2.0))

This is the Hermite interpolator for

Behaves as EaseFunction::QuadraticIn for t < 0.5 and as EaseFunction::QuadraticOut for t >= 0.5

A quadratic has too low of a degree to be both an InOut and C², so consider using at least a cubic (such as EaseFunction::SmoothStep) if you want the acceleration to be continuous.

This is the Hermite interpolator for

f(t) = (t - 1.0)³ + 1.0

Behaves as EaseFunction::CubicIn for t < 0.5 and as EaseFunction::CubicOut for t >= 0.5

Due to this piecewise definition, this is only C¹ despite being a cubic: the acceleration jumps from +12 to -12 at t = ½.

Consider using EaseFunction::SmoothStep instead, which is also cubic, or EaseFunction::SmootherStep if you picked this because you wanted the acceleration at the endpoints to also be zero.

f(t) = (t - 1.0)³ * (1.0 - t) + 1.0

Behaves as EaseFunction::QuarticIn for t < 0.5 and as EaseFunction::QuarticOut for t >= 0.5

f(t) = (t - 1.0)⁵ + 1.0

Behaves as EaseFunction::QuinticIn for t < 0.5 and as EaseFunction::QuinticOut for t >= 0.5

Due to this piecewise definition, this is only C¹ despite being a quintic: the acceleration jumps from +40 to -40 at t = ½.

Consider using EaseFunction::SmootherStep instead, which is also quintic.

Behaves as the first half of EaseFunction::SmoothStep.

This has f″(1) = 0, unlike EaseFunction::QuadraticIn which starts similarly.

Behaves as the second half of EaseFunction::SmoothStep.

This has f″(0) = 0, unlike EaseFunction::QuadraticOut which ends similarly.

This is the Hermite interpolator for

See also smoothstep in GLSL.

Behaves as the first half of EaseFunction::SmootherStep.

This has f″(1) = 0, unlike EaseFunction::CubicIn which starts similarly.

Behaves as the second half of EaseFunction::SmootherStep.

This has f″(0) = 0, unlike EaseFunction::CubicOut which ends similarly.

f(t) = 6t⁵ - 15t⁴ + 10t³

This is the Hermite interpolator for

f(t) = 1.0 - cos(t * π / 2.0)

f(t) = sin(t * π / 2.0)

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[non_exhaustive]pub enum EaseFunction {
Show 39 variants    Linear,
    QuadraticIn,
    QuadraticOut,
    QuadraticInOut,
    CubicIn,
    CubicOut,
    CubicInOut,
    QuarticIn,
    QuarticOut,
    QuarticInOut,
    QuinticIn,
    QuinticOut,
    QuinticInOut,
    SmoothStepIn,
    SmoothStepOut,
    SmoothStep,
    SmootherStepIn,
    SmootherStepOut,
    SmootherStep,
    SineIn,
    SineOut,
    SineInOut,
    CircularIn,
    CircularOut,
    CircularInOut,
    ExponentialIn,
    ExponentialOut,
    ExponentialInOut,
    ElasticIn,
    ElasticOut,
    ElasticInOut,
    BackIn,
    BackO
...
```

Example 2 (javascript):
```javascript
let f = EaseFunction::SmoothStep;

assert_eq!(f.sample(-1.0), None);
assert_eq!(f.sample(0.0), Some(0.0));
assert_eq!(f.sample(0.5), Some(0.5));
assert_eq!(f.sample(1.0), Some(1.0));
assert_eq!(f.sample(2.0), None);
```

Example 3 (unknown):
```unknown
assert_eq!(f.sample_clamped(-1.0), 0.0);
assert_eq!(f.sample_clamped(0.0), 0.0);
assert_eq!(f.sample_clamped(0.5), 0.5);
assert_eq!(f.sample_clamped(1.0), 1.0);
assert_eq!(f.sample_clamped(2.0), 1.0);
```

---

## Enum RunFixedMainLoopSystems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/enum.RunFixedMainLoopSystems.html

**Contents:**
- Enum RunFixedMainLoopSystems Copy item path
- Variants§
  - BeforeFixedMainLoop
    - §Example
  - FixedMainLoop
    - §Example
  - AfterFixedMainLoop
    - §Example
- Trait Implementations§
  - impl Clone for RunFixedMainLoopSystems

Set enum for the systems that want to run inside RunFixedMainLoop, but before or after the fixed update logic. Systems in this set will run exactly once per frame, regardless of the number of fixed updates. They will also run under a variable timestep.

This is useful for handling things that need to run every frame, but also need to be read by the fixed update logic. See the individual variants for examples of what kind of systems should be placed in each.

Note that in contrast to most other Bevy schedules, systems added directly to RunFixedMainLoop will not be parallelized between each other.

Runs before the fixed update logic.

A good example of a system that fits here is camera movement, which needs to be updated in a variable timestep, as you want the camera to move with as much precision and updates as the frame rate allows. A physics system that needs to read the camera position and orientation, however, should run in the fixed update logic, as it needs to be deterministic and run at a fixed rate for better stability. Note that we are not placing the camera movement system in Update, as that would mean that the physics system already ran at that point.

Contains the fixed update logic. Runs FixedMain zero or more times based on delta of Time<Virtual> and Time::overstep.

Don’t place systems here, use FixedUpdate and friends instead. Use this system instead to order your systems to run specifically inbetween the fixed update logic and all other systems that run in RunFixedMainLoopSystems::BeforeFixedMainLoop or RunFixedMainLoopSystems::AfterFixedMainLoop.

Runs after the fixed update logic.

A good example of a system that fits here is a system that interpolates the transform of an entity between the last and current fixed update. See the fixed timestep example for more details.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum RunFixedMainLoopSystems {
    BeforeFixedMainLoop,
    FixedMainLoop,
    AfterFixedMainLoop,
}
```

Example 2 (unknown):
```unknown
App::new()
  .add_systems(
    RunFixedMainLoop,
    update_camera_rotation.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop))
  .add_systems(FixedUpdate, update_physics);
```

Example 3 (unknown):
```unknown
App::new()
  .add_systems(FixedUpdate, update_physics)
  .add_systems(
    RunFixedMainLoop,
    (
      // This system will be called before all interpolation systems
      // that third-party plugins might add.
      prepare_for_interpolation
        .after(RunFixedMainLoopSystems::FixedMainLoop)
        .before(RunFixedMainLoopSystems::AfterFixedMainLoop),
    )
  );
```

Example 4 (unknown):
```unknown
App::new()
  .add_systems(FixedUpdate, update_physics)
  .add_systems(
    RunFixedMainLoop,
    interpolate_transforms.in_set(RunFixedMainLoopSystems::AfterFixedMainLoop));
```

---

## Struct CubicNurbs Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicNurbs.html

**Contents:**
- Struct CubicNurbs Copy item path
    - §Non-uniformity
    - §Rationality
    - §Interpolation
    - §Tangency
    - §Continuity
    - §Usage
- Fields§
- Implementations§
  - impl<P> CubicNurbs<P>where P: VectorSpace<Scalar = f32>,

Non-uniform Rational B-Splines (NURBS) are a powerful generalization of the CubicBSpline which can represent a much more diverse class of curves (like perfect circles and ellipses).

The ‘NU’ part of NURBS stands for “Non-Uniform”. This has to do with a parameter called ‘knots’. The knots are a non-decreasing sequence of floating point numbers. The first and last three pairs of knots control the behavior of the curve as it approaches its endpoints. The intermediate pairs each control the length of one segment of the curve. Multiple repeated knot values are called “knot multiplicity”. Knot multiplicity in the intermediate knots causes a “zero-length” segment, and can create sharp corners.

The ‘R’ part of NURBS stands for “Rational”. This has to do with NURBS allowing each control point to be assigned a weighting, which controls how much it affects the curve compared to the other points.

The curve will not pass through the control points except where a knot has multiplicity four.

Tangents are automatically computed based on the position of control points.

When there is no knot multiplicity, the curve is C2 continuous, meaning it has no holes or jumps and the tangent vector changes smoothly along the entire curve length. Like the CubicBSpline, the acceleration continuity makes it useful for camera paths. Knot multiplicity of 2 in intermediate knots reduces the continuity to C1, and knot multiplicity of 3 reduces the continuity to C0. The curve is always at least C0, meaning it has no jumps or holes.

The control points of the NURBS

Build a Non-Uniform Rational B-Spline.

If provided, weights must be the same length as the control points. Defaults to equal weights.

If provided, the number of knots must be n + 4 elements, where n is the amount of control points. Defaults to open uniform knots: Self::open_uniform_knots. Knots cannot all be equal.

At least 4 points must be provided, otherwise an error will be returned.

Generates uniform knots that will generate the same curve as CubicBSpline.

“Uniform” means that the difference between two subsequent knots is the same.

Will return None if there are less than 4 control points.

Generates open uniform knots, which makes the ends of the curve pass through the start and end points.

The start and end knots have multiplicity 4, and intermediate knots have multiplicity 0 and difference of 1.

Will return None if there are less than 4 control points.

Returns the argument unchanged.

That is, this conversion i

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicNurbs<P>where
    P: VectorSpace,{
    pub control_points: Vec<P>,
    pub weights: Vec<f32>,
    pub knots: Vec<f32>,
}
```

Example 2 (javascript):
```javascript
let points = [
    vec2(-1.0, -20.0),
    vec2(3.0, 2.0),
    vec2(5.0, 3.0),
    vec2(9.0, 8.0),
];
let weights = [1.0, 1.0, 2.0, 1.0];
let knots = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0];
let nurbs = CubicNurbs::new(points, Some(weights), Some(knots))
    .expect("NURBS construction failed!")
    .to_curve()
    .unwrap();
let positions: Vec<_> = nurbs.iter_positions(100).collect();
```

---

## Enum GamepadAxis Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GamepadAxis.html

**Contents:**
- Enum GamepadAxis Copy item path
  - §Usage
- Variants§
  - LeftStickX
  - LeftStickY
  - LeftZ
  - RightStickX
  - RightStickY
  - RightZ
  - Other(u8)

Represents gamepad input types that are mapped in the range [-1.0, 1.0].

This is used to determine which axis has changed its value when receiving a gamepad axis event. It is also used in the Gamepad component.

The horizontal value of the left stick.

The vertical value of the left stick.

Generally the throttle axis of a HOTAS setup. Refer to GamepadButton::LeftTrigger2 for the analog trigger on a gamepad controller.

The horizontal value of the right stick.

The vertical value of the right stick.

The yaw of the main joystick, not supported on common gamepads. Refer to GamepadButton::RightTrigger2 for the analog trigger on a gamepad controller.

Non-standard support for other axis types (i.e. HOTAS sliders, potentiometers, etc).

Returns an array of all the standard GamepadAxis.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GamepadAxis {
    LeftStickX,
    LeftStickY,
    LeftZ,
    RightStickX,
    RightStickY,
    RightZ,
    Other(u8),
}
```

---

## Struct OnExit Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.OnExit.html

**Contents:**
- Struct OnExit Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<S> Clone for OnExit<S>where S: Clone + States,
    - fn clone(&self) -> OnExit<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for OnExit<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Default for OnExit<S>where S: Default + States,
    - fn default() -> OnExit<S>

The label of a Schedule that only runs whenever State<S> exits the provided state.

This schedule ignores identity transitions.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct OnExit<S>(pub S)
where
    S: States;
```

---

## Function run_once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.run_once.html

**Contents:**
- Function run_once Copy item path
- §Example

A SystemCondition-satisfying system that returns true on the first time the condition is run and false every time after.

**Examples:**

Example 1 (unknown):
```unknown
pub fn run_once(has_run: Local<'_, bool>) -> bool
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `run_once` will only return true the first time it's evaluated
    my_system.run_if(run_once),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// This is the first time the condition will be evaluated so `my_system` will run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);

// This is the seconds time the condition will be evaluated so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Struct PostUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PostUpdate.html

**Contents:**
- Struct PostUpdate Copy item path
- Trait Implementations§
  - impl Clone for PostUpdate
    - fn clone(&self) -> PostUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PostUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PostUpdate
    - fn default() -> PostUpdate
  - impl Hash for PostUpdate

The schedule that contains logic that must run after Update. For example, synchronizing “local transforms” in a hierarchy to “global” absolute transforms. This enables the PostUpdate transform-sync system to react to “local transform” changes in Update without the Update systems needing to know about (or add scheduler dependencies for) the “global transform sync system”.

PostUpdate exists to do “engine/plugin response work” to things that happened in Update. PostUpdate abstracts out “implementation details” from users defining systems in Update.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PostUpdate;
```

---

## Struct Annulus Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Annulus.html

**Contents:**
- Struct Annulus Copy item path
- Fields§
- Implementations§
  - impl Annulus
    - pub const fn new(inner_radius: f32, outer_radius: f32) -> Annulus
      - Examples found in repository?
    - pub const fn diameter(&self) -> f32
    - pub const fn thickness(&self) -> f32
    - pub fn closest_point(&self, point: Vec2) -> Vec2
- Trait Implementations§

A primitive shape formed by the region between two circles, also known as a ring.

The inner circle of the annulus

The outer circle of the annulus

Create a new Annulus from the radii of the inner and outer circle

Get the diameter of the annulus

Get the thickness of the annulus

Finds the point on the annulus that is closest to the given point:

Returns the default Annulus with radii of 0.5 and 1.0.

Get the area of the annulus

Get the perimeter or circumference of the annulus, which is the sum of the perimeters of the inner and outer circles.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Annulus {
    pub inner_circle: Circle,
    pub outer_circle: Circle,
}
```

Example 2 (javascript):
```javascript
104fn setup_scene(
105    mut commands: Commands,
106    mut meshes: ResMut<Assets<Mesh>>,
107    mut materials: ResMut<Assets<ColorMaterial>>,
108) {
109    commands.spawn(Camera2d);
110
111    let named_shapes = [
112        (Name::new("Annulus"), meshes.add(Annulus::new(25.0, 50.0))),
113        (
114            Name::new("Bestagon"),
115            meshes.add(RegularPolygon::new(50.0, 6)),
116        ),
117        (Name::new("Rhombus"), meshes.add(Rhombus::new(75.0, 100.0))),
118    ];
119    let num_shapes = named_shapes.len();
120
121    for (i, (name, shape)) in named_shapes.into_iter()
...
```

Example 3 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 4 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

---

## Struct StateTransitionEvent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.StateTransitionEvent.html

**Contents:**
- Struct StateTransitionEvent Copy item path
- Fields§
- Trait Implementations§
  - impl<S> Clone for StateTransitionEvent<S>where S: Clone + States,
    - fn clone(&self) -> StateTransitionEvent<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for StateTransitionEvent<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> PartialEq for StateTransitionEvent<S>where S: PartialEq + States,
    - fn eq(&self, other: &StateTransitionEvent<S>) -> bool

A Message sent when any state transition of S happens. This includes identity transitions, where exited and entered have the same value.

If you know exactly what state you want to respond to ahead of time, consider OnEnter, OnTransition, or OnExit

The state being exited.

The state being entered.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct StateTransitionEvent<S>where
    S: States,{
    pub exited: Option<S>,
    pub entered: Option<S>,
}
```

---

## Trait Component Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Component.html

**Contents:**
- Trait Component Copy item path
- §Examples
- §Component and data access
- §Choosing a storage type
- §Required Components
  - §Registering required components at runtime
- §Relationships between Entities
- §Adding component’s hooks
- §Setting the clone behavior
- §Implementing the trait for foreign types

A data type that can be used to store data for an entity.

Component is a derivable trait: this means that a data type can implement it by applying a #[derive(Component)] attribute to it. However, components must always satisfy the Send + Sync + 'static trait bounds.

Components can take many forms: they are usually structs, but can also be of every other kind of data type, like enums or zero sized types. The following examples show how components are laid out in code.

Components can be marked as immutable by adding the #[component(immutable)] attribute when using the derive macro. See the documentation for ComponentMutability for more details around this feature.

See the entity module level documentation to learn how to add or remove components from an entity.

See the documentation for Query to learn how to access component data from a system.

Components can be stored in the world using different strategies with their own performance implications. By default, components are added to the Table storage, which is optimized for query iteration.

Alternatively, components can be added to the SparseSet storage, which is optimized for component insertion and removal. This is achieved by adding an additional #[component(storage = "SparseSet")] attribute to the derive one:

Components can specify Required Components. If some Component A requires Component B, then when A is inserted, B will also be initialized and inserted (if it was not manually specified).

The Default constructor will be used to initialize the component, by default:

Components can have more than one required component:

You can define inline component values that take the following forms:

You can also define arbitrary expressions by using =

Required components are recursive. This means, if a Required Component has required components, those components will also be inserted if they are missing:

Note that cycles in the “component require tree” will result in stack overflows when attempting to insert a component.

This “multiple inheritance” pattern does mean that it is possible to have duplicate requires for a given type at different levels of the inheritance tree:

In general, this shouldn’t happen often, but when it does the algorithm for choosing the constructor from the tree is simple and predictable:

From a user perspective, just think about this as the following:

In most cases, required components should be registered using the require attribute as shown above. However, in some cas

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
pub trait Component:
    Send
    + Sync
    + 'static {
    type Mutability: ComponentMutability;

    const STORAGE_TYPE: StorageType;

    // Provided methods
    fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)> { ... }
    fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)> { ... }
    fn on_replace() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)> { ... }
    fn on_remove() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)> { ... }
    fn on_despawn() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)> { ... }
    fn register_required_component
...
```

Example 2 (unknown):
```unknown
// A component can contain data...
#[derive(Component)]
struct LicensePlate(String);

// ... but it can also be a zero-sized marker.
#[derive(Component)]
struct Car;

// Components can also be structs with named fields...
#[derive(Component)]
struct VehiclePerformance {
    acceleration: f32,
    top_speed: f32,
    handling: f32,
}

// ... or enums.
#[derive(Component)]
enum WheelCount {
    Two,
    Three,
    Four,
}
```

Example 3 (unknown):
```unknown
#[derive(Component)]
#[component(storage = "SparseSet")]
struct ComponentA;
```

Example 4 (javascript):
```javascript
#[derive(Component)]
#[require(B)]
struct A;

#[derive(Component, Default, PartialEq, Eq, Debug)]
struct B(usize);

// This will implicitly also insert B with the Default constructor
let id = world.spawn(A).id();
assert_eq!(&B(0), world.entity(id).get::<B>().unwrap());

// This will _not_ implicitly insert B, because it was already provided
world.spawn((A, B(11)));
```

---

## Struct Axis Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Axis.html

**Contents:**
- Struct Axis Copy item path
- Implementations§
  - impl<T> Axis<T>where T: Copy + Eq + Hash,
    - pub const MIN: f32 = -1f32
    - pub const MAX: f32 = 1f32
    - pub fn set( &mut self, input_device: impl Into<T>, position_data: f32, ) -> Option<f32>
    - pub fn get(&self, input_device: impl Into<T>) -> Option<f32>
    - pub fn get_unclamped(&self, input_device: impl Into<T>) -> Option<f32>
    - pub fn remove(&mut self, input_device: impl Into<T>) -> Option<f32>
    - pub fn all_axes(&self) -> impl Iterator<Item = &T>

Stores the position data of the input devices of type T.

The values are stored as f32s, using Axis::set. Use Axis::get to retrieve the value clamped between Axis::MIN and Axis::MAX inclusive, or unclamped using Axis::get_unclamped.

The smallest possible axis value.

The largest possible axis value.

Sets the position data of the input_device to position_data.

Returns the position data of the provided input_device.

This will be clamped between Axis::MIN and Axis::MAX inclusive.

Returns the unclamped position data of the provided input_device.

This value may be outside the Axis::MIN and Axis::MAX range.

Use for things like camera zoom, where you want devices like mouse wheels to be able to exceed the normal range. If being able to move faster on one input device than another would give an unfair advantage, you should likely use Axis::get instead.

Removes the position data of the input_device, returning the position data if the input device was previously set.

Returns an iterator over all axes.

Returns an iterator over all axes and their values.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Axis<T> { /* private fields */ }
```

---

## Struct Time Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Time.html

**Contents:**
- Struct Time Copy item path
- §Accessing clocks
- §Adding custom clocks
- Implementations§
  - impl Time<Fixed>
    - pub fn from_duration(timestep: Duration) -> Time<Fixed>
      - §Panics
      - Examples found in repository?
    - pub fn from_seconds(seconds: f64) -> Time<Fixed>
      - §Panics

A generic clock resource that tracks how much it has advanced since its previous update and since its creation.

Multiple instances of this resource are inserted automatically by TimePlugin:

The time elapsed since the previous time this clock was advanced is saved as delta() and the total amount of time the clock has advanced is saved as elapsed(). Both are represented as exact Duration values with fixed nanosecond precision. The clock does not support time moving backwards, but it can be updated with Duration::ZERO which will set delta() to zero.

These values are also available in seconds as f32 via delta_secs() and elapsed_secs(), and also in seconds as f64 via delta_secs_f64() and elapsed_secs_f64().

Since elapsed_secs() will grow constantly and is f32, it will exhibit gradual precision loss. For applications that require an f32 value but suffer from gradual precision loss there is elapsed_secs_wrapped() available. The same wrapped value is also available as Duration and f64 for consistency. The wrap period is by default 1 hour, and can be set by set_wrap_period().

By default, any systems requiring current delta() or elapsed() should use Res<Time> to access the default time configured for the program. By default, this refers to Time<Virtual> except during the FixedMain schedule when it refers to Time<Fixed>. This ensures your system can be used either in Update or FixedUpdate schedule depending on what is needed.

If your system needs to react based on real time (wall clock time), like for user interfaces, it should use Res<Time<Real>>. The delta() and elapsed() values will always correspond to real time and will not be affected by pause, time scaling or other tweaks.

If your system specifically needs to access fixed timestep clock, even when placed in Update schedule, you should use Res<Time<Fixed>>. The delta() and elapsed() values will correspond to the latest fixed timestep that has been run.

Finally, if your system specifically needs to know the current virtual game time, even if placed inside FixedUpdate, for example to know if the game is was_paused() or to use effective_speed(), you can use Res<Time<Virtual>>. However, if the system is placed in FixedUpdate, extra care must be used because your system might be run multiple times with the same delta() and elapsed() values as the virtual game time has not changed between the iterations.

If you need to change the settings for any of the clocks, for example to pause() the game, you should use

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Time<T = ()>where
    T: Default,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
fn ambivalent_system(time: Res<Time>) {
    println!("this how I see time: delta {:?}, elapsed {:?}", time.delta(), time.elapsed());
}
```

Example 3 (unknown):
```unknown
fn real_time_system(time: Res<Time<Real>>) {
    println!("this will always be real time: delta {:?}, elapsed {:?}", time.delta(), time.elapsed());
}
```

Example 4 (unknown):
```unknown
fn fixed_time_system(time: Res<Time<Fixed>>) {
    println!("this will always be the last executed fixed timestep: delta {:?}, elapsed {:?}", time.delta(), time.elapsed());
}
```

---

## Struct Capsule3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Capsule3d.html

**Contents:**
- Struct Capsule3d Copy item path
- Fields§
- Implementations§
  - impl Capsule3d
    - pub const fn new(radius: f32, length: f32) -> Capsule3d
      - Examples found in repository?
    - pub const fn to_cylinder(&self) -> Cylinder
- Trait Implementations§
  - impl Bounded3d for Capsule3d
    - fn aabb_3d(&self, isometry: impl Into<Isometry3d>) -> Aabb3d

A 3D capsule primitive centered on the origin A three-dimensional capsule is defined as a surface at a distance (radius) from a line

The radius of the capsule

Half the height of the capsule, excluding the hemispheres

Create a new Capsule3d from a radius and length

Get the part connecting the hemispherical ends of the capsule as a Cylinder

Returns the default Capsule3d with a radius of 0.5 and a segment length of 1.0. The total height is 2.0.

Get the surface area of the capsule

Get the volume of the capsule

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Capsule3d {
    pub radius: f32,
    pub half_length: f32,
}
```

Example 2 (javascript):
```javascript
42fn setup(
43    parameters: Res<Parameters>,
44    mut commands: Commands,
45    mut meshes: ResMut<Assets<Mesh>>,
46    mut materials: ResMut<Assets<StandardMaterial>>,
47    asset_server: Res<AssetServer>,
48) {
49    // ground plane
50    commands.spawn((
51        Mesh3d(meshes.add(Plane3d::default().mesh().size(10.0, 10.0))),
52        MeshMaterial3d(materials.add(StandardMaterial {
53            base_color: Color::WHITE,
54            perceptual_roughness: 1.0,
55            ..default()
56        })),
57    ));
58
59    // left wall
60    let mut transform = Transform::from_xyz(2.5, 2.
...
```

---

## Crate light Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/light/index.html

**Contents:**
- Crate light Copy item path
- Modules§
- Structs§
- Enums§
- Functions§
- Type Aliases§

bevyCrate light Copy item pathSource Modules§cascadeclusterSpatial clustering of objects, currently just point and spot lights.preludeThe light prelude.Structs§AmbientLightAn ambient light, which lights the entire scene equally.AtmosphereEnvironmentMapLightLets the atmosphere contribute environment lighting (reflections and ambient diffuse) to your scene.CascadeShadowConfigControls how cascaded shadow mapping works. Prefer using CascadeShadowConfigBuilder to construct an instance.CascadeShadowConfigBuilderBuilder for CascadeShadowConfig.CascadesClusteredDecalAn object that projects a decal onto surfaces within its bounds.DirectionalLightA Directional light.DirectionalLightShadowMapControls the resolution of DirectionalLight and SpotLight shadow maps.DirectionalLightTextureAdd to a DirectionalLight to add a light texture effect. A texture mask is applied to the light source to modulate its intensity, simulating patterns like window shadows, gobo/cookie effects, or soft falloffs.EnvironmentMapLightA pair of cubemap textures that represent the surroundings of a specific area in space.FogVolumeGeneratedEnvironmentMapLightA generated environment map that is filtered at runtime.IrradianceVolumeThe component that defines an irradiance volume.LightPluginLightProbeA marker component for a light probe, which is a cuboid region that provides global illumination to all fragments inside it.NotShadowCasterAdd this component to make a Mesh3d not cast shadows.NotShadowReceiverAdd this component to make a Mesh3d not receive shadows.PointLightA light that emits light in all directions from a central point.PointLightShadowMapControls the resolution of PointLight shadow maps.PointLightTextureAdd to a PointLight to add a light texture effect. A texture mask is applied to the light source to modulate its intensity, simulating patterns like window shadows, gobo/cookie effects, or soft falloffs.SpotLightA light that emits light in a given direction from a central point.SpotLightTextureAdd to a SpotLight to add a light texture effect. A texture mask is applied to the light source to modulate its intensity, simulating patterns like window shadows, gobo/cookie effects, or soft falloffs.SunDiskAdd to a DirectionalLight to control rendering of the visible solar disk in the sky. Affects only the disk’s appearance, not the light’s illuminance or shadows. Requires a bevy::pbr::Atmosphere component on a Camera3d to have any effect.TransmittedShadowReceiverAdd this component to make a Mesh

*[Content truncated]*

---

## Struct CursorMoved Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CursorMoved.html

**Contents:**
- Struct CursorMoved Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for CursorMoved
    - fn clone(&self) -> CursorMoved
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for CursorMoved
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'de> Deserialize<'de> for CursorMoved
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<CursorMoved, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,

An event reporting that the mouse cursor has moved inside a window.

The event is sent only if the cursor is over one of the application’s windows. It is the translated version of WindowEvent::CursorMoved from the winit crate with the addition of delta.

Not to be confused with the MouseMotion event from bevy_input.

Because the range of data is limited by the window area and it may have been transformed by the OS to implement certain effects like acceleration, you should not use it for non-cursor-like behavior such as 3D camera control. Please see MouseMotion instead.

Window that the cursor moved inside.

The cursor position in logical pixels.

The change in the position of the cursor since the last event was sent. This value is None if the cursor was outside the window area during the last frame.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CursorMoved {
    pub window: Entity,
    pub position: Vec2,
    pub delta: Option<Vec2>,
}
```

---

## Struct RenderStartup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/render/struct.RenderStartup.html

**Contents:**
- Struct RenderStartup Copy item path
- Trait Implementations§
  - impl Clone for RenderStartup
    - fn clone(&self) -> RenderStartup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for RenderStartup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for RenderStartup
    - fn default() -> RenderStartup
  - impl Hash for RenderStartup

The startup schedule of the RenderApp

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RenderStartup;
```

---

## Struct GizmoConfig Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GizmoConfig.html

**Contents:**
- Struct GizmoConfig Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for GizmoConfig
    - fn clone(&self) -> GizmoConfig
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for GizmoConfig
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for GizmoConfig
    - fn default() -> GizmoConfig

A struct that stores configuration for gizmos.

Set to false to stop drawing gizmos.

How closer to the camera than real geometry the gizmos should be.

In 2D this setting has no effect and is effectively always -1.

Value between -1 and 1 (inclusive).

This is typically useful if you are drawing wireframes on top of polygons and your wireframe is z-fighting (flickering on/off) with your main model. You would set this value to a negative number close to 0.

Describes which rendering layers gizmos will be rendered to.

Gizmos will only be rendered to cameras with intersecting layers.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GizmoConfig {
    pub enabled: bool,
    pub line: GizmoLineConfig,
    pub depth_bias: f32,
    pub render_layers: RenderLayers,
}
```

---

## Function propagate_inherited Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/fn.propagate_inherited.html

**Contents:**
- Function propagate_inherited Copy item path

add/remove Inherited::<C> for targets of entities with modified Inherited::<C>

**Examples:**

Example 1 (unknown):
```unknown
pub fn propagate_inherited<C, F, R>(
    commands: Commands<'_, '_>,
    changed: Query<'_, '_, (&Inherited<C>, &<R as Relationship>::RelationshipTarget), (Changed<Inherited<C>>, Without<PropagateStop<C>>, F)>,
    recurse: Query<'_, '_, (Option<&<R as Relationship>::RelationshipTarget>, Option<&Inherited<C>>), (Without<Propagate<C>>, Without<PropagateStop<C>>, F)>,
    removed: RemovedComponents<'_, '_, Inherited<C>>,
    to_process: Local<'_, Vec<(Entity, Option<Inherited<C>>)>>,
)where
    C: Component + Clone + PartialEq,
    F: QueryFilter,
    R: Relationship,
```

---

## Struct Extrusion Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Extrusion.html

**Contents:**
- Struct Extrusion Copy item path
- Fields§
- Implementations§
  - impl<T> Extrusion<T>where T: Primitive2d,
    - pub fn new(base_shape: T, depth: f32) -> Extrusion<T>
      - Examples found in repository?
- Trait Implementations§
  - impl<T> Bounded3d for Extrusion<T>where T: BoundedExtrusion,
    - fn aabb_3d(&self, isometry: impl Into<Isometry3d>) -> Aabb3d
    - fn bounding_sphere(&self, isometry: impl Into<Isometry3d>) -> BoundingSphere

A 3D shape representing an extruded 2D base_shape.

Extruding a shape effectively “thickens” a 2D shapes, creating a shape with the same cross-section over the entire depth.

The resulting volumes are prisms. For example, a triangle becomes a triangular prism, while a circle becomes a cylinder.

The base shape of the extrusion

Half of the depth of the extrusion

Create a new Extrusion<T> from a given base_shape and depth

Get the surface area of the extrusion

Get the volume of the extrusion

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Extrusion<T>where
    T: Primitive2d,{
    pub base_shape: T,
    pub half_depth: f32,
}
```

Example 2 (javascript):
```javascript
54fn setup(
55    mut commands: Commands,
56    mut meshes: ResMut<Assets<Mesh>>,
57    mut images: ResMut<Assets<Image>>,
58    mut materials: ResMut<Assets<StandardMaterial>>,
59) {
60    let debug_material = materials.add(StandardMaterial {
61        base_color_texture: Some(images.add(uv_debug_texture())),
62        ..default()
63    });
64
65    let shapes = [
66        meshes.add(Cuboid::default()),
67        meshes.add(Tetrahedron::default()),
68        meshes.add(Capsule3d::default()),
69        meshes.add(Torus::default()),
70        meshes.add(Cylinder::default()),
71        meshes.a
...
```

Example 3 (javascript):
```javascript
43fn setup_scene(
44    mut commands: Commands,
45    mut meshes: ResMut<Assets<Mesh>>,
46    mut materials: ResMut<Assets<StandardMaterial>>,
47) {
48    // Set up the materials.
49    let white_matl = materials.add(Color::WHITE);
50    let ground_matl = materials.add(Color::from(GRAY_300));
51    let hover_matl = materials.add(Color::from(CYAN_300));
52    let pressed_matl = materials.add(Color::from(YELLOW_300));
53
54    let shapes = [
55        meshes.add(Cuboid::default()),
56        meshes.add(Tetrahedron::default()),
57        meshes.add(Capsule3d::default()),
58        meshes.add(Toru
...
```

---

## Struct Hsla Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Hsla.html

**Contents:**
- Struct Hsla Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Hsla
    - pub const fn new(hue: f32, saturation: f32, lightness: f32, alpha: f32) -> Hsla
      - §Arguments
      - Examples found in repository?
    - pub const fn hsl(hue: f32, saturation: f32, lightness: f32) -> Hsla
      - §Arguments

Color in Hue-Saturation-Lightness (HSL) color space with alpha. Further information on this color model can be found on Wikipedia.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The hue channel. [0.0, 360.0]

The saturation channel. [0.0, 1.0]

The lightness channel. [0.0, 1.0]

The alpha channel. [0.0, 1.0]

Construct a new Hsla color from components.

Construct a new Hsla color from (h, s, l) components, with the default alpha (1.0).

Return a copy of this color with the saturation channel set to the given value.

Return a copy of this color with the lightness channel set to the given value.

Generate a deterministic but quasi-randomly distributed color from a provided index.

This can be helpful for generating debug colors.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Hsla {
    pub hue: f32,
    pub saturation: f32,
    pub lightness: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

Example 3 (javascript):
```javascript
75const DESELECTED: Hsla = Hsla::new(0.0, 0.3, 0.2, 0.92);
```

Example 4 (javascript):
```javascript
74const SELECTED: Hsla = Hsla::hsl(0.0, 0.9, 0.7);
```

---

## Struct Oklcha Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Oklcha.html

**Contents:**
- Struct Oklcha Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Oklcha
    - pub const fn new(lightness: f32, chroma: f32, hue: f32, alpha: f32) -> Oklcha
      - §Arguments
    - pub const fn lch(lightness: f32, chroma: f32, hue: f32) -> Oklcha
      - §Arguments
    - pub const fn with_lightness(self, lightness: f32) -> Oklcha

Color in Oklch color space, with alpha

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The ‘lightness’ channel. [0.0, 1.0]

The ‘chroma’ channel. [0.0, 1.0]

The ‘hue’ channel. [0.0, 360.0]

The alpha channel. [0.0, 1.0]

Construct a new Oklcha color from components.

Construct a new Oklcha color from (l, c, h) components, with the default alpha (1.0).

Return a copy of this color with the ‘lightness’ channel set to the given value.

Return a copy of this color with the ‘chroma’ channel set to the given value.

Generate a deterministic but quasi-randomly distributed color from a provided index.

This can be helpful for generating debug colors.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Oklcha {
    pub lightness: f32,
    pub chroma: f32,
    pub hue: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

Example 3 (javascript):
```javascript
// Unique color for an entity
// let entity_index = entity.index();
let color = Oklcha::sequential_dispersed(entity_index);

// Palette with 5 distinct hues
let palette = (0..5).map(Oklcha::sequential_dispersed).collect::<Vec<_>>();
```

---

## Struct Query Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Query.html

**Contents:**
- Struct Query Copy item path
- §Similar parameters
- §System parameter declaration
  - §Component access
  - §Query filtering
  - §QueryData or QueryFilter tuples
  - §Entity identifier access
  - §Optional component access
  - §Disjoint queries
  - §Whole Entity Access

A system parameter that provides selective access to the Component data stored in a World.

Queries enable systems to access entity identifiers and components without requiring direct access to the World. Its iterators and getter methods return query items, which are types containing data related to an entity.

Query is a generic data structure that accepts two type parameters:

Query has few sibling SystemParams, which perform additional validation:

These parameters will prevent systems from running if their requirements are not met.

A query should always be declared as a system parameter. This section shows the most common idioms involving the declaration of Query.

You can fetch an entity’s component by specifying a reference to that component in the query’s data parameter:

Note that components need to be behind a reference (& or &mut), or the query will not compile:

Setting the query filter type parameter will ensure that each query item satisfies the given condition:

Note that the filter is With<ComponentB>, not With<&ComponentB>. Unlike query data, With does not require components to be behind a reference.

Using tuples, each Query type parameter can contain multiple elements.

In the following example two components are accessed simultaneously, and the query items are filtered on two conditions:

Note that this currently only works on tuples with 15 or fewer items. You may nest tuples to get around this limit:

You can access Entity, the entity identifier, by including it in the query data parameter:

Be aware that Entity is not a component, so it does not need to be behind a reference.

A component can be made optional by wrapping it into an Option. In the following example, a query item will still be generated even if the queried entity does not contain ComponentB. When this is the case, Option<&ComponentB>’s corresponding value will be None.

Optional components can hurt performance in some cases, so please read the performance section to learn more about them. Additionally, if you need to declare several optional components, you may be interested in using AnyOf.

A system cannot contain two queries that break Rust’s mutability rules, or else it will panic when initialized. This can often be fixed with the Without filter, which makes the queries disjoint.

In the following example, the two queries can mutably access the same &mut Health component if an entity has both the Player and Enemy components. Bevy will catch this and panic, however, 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Query<'world, 'state, D, F = ()>where
    D: QueryData,
    F: QueryFilter,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
// A component can be accessed by a shared reference...
fn immutable_query(query: Query<&ComponentA>) {
    // ...
}

// ...or by a mutable reference.
fn mutable_query(query: Query<&mut ComponentA>) {
    // ...
}
```

Example 3 (unknown):
```unknown
// This needs to be `&ComponentA` or `&mut ComponentA` in order to compile.
fn invalid_query(query: Query<ComponentA>) {
    // ...
}
```

Example 4 (unknown):
```unknown
// `ComponentA` data will be accessed, but only for entities that also contain `ComponentB`.
fn filtered_query(query: Query<&ComponentA, With<ComponentB>>) {
    // ...
}
```

---

## Struct SampleAutoCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SampleAutoCurve.html

**Contents:**
- Struct SampleAutoCurve Copy item path
- Implementations§
  - impl<T> SampleAutoCurve<T>
    - pub fn new( domain: Interval, samples: impl IntoIterator<Item = T>, ) -> Result<SampleAutoCurve<T>, EvenCoreError>
- Trait Implementations§
  - impl<T> Clone for SampleAutoCurve<T>where T: Clone,
    - fn clone(&self) -> SampleAutoCurve<T>
    - fn clone_from(&mut self, source: &Self)
  - impl<T> Curve<T> for SampleAutoCurve<T>where T: StableInterpolate,
    - fn domain(&self) -> Interval

A curve that is defined by neighbor interpolation over a set of evenly-spaced samples, interpolated automatically using a particularly well-behaved interpolation.

Create a new SampleCurve using type-inferred interpolation to interpolate between the given samples. An error is returned if there are not at least 2 samples or if the given domain is unbounded.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SampleAutoCurve<T> { /* private fields */ }
```

---

## Struct PanicHandlerPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PanicHandlerPlugin.html

**Contents:**
- Struct PanicHandlerPlugin Copy item path
- Trait Implementations§
  - impl Default for PanicHandlerPlugin
    - fn default() -> PanicHandlerPlugin
  - impl Plugin for PanicHandlerPlugin
    - fn build(&self, _app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

Adds sensible panic handlers to Apps. This plugin is part of the DefaultPlugins. Adding this plugin will setup a panic hook appropriate to your target platform:

If you want to setup your own panic handler, you should disable this plugin from DefaultPlugins:

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PanicHandlerPlugin;
```

Example 2 (unknown):
```unknown
fn main() {
    App::new()
        .add_plugins(MinimalPlugins)
        .add_plugins(PanicHandlerPlugin)
        .run();
}
```

Example 3 (unknown):
```unknown
fn main() {
    App::new()
        .add_plugins(DefaultPlugins.build().disable::<PanicHandlerPlugin>())
        .run();
}
```

---

## Struct Over Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Over.html

**Contents:**
- Struct Over Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Over
    - fn clone(&self) -> Over
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Over
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Over
    - type This<'from_arg> = Over

Fires when a pointer crosses into the bounds of the target entity.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Over {
    pub hit: HitData,
}
```

---

## Enum PluginsState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/enum.PluginsState.html

**Contents:**
- Enum PluginsState Copy item path
- Variants§
  - Adding
  - Ready
  - Finished
  - Cleaned
- Trait Implementations§
  - impl Clone for PluginsState
    - fn clone(&self) -> PluginsState
    - fn clone_from(&mut self, source: &Self)

Plugins state in the application

Plugins are being added.

All plugins already added are ready.

Finish has been executed for all plugins added.

Cleanup has been executed for all plugins added.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum PluginsState {
    Adding,
    Ready,
    Finished,
    Cleaned,
}
```

---

## Struct Plane3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Plane3d.html

**Contents:**
- Struct Plane3d Copy item path
- Fields§
- Implementations§
  - impl Plane3d
    - pub fn new(normal: Vec3, half_size: Vec2) -> Plane3d
      - §Panics
      - Examples found in repository?
    - pub fn from_points(a: Vec3, b: Vec3, c: Vec3) -> (Plane3d, Vec3)
      - §Panics
- Trait Implementations§

A bounded plane in 3D space. It forms a surface starting from the origin with a defined height and width.

The normal of the plane. The plane will be placed perpendicular to this direction

Half of the width and height of the plane

Create a new Plane3d from a normal and a half size

Panics if the given normal is zero (or very close to zero), or non-finite.

Create a new Plane3d based on three points and compute the geometric center of those points.

The direction of the plane normal is determined by the winding order of the triangular shape formed by the points.

Panics if a valid normal can not be computed, for example when the points are collinear and lie on the same line.

Returns the default Plane3d with a normal pointing in the +Y direction, width and height of 1.0.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Plane3d {
    pub normal: Dir3,
    pub half_size: Vec2,
}
```

Example 2 (javascript):
```javascript
196fn spawn_plane(
197    commands: &mut Commands,
198    meshes: &mut Assets<Mesh>,
199    show_depth_texture_materials: &mut Assets<ShowDepthTextureMaterial>,
200    demo_depth_texture: &DemoDepthTexture,
201) {
202    let plane_handle = meshes.add(Plane3d::new(Vec3::Z, Vec2::splat(2.0)));
203    let show_depth_texture_material = show_depth_texture_materials.add(ShowDepthTextureMaterial {
204        depth_texture: Some(demo_depth_texture.0.clone()),
205    });
206    commands.spawn((
207        Mesh3d(plane_handle),
208        MeshMaterial3d(show_depth_texture_material),
209        Transform
...
```

Example 3 (javascript):
```javascript
150fn spawn_world_model(
151    mut commands: Commands,
152    mut meshes: ResMut<Assets<Mesh>>,
153    mut materials: ResMut<Assets<StandardMaterial>>,
154) {
155    let floor = meshes.add(Plane3d::new(Vec3::Y, Vec2::splat(10.0)));
156    let cube = meshes.add(Cuboid::new(2.0, 0.5, 1.0));
157    let material = materials.add(Color::WHITE);
158
159    // The world model camera will render the floor and the cubes spawned in this system.
160    // Assigning no `RenderLayers` component defaults to layer 0.
161
162    commands.spawn((Mesh3d(floor), MeshMaterial3d(material.clone())));
163
164    com
...
```

Example 4 (unknown):
```unknown
180fn spawn_water(
181    commands: &mut Commands,
182    asset_server: &AssetServer,
183    meshes: &mut Assets<Mesh>,
184    water_materials: &mut Assets<ExtendedMaterial<StandardMaterial, Water>>,
185) {
186    commands.spawn((
187        Mesh3d(meshes.add(Plane3d::new(Vec3::Y, Vec2::splat(1.0)))),
188        MeshMaterial3d(water_materials.add(ExtendedMaterial {
189            base: StandardMaterial {
190                base_color: BLACK.into(),
191                perceptual_roughness: 0.0,
192                ..default()
193            },
194            extension: Water {
195               
...
```

---

## Enum ParallaxMappingMethod Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/pbr/enum.ParallaxMappingMethod.html

**Contents:**
- Enum ParallaxMappingMethod Copy item path
- Variants§
  - Occlusion
  - Relief
    - Fields
- Implementations§
  - impl ParallaxMappingMethod
    - pub const DEFAULT_RELIEF_MAPPING: ParallaxMappingMethod
- Trait Implementations§
  - impl Clone for ParallaxMappingMethod

The parallax mapping method to use to compute depth based on the material’s depth_map.

Parallax Mapping uses a depth map texture to give the illusion of depth variation on a mesh surface that is geometrically flat.

See the parallax_mapping.wgsl shader code for implementation details and explanation of the methods used.

A simple linear interpolation, using a single texture sample.

This method is named “Parallax Occlusion Mapping”.

Unlike ParallaxMappingMethod::Relief, only requires a single lookup, but may skip small details and result in writhing material artifacts.

Discovers the best depth value based on binary search.

Each iteration incurs a texture sample. The result has fewer visual artifacts than ParallaxMappingMethod::Occlusion.

This method is named “Relief Mapping”.

How many additional steps to use at most to find the depth value.

ParallaxMappingMethod::Relief with a 5 steps, a reasonable default.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ParallaxMappingMethod {
    Occlusion,
    Relief {
        max_steps: u32,
    },
}
```

---

## Function on_message Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.on_message.html

**Contents:**
- Function on_message Copy item path
- §Example

A SystemCondition-satisfying system that returns true if there are any new messages of the given type since it was last called.

**Examples:**

Example 1 (unknown):
```unknown
pub fn on_message<M>(reader: MessageReader<'_, '_, M>) -> boolwhere
    M: Message,
```

Example 2 (unknown):
```unknown
app.add_systems(
    my_system.run_if(on_message::<MyMessage>),
);

#[derive(Message)]
struct MyMessage;

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// No new `MyMessage` messages have been push so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 0);

world.resource_mut::<Messages<MyMessage>>().write(MyMessage);

// A `MyMessage` message has been pushed so `my_system` will run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Struct Timer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Timer.html

**Contents:**
- Struct Timer Copy item path
- §Timer modes
- §Pausing timers
- §Elapsing multiple times a frame
- Implementations§
  - impl Timer
    - pub fn new(duration: Duration, mode: TimerMode) -> Timer
      - Examples found in repository?
    - pub fn from_seconds(duration: f32, mode: TimerMode) -> Timer
      - §Example

Tracks elapsed time. Enters the finished state once duration is reached.

Note that in order to advance the timer tick MUST be called.

There are two timer modes (TimerMode):

You can pause a timer using Timer::pause. Paused timers will not have elapsed time increased.

Repeating timers might elapse multiple times per frame if the time is advanced by more than the timer duration. You can check how many times a timer elapsed each tick with Timer::times_finished_this_tick. For non-repeating timers, this will always be 0 or 1.

Creates a new timer with a given duration.

See also Timer::from_seconds.

Creates a new timer with a given duration in seconds.

Returns true if the timer has reached its duration.

For repeating timers, this method behaves identically to Timer::just_finished.

Returns true if the timer has reached its duration.

For repeating timers, this method behaves identically to Timer::just_finished.

Returns true only on the tick the timer reached its duration.

Returns the time elapsed on the timer. Guaranteed to be between 0.0 and duration. Will only equal duration when the timer is finished and non repeating.

See also Stopwatch::elapsed.

Returns the time elapsed on the timer as an f32. See also Timer::elapsed.

Returns the time elapsed on the timer as an f64. See also Timer::elapsed.

Sets the elapsed time of the timer without any other considerations.

See also Stopwatch::set.

Returns the duration of the timer.

Sets the duration of the timer.

Returns the mode of the timer.

Sets the mode of the timer.

Advance the timer by delta seconds. Non repeating timer will clamp at duration. Repeating timer will wrap around. Will not affect paused timers.

See also Stopwatch::tick.

Pauses the Timer. Disables the ticking of the timer.

See also Stopwatch::pause.

Unpauses the Timer. Resumes the ticking of the timer.

See also Stopwatch::unpause().

Returns true if the timer is paused.

See also Stopwatch::is_paused.

Returns true if the timer is paused.

See also Stopwatch::is_paused.

Resets the timer. The reset doesn’t affect the paused state of the timer.

See also Stopwatch::reset.

Returns the fraction of the timer elapsed time (goes from 0.0 to 1.0).

Returns the fraction of the timer remaining time (goes from 1.0 to 0.0).

Returns the remaining time in seconds

Returns the remaining time using Duration

Returns the number of times a repeating timer finished during the last tick call.

For non repeating-timers, this method will only ever r

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Timer { /* private fields */ }
```

Example 2 (unknown):
```unknown
50    fn timer_from_fps(fps: u8) -> Timer {
51        Timer::new(Duration::from_secs_f32(1.0 / (fps as f32)), TimerMode::Once)
52    }
```

Example 3 (unknown):
```unknown
107    fn timer_from_fps(fps: u8) -> Timer {
108        Timer::new(Duration::from_secs_f32(1.0 / (fps as f32)), TimerMode::Once)
109    }
```

Example 4 (javascript):
```javascript
32    fn build(&self, app: &mut App) {
33        let state = PrintMessageState {
34            message: self.message.clone(),
35            timer: Timer::new(self.wait_duration, TimerMode::Repeating),
36        };
37        app.insert_resource(state)
38            .add_systems(Update, print_message_system);
39    }
```

---

## Struct BoxShadow Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BoxShadow.html

**Contents:**
- Struct BoxShadow Copy item path
- Tuple Fields§
- Implementations§
  - impl BoxShadow
    - pub fn new( color: Color, x_offset: Val, y_offset: Val, spread_radius: Val, blur_radius: Val, ) -> BoxShadow
      - Examples found in repository?
- Methods from Deref<Target = Vec<ShadowStyle>>§
    - pub fn capacity(&self) -> usize
      - §Examples
    - pub fn reserve(&mut self, additional: usize)

List of shadows to draw for a Node.

Draw order is determined implicitly from the vector of ShadowStyles, back-to-front.

Returns the total number of elements the vector can hold without reallocating.

A vector with zero-sized elements will always have a capacity of usize::MAX:

Reserves capacity for at least additional more elements to be inserted in the given Vec<T>. The collection may reserve more space to speculatively avoid frequent reallocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient.

Panics if the new capacity exceeds isize::MAX bytes.

Reserves the minimum capacity for at least additional more elements to be inserted in the given Vec<T>. Unlike reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling reserve_exact, capacity will be greater than or equal to self.len() + additional. Does nothing if the capacity is already sufficient.

Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.

Panics if the new capacity exceeds isize::MAX bytes.

Tries to reserve capacity for at least additional more elements to be inserted in the given Vec<T>. The collection may reserve more space to speculatively avoid frequent reallocations. After calling try_reserve, capacity will be greater than or equal to self.len() + additional if it returns Ok(()). Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.

If the capacity overflows, or the allocator reports a failure, then an error is returned.

Tries to reserve the minimum capacity for at least additional elements to be inserted in the given Vec<T>. Unlike try_reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling try_reserve_exact, capacity will be greater than or equal to self.len() + additional if it returns Ok(()). Does nothing if the capacity is already sufficient.

Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer try_reserve if future insertions are expected.

If the capacity overflows, or the allocator reports a failure, then an error is returned.

Shrinks the capacity of the vector as much as possible.

The behavi

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct BoxShadow(pub Vec<ShadowStyle>);
```

Example 2 (javascript):
```javascript
371    pub fn setup(mut commands: Commands) {
372        commands.spawn((Camera2d, DespawnOnExit(super::Scene::BoxShadow)));
373
374        commands
375            .spawn((
376                Node {
377                    width: percent(100),
378                    height: percent(100),
379                    padding: UiRect::all(px(30)),
380                    column_gap: px(200),
381                    flex_wrap: FlexWrap::Wrap,
382                    ..default()
383                },
384                BackgroundColor(GREEN.into()),
385                DespawnOnExit(super::Scene::BoxShadow),
...
```

Example 3 (javascript):
```javascript
let mut vec: Vec<i32> = Vec::with_capacity(10);
vec.push(42);
assert!(vec.capacity() >= 10);
```

Example 4 (javascript):
```javascript
#[derive(Clone)]
struct ZeroSized;

fn main() {
    assert_eq!(std::mem::size_of::<ZeroSized>(), 0);
    let v = vec![ZeroSized; 0];
    assert_eq!(v.capacity(), usize::MAX);
}
```

---

## Struct SubApps Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.SubApps.html

**Contents:**
- Struct SubApps Copy item path
- Fields§
- Implementations§
  - impl SubApps
    - pub fn update(&mut self)
    - pub fn iter(&self) -> impl Iterator<Item = &SubApp>
    - pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut SubApp>
    - pub fn update_subapp_by_label(&mut self, label: impl AppLabel)
- Trait Implementations§
  - impl Default for SubApps

The collection of sub-apps that belong to an App.

The primary sub-app that contains the “main” world.

Other, labeled sub-apps.

Calls update for the main sub-app, and then calls extract and update for the rest.

Returns an iterator over the sub-apps (starting with the main one).

Returns a mutable iterator over the sub-apps (starting with the main one).

Extract data from the main world into the SubApp with the given label and perform an update if it exists.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SubApps {
    pub main: SubApp,
    pub sub_apps: HashMap<Interned<dyn AppLabel>, SubApp>,
}
```

---

## Struct Polygon Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Polygon.html

**Contents:**
- Struct Polygon Copy item path
- Fields§
- Implementations§
  - impl Polygon
    - pub fn new(vertices: impl IntoIterator<Item = Vec2>) -> Polygon
    - pub fn is_simple(&self) -> bool
- Trait Implementations§
  - impl Bounded2d for Polygon
    - fn aabb_2d(&self, isometry: impl Into<Isometry2d>) -> Aabb2d
    - fn bounding_circle(&self, isometry: impl Into<Isometry2d>) -> BoundingCircle

A polygon with N vertices.

The vertices of the Polygon

Create a new Polygon from its vertices

Tests if the polygon is simple.

A polygon is simple if it is not self intersecting and not self tangent. As such, no two edges of the polygon may cross each other and each vertex must not lie on another edge.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Polygon {
    pub vertices: Vec<Vec2>,
}
```

---

## Trait IterableCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/iterable/trait.IterableCurve.html

**Contents:**
- Trait IterableCurve Copy item path
- Required Methods§
    - fn domain(&self) -> Interval
    - fn sample_iter_unchecked(&self, t: f32) -> impl Iterator<Item = T>
- Provided Methods§
    - fn sample_iter_clamped(&self, t: f32) -> impl Iterator<Item = T>
    - fn sample_iter(&self, t: f32) -> Option<impl Iterator<Item = T>>
- Dyn Compatibility§
- Implementors§
  - impl<T> IterableCurve<T> for WideCubicKeyframeCurve<T>where T: VectorSpace<Scalar = f32>,

A curve which provides samples in the form of Iterators.

This is an abstraction that provides an interface for curves which look like Curve<Vec<T>> but side-stepping issues with allocation on sampling. This happens when the size of an output array cannot be known statically.

The interval over which this curve is parametrized.

Sample a point on this curve at the parameter value t, producing an iterator over values. This is the unchecked version of sampling, which should only be used if the sample time t is already known to lie within the curve’s domain.

Values sampled from outside of a curve’s domain are generally considered invalid; data which is nonsensical or otherwise useless may be returned in such a circumstance, and extrapolation beyond a curve’s domain should not be relied upon.

Sample this curve at a specified time t, producing an iterator over sampled values. The parameter t is clamped to the domain of the curve.

Sample this curve at a specified time t, producing an iterator over sampled values. If the parameter t does not lie in the curve’s domain, None is returned.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait IterableCurve<T> {
    // Required methods
    fn domain(&self) -> Interval;
    fn sample_iter_unchecked(&self, t: f32) -> impl Iterator<Item = T>;

    // Provided methods
    fn sample_iter_clamped(&self, t: f32) -> impl Iterator<Item = T> { ... }
    fn sample_iter(&self, t: f32) -> Option<impl Iterator<Item = T>> { ... }
}
```

---

## Trait Vec3Swizzles Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Vec3Swizzles.html

**Contents:**
- Trait Vec3Swizzles Copy item path
- Required Associated Types§
    - type Vec2
    - type Vec4
- Required Methods§
    - fn xx(self) -> Self::Vec2
    - fn xy(self) -> Self::Vec2
    - fn with_xy(self, rhs: Self::Vec2) -> Self
    - fn xz(self) -> Self::Vec2
    - fn with_xz(self, rhs: Self::Vec2) -> Self

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Vec3Swizzles:
    Sized
    + Copy
    + Clone {
    type Vec2;
    type Vec4;

Show 123 methods    // Required methods
    fn xx(self) -> Self::Vec2;
    fn xy(self) -> Self::Vec2;
    fn with_xy(self, rhs: Self::Vec2) -> Self;
    fn xz(self) -> Self::Vec2;
    fn with_xz(self, rhs: Self::Vec2) -> Self;
    fn yx(self) -> Self::Vec2;
    fn with_yx(self, rhs: Self::Vec2) -> Self;
    fn yy(self) -> Self::Vec2;
    fn yz(self) -> Self::Vec2;
    fn with_yz(self, rhs: Self::Vec2) -> Self;
    fn zx(self) -> Self::Vec2;
    fn with_zx(self, rhs: Self::Vec2) -> Self;
    fn zy(self) ->
...
```

---

## Struct GeneratedEnvironmentMapLight Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GeneratedEnvironmentMapLight.html

**Contents:**
- Struct GeneratedEnvironmentMapLight Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for GeneratedEnvironmentMapLight
    - fn clone(&self) -> GeneratedEnvironmentMapLight
    - fn clone_from(&mut self, source: &Self)
  - impl Component for GeneratedEnvironmentMapLightwhere GeneratedEnvironmentMapLight: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

A generated environment map that is filtered at runtime.

See bevy_pbr::light_probe::generate for detailed information.

Source cubemap to be filtered on the GPU, size must be a power of two.

Scale factor applied to the diffuse and specular light generated by this component. Expressed in cd/m² (candela per square meter).

World-space rotation applied to the cubemap.

Whether this light contributes diffuse lighting to meshes that already have baked lightmaps.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GeneratedEnvironmentMapLight {
    pub environment_map: Handle<Image>,
    pub intensity: f32,
    pub rotation: Quat,
    pub affects_lightmapped_mesh_diffuse: bool,
}
```

---

## Enum SerializedAnimationClip Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.SerializedAnimationClip.html

**Contents:**
- Enum SerializedAnimationClip Copy item path
- Variants§
  - AssetPath(AssetPath<'static>)
  - AssetId(AssetId<AnimationClip>)
- Trait Implementations§
  - impl<'de> Deserialize<'de> for SerializedAnimationClip
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<SerializedAnimationClip, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,
- Auto Trait Implementations§
  - impl Freeze for SerializedAnimationClip
  - impl RefUnwindSafe for SerializedAnimationClip

The legacy form of serialized animation clips. This allows raw asset IDs to be deserialized.

Records an asset path.

The fallback that records an asset ID.

Because asset IDs can change, this should not be relied upon. Prefer to use asset paths where possible.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum SerializedAnimationClip {
    AssetPath(AssetPath<'static>),
    AssetId(AssetId<AnimationClip>),
}
```

---

## Struct TransformHelper Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TransformHelper.html

**Contents:**
- Struct TransformHelper Copy item path
- Implementations§
  - impl<'w, 's> TransformHelper<'w, 's>
    - pub fn compute_global_transform( &self, entity: Entity, ) -> Result<GlobalTransform, ComputeGlobalTransformError>
- Trait Implementations§
  - impl SystemParam for TransformHelper<'_, '_>
    - type State = FetchState
    - type Item<'w, 's> = TransformHelper<'w, 's>
    - fn init_state( world: &mut World, ) -> <TransformHelper<'_, '_> as SystemParam>::State
    - fn init_access( state: &<TransformHelper<'_, '_> as SystemParam>::State, system_meta: &mut SystemMeta, component_access_set: &mut FilteredAccessSet, world: &mut World, )

System parameter for computing up-to-date GlobalTransforms.

Computing an entity’s GlobalTransform can be expensive so it is recommended you use the GlobalTransform component stored on the entity, unless you need a GlobalTransform that reflects the changes made to any Transforms since the last time the transform propagation systems ran.

Computes the GlobalTransform of the given entity from the Transform component on it and its ancestors.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TransformHelper<'w, 's> { /* private fields */ }
```

---

## Trait FromWorld Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.FromWorld.html

**Contents:**
- Trait FromWorld Copy item path
- Required Methods§
    - fn from_world(world: &mut World) -> Self
- Dyn Compatibility§
- Implementors§
  - impl FromWorld for CasNode
  - impl FromWorld for DownsampleDepthNode
  - impl FromWorld for OitResolvePipeline
  - impl FromWorld for FullscreenShader
  - impl FromWorld for DefaultQueryFilters

Creates an instance of the type this trait is implemented for using data from the supplied World.

This can be helpful for complex initialization or context-aware defaults.

FromWorld is automatically implemented for any type implementing Default and may also be derived for:

Creates Self using data from the given World.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait FromWorld {
    // Required method
    fn from_world(world: &mut World) -> Self;
}
```

Example 2 (rs):
```rs
#[derive(Default)]
struct A;

#[derive(Default)]
struct B(Option<u32>)

struct C;

impl FromWorld for C {
    fn from_world(_world: &mut World) -> Self {
        Self
    }
}

#[derive(FromWorld)]
struct D(A, B, C);

#[derive(FromWorld)]
enum E {
    #[from_world]
    F,
    G
}
```

---

## Enum NodeImageMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.NodeImageMode.html

**Contents:**
- Enum NodeImageMode Copy item path
- Variants§
  - Auto
  - Stretch
  - Sliced(TextureSlicer)
  - Tiled
    - Fields
- Implementations§
  - impl NodeImageMode
    - pub const fn uses_slices(&self) -> bool

Controls how the image is altered to fit within the layout and how the layout algorithm determines the space in the layout for the image

The image will be sized automatically by taking the size of the source image and applying any layout constraints.

The image will be resized to match the size of the node. The image’s original size and aspect ratio will be ignored.

The texture will be cut in 9 slices, keeping the texture in proportions on resize

The texture will be repeated if stretched beyond stretched_value

Should the image repeat horizontally

Should the image repeat vertically

The texture will repeat when the ratio between the drawing dimensions of texture and the original texture size are above this value.

Returns true if this mode uses slices internally (NodeImageMode::Sliced or NodeImageMode::Tiled)

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum NodeImageMode {
    Auto,
    Stretch,
    Sliced(TextureSlicer),
    Tiled {
        tile_x: bool,
        tile_y: bool,
        stretch_value: f32,
    },
}
```

---

## Function condition_changed_to Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.condition_changed_to.html

**Contents:**
- Function condition_changed_to Copy item path
- §Example

Generates a SystemCondition that returns true when the result of the passed one went from false to true since the last time this was called.

The first time this is called, the passed condition is assumed to have been previously false.

**Examples:**

Example 1 (unknown):
```unknown
pub fn condition_changed_to<Marker, CIn, C>(
    to: bool,
    condition: C,
) -> impl SystemCondition<(), CIn>where
    CIn: SystemInput,
    C: SystemCondition<Marker, CIn>,
```

Example 2 (unknown):
```unknown
app.add_systems(
    my_system.run_if(condition_changed_to(true, resource_exists::<MyResource>)),
);

#[derive(Resource)]
struct MyResource;

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `MyResource` is initially there, the inner condition is true, the system runs once
world.insert_resource(MyResource);
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);

// We remove `MyResource`, the inner condition is now false, the system doesn't run.
world.remove_resource::<MyResource>();
app.run(&m
...
```

---

## Struct MeshRayCast Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshRayCast.html

**Contents:**
- Struct MeshRayCast Copy item path
  - §Usage
  - §Configuration
- Implementations§
  - impl<'w, 's> MeshRayCast<'w, 's>
    - pub fn cast_ray( &mut self, ray: Ray3d, settings: &MeshRayCastSettings<'_>, ) -> &[(Entity, RayMeshHit)]
      - Examples found in repository?
- Trait Implementations§
  - impl SystemParam for MeshRayCast<'_, '_>
    - type State = FetchState

Add this ray casting SystemParam to your system to cast rays into the world with an immediate-mode API. Call cast_ray to immediately perform a ray cast and get a result.

Under the hood, this is a collection of regular bevy queries, resources, and local parameters that are added to your system.

The following system casts a ray into the world with the ray positioned at the origin, pointing in the X-direction, and returns a list of intersections:

You can specify the behavior of the ray cast using MeshRayCastSettings. This allows you to filter out entities, configure early-out behavior, and set whether the Visibility of an entity should be considered.

Casts the ray into the world and returns a sorted list of intersections, nearest first.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshRayCast<'w, 's> { /* private fields */ }
```

Example 2 (javascript):
```javascript
fn ray_cast_system(mut ray_cast: MeshRayCast) {
    let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
    let hits = ray_cast.cast_ray(ray, &MeshRayCastSettings::default());
}
```

Example 3 (javascript):
```javascript
fn ray_cast_system(mut ray_cast: MeshRayCast, foo_query: Query<(), With<Foo>>) {
    let ray = Ray3d::new(Vec3::ZERO, Dir3::X);

    // Only ray cast against entities with the `Foo` component.
    let filter = |entity| foo_query.contains(entity);

    // Never early-exit. Note that you can change behavior per-entity.
    let early_exit_test = |_entity| false;

    // Ignore the visibility of entities. This allows ray casting hidden entities.
    let visibility = RayCastVisibility::Any;

    let settings = MeshRayCastSettings::default()
        .with_filter(&filter)
        .with_early_exit_tes
...
```

Example 4 (javascript):
```javascript
45fn bounce_ray(mut ray: Ray3d, ray_cast: &mut MeshRayCast, gizmos: &mut Gizmos, color: Color) {
46    let mut intersections = Vec::with_capacity(MAX_BOUNCES + 1);
47    intersections.push((ray.origin, Color::srgb(30.0, 0.0, 0.0)));
48
49    for i in 0..MAX_BOUNCES {
50        // Cast the ray and get the first hit
51        let Some((_, hit)) = ray_cast
52            .cast_ray(ray, &MeshRayCastSettings::default())
53            .first()
54        else {
55            break;
56        };
57
58        // Draw the point of intersection and add it to the list
59        let brightness = 1.0 + 10.0 
...
```

---

## Struct BounceInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BounceInOutCurve.html

**Contents:**
- Struct BounceInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for BounceInOutCurve
    - fn clone(&self) -> BounceInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for BounceInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as BounceIn for t < 0.5 and as BounceOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BounceInOutCurve;
```

---

## Trait AssetApp Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/asset/trait.AssetApp.html

**Contents:**
- Trait AssetApp Copy item path
- Required Methods§
    - fn register_asset_loader<L>(&mut self, loader: L) -> &mut Selfwhere L: AssetLoader,
    - fn register_asset_processor<P>(&mut self, processor: P) -> &mut Selfwhere P: Process,
    - fn register_asset_source( &mut self, id: impl Into<AssetSourceId<'static>>, source: AssetSourceBuilder, ) -> &mut Self
    - fn set_default_asset_processor<P>(&mut self, extension: &str) -> &mut Selfwhere P: Process,
    - fn init_asset_loader<L>(&mut self) -> &mut Selfwhere L: AssetLoader + FromWorld,
    - fn init_asset<A>(&mut self) -> &mut Selfwhere A: Asset,
    - fn register_asset_reflect<A>(&mut self) -> &mut Selfwhere A: Asset + Reflect + FromReflect + GetTypeRegistration,
    - fn preregister_asset_loader<L>(&mut self, extensions: &[&str]) -> &mut Selfwhere L: AssetLoader,

Adds asset-related builder methods to App.

Registers the given loader in the App’s AssetServer.

Registers the given processor in the App’s AssetProcessor.

Registers the given AssetSourceBuilder with the given id.

Note that asset sources must be registered before adding AssetPlugin to your application, since registered asset sources are built at that point and not after.

Sets the default asset processor for the given extension.

Initializes the given loader in the App’s AssetServer.

Initializes the given Asset in the App by:

Registers the asset type T using [App::register], and adds ReflectAsset type data to T and ReflectHandle type data to Handle<T> in the type registry.

This enables reflection code to access assets. For detailed information, see the docs on ReflectAsset and ReflectHandle.

Preregisters a loader for the given extensions, that will block asset loads until a real loader is registered.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AssetApp {
    // Required methods
    fn register_asset_loader<L>(&mut self, loader: L) -> &mut Self
       where L: AssetLoader;
    fn register_asset_processor<P>(&mut self, processor: P) -> &mut Self
       where P: Process;
    fn register_asset_source(
        &mut self,
        id: impl Into<AssetSourceId<'static>>,
        source: AssetSourceBuilder,
    ) -> &mut Self;
    fn set_default_asset_processor<P>(&mut self, extension: &str) -> &mut Self
       where P: Process;
    fn init_asset_loader<L>(&mut self) -> &mut Self
       where L: AssetLoader + FromWorld;
    fn init_
...
```

---

## Struct NonSendMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.NonSendMut.html

**Contents:**
- Struct NonSendMut Copy item path
- Implementations§
  - impl<'w, T> NonSendMut<'w, T>where T: ?Sized,
    - pub fn into_inner(self) -> &'w mut T
    - pub fn reborrow(&mut self) -> Mut<'_, T>
    - pub fn map_unchanged<U>(self, f: impl FnOnce(&mut T) -> &mut U) -> Mut<'w, U>where U: ?Sized,
    - pub fn filter_map_unchanged<U>( self, f: impl FnOnce(&mut T) -> Option<&mut U>, ) -> Option<Mut<'w, U>>where U: ?Sized,
    - pub fn try_map_unchanged<U, E>( self, f: impl FnOnce(&mut T) -> Result<&mut U, E>, ) -> Result<Mut<'w, U>, E>where U: ?Sized,
    - pub fn as_deref_mut(&mut self) -> Mut<'_, <T as Deref>::Target>where T: DerefMut,
- Trait Implementations§

Unique borrow of a non-Send resource.

Only Send resources may be accessed with the ResMut SystemParam. In case that the resource does not implement Send, this SystemParam wrapper can be used. This will instruct the scheduler to instead run the system on the main thread so that it doesn’t send the resource over to another thread.

This SystemParam fails validation if non-send resource doesn’t exist. This will cause a panic, but can be configured to do nothing or warn once.

Use Option<NonSendMut<T>> instead if the resource might not always exist.

Consume self and return a mutable reference to the contained value while marking self as “changed”.

Returns a Mut<> with a smaller lifetime. This is useful if you have &mut NonSendMut <T>, but you need a Mut<T>.

Maps to an inner value by applying a function to the contained reference, without flagging a change.

You should never modify the argument passed to the closure – if you want to modify the data without flagging a change, consider using DetectChangesMut::bypass_change_detection to make your intent explicit.

Optionally maps to an inner value by applying a function to the contained reference. This is useful in a situation where you need to convert a Mut<T> to a Mut<U>, but only if T contains U.

As with map_unchanged, you should never modify the argument passed to the closure.

Optionally maps to an inner value by applying a function to the contained reference, returns an error on failure. This is useful in a situation where you need to convert a Mut<T> to a Mut<U>, but only if T contains U.

As with map_unchanged, you should never modify the argument passed to the closure.

Allows you access to the dereferenced value of this pointer without immediately triggering change detection.

Convert this NonSendMut into a Mut. This allows keeping the change-detection feature of Mut while losing the specificity of NonSendMut.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct NonSendMut<'w, T>where
    T: 'static + ?Sized,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
// When run, zeroes the translation of every entity.
fn reset_positions(mut transforms: Query<&mut Transform>) {
    for transform in &mut transforms {
        // We pinky promise not to modify `t` within the closure.
        // Breaking this promise will result in logic errors, but will never cause undefined behavior.
        let mut translation = transform.map_unchanged(|t| &mut t.translation);
        // Only reset the translation if it isn't already zero;
        translation.set_if_neq(Vec2::ZERO);
    }
}
```

---

## Struct Ellipse Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Ellipse.html

**Contents:**
- Struct Ellipse Copy item path
- Fields§
- Implementations§
  - impl Ellipse
    - pub const fn new(half_width: f32, half_height: f32) -> Ellipse
      - Examples found in repository?
    - pub const fn from_size(size: Vec2) -> Ellipse
    - pub fn eccentricity(&self) -> f32
    - pub fn focal_length(&self) -> f32
    - pub fn semi_major(&self) -> f32

An ellipse primitive, which is like a circle, but the width and height can be different

Half of the width and height of the ellipse.

This corresponds to the two perpendicular radii defining the ellipse.

Create a new Ellipse from half of its width and height.

This corresponds to the two perpendicular radii defining the ellipse.

Create a new Ellipse from a given full size.

size.x is the diameter along the X axis, and size.y is the diameter along the Y axis.

Returns the eccentricity of the ellipse. It can be thought of as a measure of how “stretched” or elongated the ellipse is.

The value should be in the range [0, 1), where 0 represents a circle, and 1 represents a parabola.

Get the focal length of the ellipse. This corresponds to the distance between one of the foci and the center of the ellipse.

The focal length of an ellipse is related to its eccentricity by eccentricity = focal_length / semi_major

Returns the length of the semi-major axis. This corresponds to the longest radius of the ellipse.

Returns the length of the semi-minor axis. This corresponds to the shortest radius of the ellipse.

Returns the default Ellipse with a half-width of 1.0 and a half-height of 0.5.

Get the area of the ellipse

Get an approximation for the perimeter or circumference of the ellipse.

The approximation is reasonably precise with a relative error less than 0.007%, getting more precise as the eccentricity of the ellipse decreases.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Ellipse {
    pub half_size: Vec2,
}
```

Example 2 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 3 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

---

## Trait RelationshipTarget Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.RelationshipTarget.html

**Contents:**
- Trait RelationshipTarget Copy item path
- Required Associated Constants§
    - const LINKED_SPAWN: bool
- Required Associated Types§
    - type Relationship: Relationship<RelationshipTarget = Self>
    - type Collection: RelationshipSourceCollection
- Required Methods§
    - fn collection(&self) -> &Self::Collection
    - fn collection_mut_risky(&mut self) -> &mut Self::Collection
      - §Warning

A Component containing the collection of entities that relate to this Entity via the associated Relationship type. See the Relationship documentation for more information.

If this is true, when despawning or cloning (when linked cloning is enabled), the related entities targeting this entity will also be despawned or cloned.

For example, this is set to true for Bevy’s built-in parent-child relation, defined by ChildOf and Children. This means that when a parent is despawned, any children targeting that parent are also despawned (and the same applies to cloning).

To get around this behavior, you can first break the relationship between entities, and then despawn or clone. This defaults to false when derived.

The Relationship that populates this RelationshipTarget collection.

The collection type that stores the “source” entities for this RelationshipTarget component.

Check the list of types which implement RelationshipSourceCollection for the data structures that can be used inside of your component. If you need a new collection type, you can implement the RelationshipSourceCollection trait for a type you own which wraps the collection you want to use (to avoid the orphan rule), or open an issue on the Bevy repository to request first-party support for your collection type.

Returns a reference to the stored RelationshipTarget::Collection.

Returns a mutable reference to the stored RelationshipTarget::Collection.

This should generally not be called by user code, as modifying the internal collection could invalidate the relationship. The collection should not contain duplicates.

Creates a new RelationshipTarget from the given RelationshipTarget::Collection.

This should generally not be called by user code, as constructing the internal collection could invalidate the relationship. The collection should not contain duplicates.

The on_replace component hook that maintains the Relationship / RelationshipTarget connection.

The on_despawn component hook that despawns entities stored in an entity’s RelationshipTarget when that entity is despawned.

Creates this RelationshipTarget with the given pre-allocated entity capacity.

Iterates the entities stored in this collection.

Returns the number of entities in this collection.

Returns true if this entity collection is empty.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (javascript):
```javascript
pub trait RelationshipTarget: Sized + Component<Mutability = Mutable> {
    type Relationship: Relationship<RelationshipTarget = Self>;
    type Collection: RelationshipSourceCollection;

    const LINKED_SPAWN: bool;

    // Required methods
    fn collection(&self) -> &Self::Collection;
    fn collection_mut_risky(&mut self) -> &mut Self::Collection;
    fn from_collection_risky(collection: Self::Collection) -> Self;

    // Provided methods
    fn on_replace(world: DeferredWorld<'_>, _: HookContext) { ... }
    fn on_despawn(world: DeferredWorld<'_>, _: HookContext) { ... }
    fn with_capa
...
```

Example 2 (javascript):
```javascript
66fn cycle_text_background_colors(
67    time: Res<Time>,
68    children_query: Query<&Children, With<Text>>,
69    mut text_background_colors_query: Query<&mut TextBackgroundColor>,
70) {
71    let n = time.elapsed_secs() as usize;
72    let children = children_query.single().unwrap();
73
74    for (i, child) in children.iter().enumerate() {
75        text_background_colors_query.get_mut(child).unwrap().0 = PALETTE[(i + n) % PALETTE.len()];
76    }
77}
```

Example 3 (javascript):
```javascript
40fn text_color_on_hover<T: Debug + Clone + Reflect>(
41    color: Color,
42) -> impl FnMut(On<Pointer<T>>, Query<&mut TextColor>, Query<&Children>) {
43    move |mut event: On<Pointer<T>>,
44          mut text_color: Query<&mut TextColor>,
45          children: Query<&Children>| {
46        let Ok(children) = children.get(event.original_event_target()) else {
47            return;
48        };
49        event.propagate(false);
50
51        // find the text among children and change its color
52        for child in children.iter() {
53            if let Ok(mut col) = text_color.get_mut(child) 
...
```

Example 4 (javascript):
```javascript
300fn move_cars(
301    time: Res<Time>,
302    mut movables: Query<(&mut Transform, &Moves, &Children)>,
303    mut spins: Query<&mut Transform, (Without<Moves>, With<Rotates>)>,
304) {
305    for (mut transform, moves, children) in &mut movables {
306        let time = time.elapsed_secs() * 0.25;
307        let t = time + 0.5 * moves.0;
308        let dx = ops::cos(t);
309        let dz = -ops::sin(3.0 * t);
310        let speed_variation = (dx * dx + dz * dz).sqrt() * 0.15;
311        let t = t + speed_variation;
312        let prev = transform.translation;
313        transform.translation.
...
```

---

## Struct Vec3A Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Vec3A.html

**Contents:**
- Struct Vec3A Copy item path
- Implementations§
  - impl Vec3A
    - pub const ZERO: Vec3A
    - pub const ONE: Vec3A
    - pub const NEG_ONE: Vec3A
    - pub const MIN: Vec3A
    - pub const MAX: Vec3A
    - pub const NAN: Vec3A
    - pub const INFINITY: Vec3A

A 3-dimensional vector.

SIMD vector types are used for storage on supported platforms for better performance than the Vec3 type.

It is possible to convert between Vec3 and Vec3A types using From or Into trait implementations.

This type is 16 byte aligned.

All f32::NEG_INFINITY.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

Vec3A uses Rust Portable SIMD

Vec3A uses scalar math

Vec3A uses Intel SSE2

Vec3A uses WebAssembly 128-bit SIMD

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z]

Creates a vector from the first 3 values in slice.

Panics if slice is less than 3 elements long.

Writes the elements of self to the first 3 elements in slice.

Panics if slice is less than 3 elements long.

Creates a Vec3A from the x, y and z elements of self discarding w.

On architectures where SIMD is supported such as SSE2 on x86_64 this conversion is a noop.

Creates a 4D vector from self and the given w value.

Creates a 2D vector from the x and y elements of self, discarding z.

Truncation may also be performed by using self.xy().

Creates a 3D vector from self with the given value of x.

Creates a 3D vector from self with the given value of y.

Creates a 3D vector from self with the given value of z.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Computes the cross product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for minNum and may differ on different SIMD architectures.

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Vec3A(/* private fields */);
```

Example 2 (unknown):
```unknown
184fn setup(mut commands: Commands) {
185    // Spawn a single entity that has custom rendering. It'll be extracted into
186    // the render world via [`ExtractComponent`].
187    commands.spawn((
188        Visibility::default(),
189        Transform::default(),
190        // This `Aabb` is necessary for the visibility checks to work.
191        Aabb {
192            center: Vec3A::ZERO,
193            half_extents: Vec3A::splat(0.5),
194        },
195        CustomRenderedEntity,
196    ));
197
198    // Spawn the camera.
199    commands.spawn((
200        Camera3d::default(),
201        Tr
...
```

Example 3 (javascript):
```javascript
99fn draw_axes(mut gizmos: Gizmos, query: Query<(&Transform, &Aabb), With<ShowAxes>>) {
100    for (&transform, &aabb) in &query {
101        let length = aabb.half_extents.length();
102        gizmos.axes(transform, length);
103    }
104}
```

---

## Struct StepsCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.StepsCurve.html

**Contents:**
- Struct StepsCurve Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for StepsCurve
    - fn clone(&self) -> StepsCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for StepsCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>

n steps connecting the start and the end. Jumping behavior is customizable via JumpAt. See JumpAt for all the options and visual examples.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct StepsCurve(pub usize, pub JumpAt);
```

---

## Struct Without Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Without.html

**Contents:**
- Struct Without Copy item path
- §Examples
- Trait Implementations§
  - impl<T> QueryFilter for Without<T>where T: Component,
    - const IS_ARCHETYPAL: bool = true
    - unsafe fn filter_fetch( _state: &<Without<T> as WorldQuery>::State, _fetch: &mut <Without<T> as WorldQuery>::Fetch<'_>, _entity: Entity, _table_row: TableRow, ) -> bool
  - impl<T> WorldQuery for Without<T>where T: Component,
    - const IS_DENSE: bool
    - type Fetch<'w> = ()
    - type State = ComponentId

Filter that selects entities without a component T.

This is the negation of With.

SAFETY: update_component_access does not add any accesses. This is sound because QueryFilter::filter_fetch does not access any components. update_component_access adds a Without filter for T. This is sound because matches_component_set returns whether the set does not contain the component.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Without<T>(/* private fields */);
```

Example 2 (unknown):
```unknown
fn no_permit_system(query: Query<&Name, Without<Permit>>) {
    for name in &query{
        println!("{} has no permit!", name.name);
    }
}
```

---

## Struct BorderGradient Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BorderGradient.html

**Contents:**
- Struct BorderGradient Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for BorderGradient
    - fn clone(&self) -> BorderGradient
    - fn clone_from(&mut self, source: &Self)
  - impl Component for BorderGradientwhere BorderGradient: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

A UI node border that displays a gradient

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BorderGradient(pub Vec<Gradient>);
```

---

## Struct InteractionPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.InteractionPlugin.html

**Contents:**
- Struct InteractionPlugin Copy item path
- Trait Implementations§
  - impl Default for InteractionPlugin
    - fn default() -> InteractionPlugin
  - impl Plugin for InteractionPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

Generates Pointer events and handles event bubbling.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct InteractionPlugin;
```

---

## Enum FileDragAndDrop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.FileDragAndDrop.html

**Contents:**
- Enum FileDragAndDrop Copy item path
- Variants§
  - DroppedFile
    - Fields
  - HoveredFile
    - Fields
  - HoveredFileCanceled
    - Fields
- Trait Implementations§
  - impl Clone for FileDragAndDrop

Events related to files being dragged and dropped on a window.

File is being dropped into a window.

Window the file was dropped into.

Path to the file that was dropped in.

File is currently being hovered over a window.

Window a file is possibly going to be dropped into.

Path to the file that might be dropped in.

File hovering was canceled.

Window that had a canceled file drop.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum FileDragAndDrop {
    DroppedFile {
        window: Entity,
        path_buf: PathBuf,
    },
    HoveredFile {
        window: Entity,
        path_buf: PathBuf,
    },
    HoveredFileCanceled {
        window: Entity,
    },
}
```

---

## Crate bevy Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/index.html

**Contents:**
- Crate bevy Copy item path
  - §Example
  - §This Crate
  - §Cargo Features
    - §Default Features
    - §Optional Features
- Modules§
- Structs§

Bevy is an open-source modular game engine built in Rust, with a focus on developer productivity and performance.

Check out the Bevy website for more information, read the Quick Start Guide for a step-by-step introduction, and engage with our community if you have any questions or ideas!

Here is a simple “Hello World” Bevy app:

Don’t let the simplicity of the example above fool you. Bevy is a fully featured game engine and it gets more powerful every day!

The bevy crate is just a container crate that makes it easier to consume Bevy subcrates. The defaults provide a “full” engine experience, but you can easily enable / disable features in your project’s Cargo.toml to meet your specific needs. See Bevy’s Cargo.toml for a full list of features available.

If you prefer, you can also consume the individual bevy crates directly. Each module in the root of this crate, except for the prelude, can be found on crates.io with bevy_ appended to the front, e.g. app -> bevy_app.

Bevy exposes many features to customize the engine. Enabling them add functionalities but often come at the cost of longer compilation times and extra dependencies.

The default feature set enables most of the expected features of a game engine, like rendering in both 2D and 3D, asset loading, audio and UI. To help reduce compilation time, consider disabling default features and enabling only those you need.

**Examples:**

Example 1 (unknown):
```unknown
use bevy::prelude::*;

fn main() {
   App::new()
       .add_systems(Update, hello_world_system)
       .run();
}

fn hello_world_system() {
   println!("hello world");
}
```

---

## Struct MaterialPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MaterialPlugin.html

**Contents:**
- Struct MaterialPlugin Copy item path
- Fields§
- Trait Implementations§
  - impl<M> Default for MaterialPlugin<M>where M: Material,
    - fn default() -> MaterialPlugin<M>
  - impl<M> Plugin for MaterialPlugin<M>where M: Material, <M as AsBindGroup>::Data: PartialEq + Eq + Hash + Clone,
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

Adds the necessary ECS resources and render logic to enable rendering entities using the given Material asset type.

Controls if the prepass is enabled for the Material. For more information about what a prepass is, see the bevy_core_pipeline::prepass docs.

When it is enabled, it will automatically add the PrepassPlugin required to make the prepass work on this Material.

Controls if shadows are enabled for the Material.

Debugging flags that can optionally be set when constructing the renderer.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MaterialPlugin<M>where
    M: Material,{
    pub prepass_enabled: bool,
    pub shadows_enabled: bool,
    pub debug_flags: RenderDebugFlags,
    pub _marker: PhantomData<M>,
}
```

---

## Type Alias Events Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.Events.html

**Contents:**
- Type Alias Events Copy item path
- Aliased Type§

This is deprecated. See Messages

**Examples:**

Example 1 (unknown):
```unknown
pub type Events<E> = Messages<E>;
```

Example 2 (unknown):
```unknown
pub struct Events<E> { /* private fields */ }
```

---

## Enum AlignSelf Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AlignSelf.html

**Contents:**
- Enum AlignSelf Copy item path
- Variants§
  - Auto
  - Start
  - End
  - FlexStart
  - FlexEnd
  - Center
  - Baseline
  - Stretch

Used to control how the specified item is aligned within the space it’s given.

https://developer.mozilla.org/en-US/docs/Web/CSS/align-self

Use the parent node’s AlignItems value to determine how this item should be aligned.

This item will be aligned with the start of the axis.

This item will be aligned with the end of the axis.

This item will be aligned with the start of the axis, unless the flex direction is reversed; then it will be aligned with the end of the axis.

This item will be aligned with the end of the axis, unless the flex direction is reversed; then it will be aligned with the start of the axis.

This item will be aligned along the center of the axis.

This item will be aligned at the baseline.

This item will be stretched to fill the container.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AlignSelf {
    Auto,
    Start,
    End,
    FlexStart,
    FlexEnd,
    Center,
    Baseline,
    Stretch,
}
```

---

## Struct FixedMainScheduleOrder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedMainScheduleOrder.html

**Contents:**
- Struct FixedMainScheduleOrder Copy item path
- Fields§
- Implementations§
  - impl FixedMainScheduleOrder
    - pub fn insert_after( &mut self, after: impl ScheduleLabel, schedule: impl ScheduleLabel, )
    - pub fn insert_before( &mut self, before: impl ScheduleLabel, schedule: impl ScheduleLabel, )
- Trait Implementations§
  - impl Debug for FixedMainScheduleOrder
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedMainScheduleOrder

Defines the schedules to be run for the FixedMain schedule, including their order.

The labels to run for the FixedMain schedule (in the order they will be run).

Adds the given schedule after the after schedule

Adds the given schedule before the before schedule

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedMainScheduleOrder {
    pub labels: Vec<Interned<dyn ScheduleLabel>>,
}
```

---

## Struct Scroll Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Scroll.html

**Contents:**
- Struct Scroll Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Scroll
    - fn clone(&self) -> Scroll
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Scroll
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Scroll
    - type This<'from_arg> = Scroll

Fires while a pointer is scrolling over the target entity.

The mouse scroll unit.

The horizontal scroll value.

The vertical scroll value.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Scroll {
    pub unit: MouseScrollUnit,
    pub x: f32,
    pub y: f32,
    pub hit: HitData,
}
```

---

## Trait SystemCondition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SystemCondition.html

**Contents:**
- Trait SystemCondition Copy item path
- §Marker type parameter
- §Examples
- Provided Methods§
    - fn and<M, C>( self, and: C, ) -> CombinatorSystem<AndMarker, Self::System, <C as IntoSystem<In, bool, M>>::System>where C: SystemCondition<M, In>,
      - §Examples
      - Examples found in repository?
    - fn nand<M, C>( self, nand: C, ) -> CombinatorSystem<NandMarker, Self::System, <C as IntoSystem<In, bool, M>>::System>where C: SystemCondition<M, In>,
      - §Examples
    - fn nor<M, C>( self, nor: C, ) -> CombinatorSystem<NorMarker, Self::System, <C as IntoSystem<In, bool, M>>::System>where C: SystemCondition<M, In>,

A system that determines if one or more scheduled systems should run.

Implemented for functions and closures that convert into System<Out=bool> with read-only parameters.

SystemCondition trait has Marker type parameter, which has no special meaning, but exists to work around the limitation of Rust’s trait system.

Type parameter in return type can be set to <()> by calling IntoSystem::into_system, but usually have to be specified when passing a condition to a function.

A condition that returns true every other time it’s called.

A condition that takes a bool as an input and returns it unchanged.

Returns a new run condition that only returns true if both this one and the passed and return true.

The returned run condition is short-circuiting, meaning and will only be invoked if self returns true.

Use .and() to avoid checking the condition.

Note that in this case, it’s better to just use the run condition resource_exists_and_equals.

Returns a new run condition that only returns false if both this one and the passed nand return true.

The returned run condition is short-circuiting, meaning nand will only be invoked if self returns true.

Equivalent logic can be achieved by using not in concert with and:

Returns a new run condition that only returns true if both this one and the passed nor return false.

The returned run condition is short-circuiting, meaning nor will only be invoked if self returns false.

Equivalent logic can be achieved by using not in concert with or:

Returns a new run condition that returns true if either this one or the passed or return true.

The returned run condition is short-circuiting, meaning or will only be invoked if self returns false.

Returns a new run condition that only returns true if self and xnor both return false or both return true.

Equivalent logic can be achieved by using not in concert with xor:

Returns a new run condition that only returns true if either self or xor return true, but not both.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait SystemCondition<Marker, In = ()>: SystemCondition<Marker, In>where
    In: SystemInput,{
    // Provided methods
    fn and<M, C>(
        self,
        and: C,
    ) -> CombinatorSystem<AndMarker, Self::System, <C as IntoSystem<In, bool, M>>::System>
       where C: SystemCondition<M, In> { ... }
    fn nand<M, C>(
        self,
        nand: C,
    ) -> CombinatorSystem<NandMarker, Self::System, <C as IntoSystem<In, bool, M>>::System>
       where C: SystemCondition<M, In> { ... }
    fn nor<M, C>(
        self,
        nor: C,
    ) -> CombinatorSystem<NorMarker, Self::System, <C 
...
```

Example 2 (unknown):
```unknown
fn not_condition<Marker>(a: impl SystemCondition<Marker>) -> impl SystemCondition<()> {
   IntoSystem::into_system(a.map(|x| !x))
}
```

Example 3 (unknown):
```unknown
fn every_other_time() -> impl SystemCondition<()> {
    IntoSystem::into_system(|mut flag: Local<bool>| {
        *flag = !*flag;
        *flag
    })
}

schedule.add_systems(my_system.run_if(every_other_time()));
```

Example 4 (unknown):
```unknown
fn identity() -> impl SystemCondition<(), In<bool>> {
    IntoSystem::into_system(|In(x): In<bool>| x)
}

app.add_systems(my_system.run_if(always_true.pipe(identity())));
```

---

## Struct EvenCore Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EvenCore.html

**Contents:**
- Struct EvenCore Copy item path
- §Example
- Fields§
  - §Invariants
  - §Invariants
- Implementations§
  - impl<T> EvenCore<T>
    - pub fn new( domain: Interval, samples: impl IntoIterator<Item = T>, ) -> Result<EvenCore<T>, EvenCoreError>
    - pub const fn domain(&self) -> Interval
    - pub fn sample_with<I>(&self, t: f32, interpolation: I) -> Twhere T: Clone, I: Fn(&T, &T, f32) -> T,

The data core of a curve derived from evenly-spaced samples. The intention is to use this in addition to explicit or inferred interpolation information in user-space in order to implement curves using domain and sample_with.

The internals are made transparent to give curve authors freedom, but the provided constructor enforces the required invariants, and the methods maintain those invariants.

The domain over which the samples are taken, which corresponds to the domain of the curve formed by interpolating them.

This must always be a bounded interval; i.e. its endpoints must be finite.

The samples that are interpolated to extract values.

This must always have a length of at least 2.

Create a new EvenCore from the specified domain and samples. The samples are regarded to be evenly spaced within the given domain interval, so that the outermost samples form the boundary of that interval. An error is returned if there are not at least 2 samples or if the given domain is unbounded.

The domain of the curve derived from this core.

Obtain a value from the held samples using the given interpolation to interpolate between adjacent samples.

The interpolation takes two values by reference together with a scalar parameter and produces an owned value. The expectation is that interpolation(&x, &y, 0.0) and interpolation(&x, &y, 1.0) are equivalent to x and y respectively.

Given a time t, obtain a InterpolationDatum which governs how interpolation might recover a sample at time t. For example, when a Between value is returned, its contents can be used to interpolate between the two contained values with the given parameter. The other variants give additional context about where the value is relative to the family of samples.

Like sample_interp, but the returned values include the sample times. This can be useful when sample interpolation is not scale-invariant.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct EvenCore<T> {
    pub domain: Interval,
    pub samples: Vec<T>,
}
```

Example 2 (javascript):
```javascript
// Let's make a curve that interpolates evenly spaced samples using either linear interpolation
// or step "interpolation" — i.e. just using the most recent sample as the source of truth.
enum InterpolationMode {
    Linear,
    Step,
}

// Linear interpolation mode is driven by a trait.
trait LinearInterpolate {
    fn lerp(&self, other: &Self, t: f32) -> Self;
}

// Step interpolation just uses an explicit function.
fn step<T: Clone>(first: &T, second: &T, t: f32) -> T {
    if t >= 1.0 {
        second.clone()
    } else {
        first.clone()
    }
}

// Omitted: Implementing `LinearInter
...
```

---

## Trait IntoSystemSet Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.IntoSystemSet.html

**Contents:**
- Trait IntoSystemSet Copy item path
- §Usage notes
- Required Associated Types§
    - type Set: SystemSet
- Required Methods§
    - fn into_system_set(self) -> Self::Set
- Dyn Compatibility§
- Implementors§
  - impl IntoSystemSet<()> for ApplyDeferred
    - type Set = SystemTypeSet<ApplyDeferred>

Types that can be converted into a SystemSet.

This trait should only be used as a bound for trait implementations or as an argument to a function. If a system set needs to be returned from a function or stored somewhere, use SystemSet instead of this trait.

The type of SystemSet this instance converts into.

Converts this instance to its associated SystemSet type.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait IntoSystemSet<Marker>: Sized {
    type Set: SystemSet;

    // Required method
    fn into_system_set(self) -> Self::Set;
}
```

---

## Struct ViewVisibility Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ViewVisibility.html

**Contents:**
- Struct ViewVisibility Copy item path
- Implementations§
  - impl ViewVisibility
    - pub const HIDDEN: ViewVisibility
    - pub fn get(self) -> bool
      - Examples found in repository?
    - pub fn set(&mut self)
- Trait Implementations§
  - impl Clone for ViewVisibility
    - fn clone(&self) -> ViewVisibility

Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering.

Each frame, this will be reset to false during VisibilityPropagate systems in PostUpdate. Later in the frame, systems in CheckVisibility will mark any visible entities using ViewVisibility::set. Because of this, values of this type will be marked as changed every frame, even when they do not change.

If you wish to add custom visibility system that sets this value, make sure you add it to the CheckVisibility set.

An entity that cannot be seen from any views.

Returns true if the entity is visible in any view. Otherwise, returns false.

Sets the visibility to true. This should not be considered reversible for a given frame, as this component tracks whether or not the entity visible in any view.

This will be automatically reset to false every frame in VisibilityPropagate and then set to the proper value in CheckVisibility.

You should only manually set this if you are defining a custom visibility system, in which case the system should be placed in the CheckVisibility set. For normal user-defined entity visibility, see Visibility.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ViewVisibility(/* private fields */);
```

Example 2 (unknown):
```unknown
468fn print_mesh_count(
469    time: Res<Time>,
470    mut timer: Local<PrintingTimer>,
471    sprites: Query<(&Mesh3d, &ViewVisibility)>,
472) {
473    timer.tick(time.delta());
474
475    if timer.just_finished() {
476        info!(
477            "Meshes: {} - Visible Meshes {}",
478            sprites.iter().len(),
479            sprites.iter().filter(|(_, vis)| vis.get()).count(),
480        );
481    }
482}
```

Example 3 (javascript):
```javascript
591fn rotate_primitive_2d_meshes(
592    mut primitives_2d: Query<
593        (&mut Transform, &ViewVisibility),
594        (With<PrimitiveData>, With<MeshDim2>),
595    >,
596    time: Res<Time>,
597) {
598    let rotation_2d = Quat::from_mat3(&Mat3::from_angle(time.elapsed_secs()));
599    primitives_2d
600        .iter_mut()
601        .filter(|(_, vis)| vis.get())
602        .for_each(|(mut transform, _)| {
603            transform.rotation = rotation_2d;
604        });
605}
606
607fn rotate_primitive_3d_meshes(
608    mut primitives_3d: Query<
609        (&mut Transform, &ViewVisibility),
...
```

Example 4 (javascript):
```javascript
169fn print_counts(
170    time: Res<Time>,
171    mut timer: Local<PrintingTimer>,
172    texts: Query<&ViewVisibility, With<Text2d>>,
173    atlases: Res<FontAtlasSets>,
174    font: Res<FontHandle>,
175) {
176    timer.tick(time.delta());
177    if !timer.just_finished() {
178        return;
179    }
180
181    let num_atlases = atlases
182        .get(font.0.id())
183        .map(|set| set.iter().map(|atlas| atlas.1.len()).sum())
184        .unwrap_or(0);
185
186    let visible_texts = texts.iter().filter(|visibility| visibility.get()).count();
187
188    info!(
189        "Texts: {} Visib
...
```

---

## Struct Mesh3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mesh3d.html

**Contents:**
- Struct Mesh3d Copy item path
- §Example
- Tuple Fields§
- Methods from Deref<Target = Handle<Mesh>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§

A component for 3D meshes. Requires a MeshMaterial3d to be rendered, commonly using a StandardMaterial.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Required Components: Transform.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Mesh3d(pub Handle<Mesh>);
```

Example 2 (unknown):
```unknown
// Spawn an entity with a mesh using `StandardMaterial`.
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    commands.spawn((
        Mesh3d(meshes.add(Capsule3d::default())),
        MeshMaterial3d(materials.add(StandardMaterial {
            base_color: RED.into(),
            ..Default::default()
        })),
    ));
}
```

Example 3 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 4 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

---

## Function advance_transitions Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.advance_transitions.html

**Contents:**
- Function advance_transitions Copy item path

A system that alters the weight of currently-playing transitions based on the current time and decline amount.

**Examples:**

Example 1 (unknown):
```unknown
pub fn advance_transitions(
    query: Query<'_, '_, (&mut AnimationTransitions, &mut AnimationPlayer)>,
    time: Res<'_, Time>,
)
```

---

## Struct UiGlobalTransform Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiGlobalTransform.html

**Contents:**
- Struct UiGlobalTransform Copy item path
- Implementations§
  - impl UiGlobalTransform
    - pub fn try_inverse(&self) -> Option<Affine2>
- Methods from Deref<Target = Affine2>§
    - pub const ZERO: Affine2
    - pub const IDENTITY: Affine2
    - pub const NAN: Affine2
    - pub fn to_cols_array(&self) -> [f32; 6]
    - pub fn to_cols_array_2d(&self) -> [[f32; 2]; 3]

Absolute 2D transform for UI nodes

UiGlobalTransforms are updated from UiTransform and Node in ui_layout_system

If the transform is invertible returns its inverse. Otherwise returns None.

Creates a [f32; 6] array storing data in column major order.

Creates a [[f32; 2]; 3] 2D array storing data in column major order. If you require data in row major order transpose the matrix first.

Transforms the given 2D point, applying shear, scale, rotation and translation.

Transforms the given 2D vector, applying shear, scale and rotation (but NOT translation).

To also apply translation, use Self::transform_point2() instead.

Returns true if, and only if, all elements are finite.

If any element is either NaN, positive or negative infinity, this will return false.

Returns true if any elements are NaN.

Returns true if the absolute difference of all elements between self and rhs is less than or equal to max_abs_diff.

This can be used to compare if two 3x4 matrices contain similar elements. It works best when comparing with a known value. The max_abs_diff that should be used used depends on the values being compared against.

For more see comparing floating point numbers.

Return the inverse of this transform.

Note that if the transform is not invertible the result will be invalid.

Casts all elements of self to f64.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiGlobalTransform(/* private fields */);
```

---

## Struct RunFixedMainLoop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RunFixedMainLoop.html

**Contents:**
- Struct RunFixedMainLoop Copy item path
- Trait Implementations§
  - impl Clone for RunFixedMainLoop
    - fn clone(&self) -> RunFixedMainLoop
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for RunFixedMainLoop
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for RunFixedMainLoop
    - fn default() -> RunFixedMainLoop
  - impl Hash for RunFixedMainLoop

Runs the FixedMain schedule in a loop according until all relevant elapsed time has been “consumed”.

If you need to order your variable timestep systems before or after the fixed update logic, use the RunFixedMainLoopSystems system set.

Note that in contrast to most other Bevy schedules, systems added directly to RunFixedMainLoop will not be parallelized between each other.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RunFixedMainLoop;
```

---

## Trait AssetApp Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AssetApp.html

**Contents:**
- Trait AssetApp Copy item path
- Required Methods§
    - fn register_asset_loader<L>(&mut self, loader: L) -> &mut Selfwhere L: AssetLoader,
    - fn register_asset_processor<P>(&mut self, processor: P) -> &mut Selfwhere P: Process,
    - fn register_asset_source( &mut self, id: impl Into<AssetSourceId<'static>>, source: AssetSourceBuilder, ) -> &mut Self
    - fn set_default_asset_processor<P>(&mut self, extension: &str) -> &mut Selfwhere P: Process,
    - fn init_asset_loader<L>(&mut self) -> &mut Selfwhere L: AssetLoader + FromWorld,
    - fn init_asset<A>(&mut self) -> &mut Selfwhere A: Asset,
    - fn register_asset_reflect<A>(&mut self) -> &mut Selfwhere A: Asset + Reflect + FromReflect + GetTypeRegistration,
    - fn preregister_asset_loader<L>(&mut self, extensions: &[&str]) -> &mut Selfwhere L: AssetLoader,

Adds asset-related builder methods to App.

Registers the given loader in the App’s AssetServer.

Registers the given processor in the App’s AssetProcessor.

Registers the given AssetSourceBuilder with the given id.

Note that asset sources must be registered before adding AssetPlugin to your application, since registered asset sources are built at that point and not after.

Sets the default asset processor for the given extension.

Initializes the given loader in the App’s AssetServer.

Initializes the given Asset in the App by:

Registers the asset type T using [App::register], and adds ReflectAsset type data to T and ReflectHandle type data to Handle<T> in the type registry.

This enables reflection code to access assets. For detailed information, see the docs on ReflectAsset and ReflectHandle.

Preregisters a loader for the given extensions, that will block asset loads until a real loader is registered.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AssetApp {
    // Required methods
    fn register_asset_loader<L>(&mut self, loader: L) -> &mut Self
       where L: AssetLoader;
    fn register_asset_processor<P>(&mut self, processor: P) -> &mut Self
       where P: Process;
    fn register_asset_source(
        &mut self,
        id: impl Into<AssetSourceId<'static>>,
        source: AssetSourceBuilder,
    ) -> &mut Self;
    fn set_default_asset_processor<P>(&mut self, extension: &str) -> &mut Self
       where P: Process;
    fn init_asset_loader<L>(&mut self) -> &mut Self
       where L: AssetLoader + FromWorld;
    fn init_
...
```

---

## Struct PickingMessageWriters Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PickingMessageWriters.html

**Contents:**
- Struct PickingMessageWriters Copy item path
- Trait Implementations§
  - impl SystemParam for PickingMessageWriters<'_>
    - type State = FetchState
    - type Item<'w, 's> = PickingMessageWriters<'w>
    - fn init_state( world: &mut World, ) -> <PickingMessageWriters<'_> as SystemParam>::State
    - fn init_access( state: &<PickingMessageWriters<'_> as SystemParam>::State, system_meta: &mut SystemMeta, component_access_set: &mut FilteredAccessSet, world: &mut World, )
    - fn apply( state: &mut <PickingMessageWriters<'_> as SystemParam>::State, system_meta: &SystemMeta, world: &mut World, )
    - fn queue( state: &mut <PickingMessageWriters<'_> as SystemParam>::State, system_meta: &SystemMeta, world: DeferredWorld<'_>, )
    - unsafe fn validate_param<'w, 's>( state: &'s mut <PickingMessageWriters<'_> as SystemParam>::State, _system_meta: &SystemMeta, _world: UnsafeWorldCell<'w>, ) -> Result<(), SystemParamValidationError>

A helper system param for accessing the picking event writers.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PickingMessageWriters<'w> { /* private fields */ }
```

---

## Struct Main Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Main.html

**Contents:**
- Struct Main Copy item path
- §Rendering
- Implementations§
  - impl Main
    - pub fn run_main(world: &mut World, run_at_least_once: Local<'_, bool>)
- Trait Implementations§
  - impl Clone for Main
    - fn clone(&self) -> Main
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Main

The schedule that contains the app logic that is evaluated each tick of App::update().

By default, it will run the following schedules in the given order:

On the first run of the schedule (and only on the first run), it will run:

Note rendering is not executed in the main schedule by default. Instead, rendering is performed in a separate SubApp which exchanges data with the main app in between the main schedule runs.

See RenderPlugin and PipelinedRenderingPlugin for more details.

StateTransition is inserted only if you have bevy_state feature enabled. It is enabled in default features. ↩ 1 2

A system that runs the “main schedule”

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Main;
```

---

## Struct CircularInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CircularInCurve.html

**Contents:**
- Struct CircularInCurve Copy item path
- Trait Implementations§
  - impl Clone for CircularInCurve
    - fn clone(&self) -> CircularInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for CircularInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = 1.0 - sqrt(1.0 - t²)

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CircularInCurve;
```

---

## Struct UVec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UVec4.html

**Contents:**
- Struct UVec4 Copy item path
- Fields§
- Implementations§
  - impl UVec4
    - pub const ZERO: UVec4
    - pub const ONE: UVec4
    - pub const MIN: UVec4
    - pub const MAX: UVec4
    - pub const X: UVec4
    - pub const Y: UVec4

A 4-dimensional vector.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the positive W axis.

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z, w]

Creates a vector from the first 4 values in slice.

Panics if slice is less than 4 elements long.

Writes the elements of self to the first 4 elements in slice.

Panics if slice is less than 4 elements long.

Creates a 3D vector from the x, y and z elements of self, discarding w.

Truncation to UVec3 may also be performed by using self.xyz().

Creates a 4D vector from self with the given value of x.

Creates a 4D vector from self with the given value of y.

Creates a 4D vector from self with the given value of z.

Creates a 4D vector from self with the given value of w.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

Component-wise clamping of values, similar to u32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

Returns the index of the first minimum element of self.

Returns the index of the first maximum element of self.

Returns the sum of all elements of self.

In other words, this computes self.x + self.y + ...

Returns the product of all elements of self.

In other words, this computes self.x * self.y * ...

Returns a vector mask containing the result of a == comparison for each element of self and rhs.

In other words, this computes [s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct UVec4 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
    pub w: u32,
}
```

---

## Struct Font Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Font.html

**Contents:**
- Struct Font Copy item path
- §A note on fonts
- Fields§
- Implementations§
  - impl Font
    - pub fn try_from_bytes(font_data: Vec<u8>) -> Result<Font, FaceParsingError>
- Trait Implementations§
  - impl Clone for Font
    - fn clone(&self) -> Font
    - fn clone_from(&mut self, source: &Self)

An Asset that contains the data for a loaded font, if loaded as an asset.

Loaded by FontLoader.

Font may differ from the everyday notion of what a “font” is. A font face (e.g. Fira Sans Semibold Italic) is part of a font family (e.g. Fira Sans), and is distinguished from other font faces in the same family by its style (e.g. italic), its weight (e.g. bold) and its stretch (e.g. condensed).

Bevy currently loads a single font face as a single Font asset.

Content of a font file as bytes

Creates a Font from bytes

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Font {
    pub data: Arc<Vec<u8>>,
}
```

---

## Trait BuildChildrenTransformExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.BuildChildrenTransformExt.html

**Contents:**
- Trait BuildChildrenTransformExt Copy item path
- Required Methods§
    - fn set_parent_in_place(&mut self, parent: Entity) -> &mut Self
    - fn remove_parent_in_place(&mut self) -> &mut Self
- Dyn Compatibility§
- Implementors§
  - impl BuildChildrenTransformExt for EntityCommands<'_>
  - impl BuildChildrenTransformExt for EntityWorldMut<'_>

Collection of methods similar to the built-in parenting methods on EntityWorldMut and EntityCommands, but preserving each entity’s GlobalTransform.

Change this entity’s parent while preserving this entity’s GlobalTransform by updating its Transform.

Insert the ChildOf component directly if you don’t want to also update the Transform.

Note that both the hierarchy and transform updates will only execute the next time commands are applied (during ApplyDeferred).

Make this entity parentless while preserving this entity’s GlobalTransform by updating its Transform to be equal to its current GlobalTransform.

See EntityWorldMut::remove::<ChildOf> or EntityCommands::remove::<ChildOf> for a method that doesn’t update the Transform.

Note that both the hierarchy and transform updates will only execute the next time commands are applied (during ApplyDeferred).

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait BuildChildrenTransformExt {
    // Required methods
    fn set_parent_in_place(&mut self, parent: Entity) -> &mut Self;
    fn remove_parent_in_place(&mut self) -> &mut Self;
}
```

---

## Struct Xyza Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Xyza.html

**Contents:**
- Struct Xyza Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Xyza
    - pub const D65_WHITE: Xyza
    - pub const fn new(x: f32, y: f32, z: f32, alpha: f32) -> Xyza
      - §Arguments
    - pub const fn xyz(x: f32, y: f32, z: f32) -> Xyza
      - §Arguments

CIE 1931 color space, also known as XYZ, with an alpha channel.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The x-axis. [0.0, 1.0]

The y-axis, intended to represent luminance. [0.0, 1.0]

The z-axis. [0.0, 1.0]

The alpha channel. [0.0, 1.0]

Construct a new Xyza color from components.

Construct a new Xyza color from (x, y, z) components, with the default alpha (1.0).

Return a copy of this color with the ‘x’ channel set to the given value.

Return a copy of this color with the ‘y’ channel set to the given value.

Return a copy of this color with the ‘z’ channel set to the given value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Xyza {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

---

## Struct Tetrahedron Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Tetrahedron.html

**Contents:**
- Struct Tetrahedron Copy item path
- Fields§
- Implementations§
  - impl Tetrahedron
    - pub const fn new(a: Vec3, b: Vec3, c: Vec3, d: Vec3) -> Tetrahedron
    - pub fn signed_volume(&self) -> f32
    - pub fn centroid(&self) -> Vec3
    - pub fn faces(&self) -> [Triangle3d; 4]
- Trait Implementations§
  - impl Clone for Tetrahedron

A tetrahedron primitive.

The vertices of the tetrahedron.

Create a new Tetrahedron from points a, b, c and d.

Get the signed volume of the tetrahedron.

If it’s negative, the normal vector of the face defined by the first three points using the right-hand rule points away from the fourth vertex.

Get the centroid of the tetrahedron.

This function finds the geometric center of the tetrahedron by averaging the vertices: centroid = (a + b + c + d) / 4.

Get the triangles that form the faces of this tetrahedron.

Note that the orientations of the faces are determined by that of the tetrahedron; if the signed volume of this tetrahedron is positive, then the triangles’ normals will point outward, and if the signed volume is negative they will point inward.

Returns the default Tetrahedron with the vertices [0.5, 0.5, 0.5], [-0.5, 0.5, -0.5], [-0.5, -0.5, 0.5] and [0.5, -0.5, -0.5].

Get the surface area of the tetrahedron.

Get the volume of the tetrahedron.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Tetrahedron {
    pub vertices: [Vec3; 4],
}
```

---

## Trait Event Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Event.html

**Contents:**
- Trait Event Copy item path
- §Triggers
- §Entity Events
- Required Associated Types§
    - type Trigger<'a>: Trigger<Self>
- Dyn Compatibility§
- Implementors§
  - impl Event for CheckChangeTickswhere CheckChangeTicks: Send + Sync + 'static,
    - type Trigger<'a> = GlobalTrigger
  - impl Event for AcquireFocuswhere AcquireFocus: Send + Sync + 'static,

An Event is something that “happens” at a given moment.

To make an Event “happen”, you “trigger” it on a World using World::trigger or via a Command using Commands::trigger. This causes any Observer watching for that Event to run immediately, as part of the World::trigger call.

First, we create an Event type, typically by deriving the trait.

Then, we add an Observer to watch for this event type:

Finally, we trigger the event by calling World::trigger:

Every Event has an associated Trigger implementation (set via Event::Trigger), which defines which observers will run, what data will be passed to them, and the order they will be run in. Unless you are an internals developer or you have very specific needs, you don’t need to worry too much about Trigger. When you derive Event (or a more specific event trait like EntityEvent), a Trigger will be provided for you.

The Event derive defaults Event::Trigger to GlobalTrigger, which will run all observers that watch for the Event.

For events that “target” a specific Entity, see EntityEvent.

Defines which observers will run, what data will be passed to them, and the order they will be run in. See Trigger for more info.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Event:
    Sized
    + Send
    + Sync
    + 'static {
    type Trigger<'a>: Trigger<Self>;
}
```

Example 2 (unknown):
```unknown
#[derive(Event)]
struct Speak {
    message: String,
}
```

Example 3 (unknown):
```unknown
world.add_observer(|speak: On<Speak>| {
    println!("{}", speak.message);
});
```

Example 4 (unknown):
```unknown
world.trigger(Speak {
    message: "Hello!".to_string(),
});
```

---

## Function resource_exists_and_equals Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_exists_and_equals.html

**Contents:**
- Function resource_exists_and_equals Copy item path
- §Example

Generates a SystemCondition-satisfying closure that returns true if the resource exists and is equal to value.

The condition will return false if the resource does not exist.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_exists_and_equals<T>(value: T) -> impl FnMut(Option<Res<'_, T>>)where
    T: Resource + PartialEq,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_exists_and_equals` will only return true
    // if the given resource exists and equals the given value
    my_system.run_if(resource_exists_and_equals(Counter(0))),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `Counter` hasn't been added so `my_system` can't run
app.run(&mut world);
world.init_resource::<Counter>();

// `Counter` is `0` so `my_system` can run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);

// `Counter` is no longer `0` so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<C
...
```

---

## Struct BevyError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BevyError.html

**Contents:**
- Struct BevyError Copy item path
- §Backtraces
- §Usage
- Implementations§
  - impl BevyError
    - pub fn downcast_ref<E>(&self) -> Option<&E>where E: Error + 'static,
- Trait Implementations§
  - impl Debug for BevyError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for BevyError

The built in “universal” Bevy error type. This has a blanket From impl for any type that implements Rust’s Error, meaning it can be used as a “catch all” error.

When used with the backtrace Cargo feature, it will capture a backtrace when the error is constructed (generally in the From impl]). When printed, the backtrace will be displayed. By default, the backtrace will be trimmed down to filter out noise. To see the full backtrace, set the BEVY_BACKTRACE=full environment variable.

Attempts to downcast the internal error to the given type.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BevyError { /* private fields */ }
```

Example 2 (javascript):
```javascript
fn fallible_system() -> Result<(), BevyError> {
    // This will result in Rust's built-in ParseIntError, which will automatically
    // be converted into a BevyError.
    let parsed: usize = "I am not a number".parse()?;
    Ok(())
}
```

---

## Struct GridTrack Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GridTrack.html

**Contents:**
- Struct GridTrack Copy item path
- Implementations§
  - impl GridTrack
    - pub const DEFAULT: GridTrack
    - pub fn px<T>(value: f32) -> Twhere T: From<GridTrack>,
      - Examples found in repository?
    - pub fn percent<T>(value: f32) -> Twhere T: From<GridTrack>,
    - pub fn fr<T>(value: f32) -> Twhere T: From<GridTrack>,
      - Examples found in repository?
    - pub fn flex<T>(value: f32) -> Twhere T: From<GridTrack>,

A GridTrack is a Row or Column of a CSS Grid. This struct specifies what size the track should be. See below for the different “track sizing functions” you can specify.

Create a grid track with a fixed pixel size

Create a grid track with a percentage size

Create a grid track with an fr size. Note that this will give the track a content-based minimum size. Usually you are best off using GridTrack::flex instead which uses a zero minimum size.

Create a grid track with a minmax(0, Nfr) size.

Create a grid track which is automatically sized to fit its contents.

Create a grid track which is automatically sized to fit its contents when sized at their “min-content” sizes

Create a grid track which is automatically sized to fit its contents when sized at their “max-content” sizes

Create a fit-content() grid track with fixed pixel limit.

https://developer.mozilla.org/en-US/docs/Web/CSS/fit-content_function

Create a fit-content() grid track with percentage limit.

https://developer.mozilla.org/en-US/docs/Web/CSS/fit-content_function

Create a minmax() grid track.

https://developer.mozilla.org/en-US/docs/Web/CSS/minmax

Create a grid track with a percentage of the viewport’s smaller dimension

Create a grid track with a percentage of the viewport’s larger dimension

Create a grid track with a percentage of the viewport’s height dimension

Create a grid track with a percentage of the viewport’s width dimension

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GridTrack { /* private fields */ }
```

Example 2 (unknown):
```unknown
218    pub fn setup(mut commands: Commands) {
219        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Grid)));
220        // Top-level grid (app frame)
221        commands.spawn((
222            Node {
223                display: Display::Grid,
224                width: percent(100),
225                height: percent(100),
226                grid_template_columns: vec![GridTrack::min_content(), GridTrack::flex(1.0)],
227                grid_template_rows: vec![
228                    GridTrack::auto(),
229                    GridTrack::flex(1.0),
230                    GridTrack::px(
...
```

Example 3 (javascript):
```javascript
18fn spawn_layout(mut commands: Commands, asset_server: Res<AssetServer>) {
19    let font = asset_server.load("fonts/FiraSans-Bold.ttf");
20    commands.spawn(Camera2d);
21
22    // Top-level grid (app frame)
23    commands
24        .spawn((
25            Node {
26                // Use the CSS Grid algorithm for laying out this node
27                display: Display::Grid,
28                // Make node fill the entirety of its parent (in this case the window)
29                width: percent(100),
30                height: percent(100),
31                // Set the grid to have 2 columns 
...
```

Example 4 (javascript):
```javascript
18fn spawn_layout(mut commands: Commands, asset_server: Res<AssetServer>) {
19    let font = asset_server.load("fonts/FiraSans-Bold.ttf");
20    commands.spawn(Camera2d);
21
22    // Top-level grid (app frame)
23    commands
24        .spawn((
25            Node {
26                // Use the CSS Grid algorithm for laying out this node
27                display: Display::Grid,
28                // Make node fill the entirety of its parent (in this case the window)
29                width: percent(100),
30                height: percent(100),
31                // Set the grid to have 2 columns 
...
```

---

## Struct Overflow Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Overflow.html

**Contents:**
- Struct Overflow Copy item path
- Fields§
- Implementations§
  - impl Overflow
    - pub const DEFAULT: Overflow
    - pub const fn visible() -> Overflow
      - Examples found in repository?
    - pub const fn clip() -> Overflow
      - Examples found in repository?
    - pub const fn clip_x() -> Overflow

Whether to show or hide overflowing items

Whether to show or clip overflowing items on the x axis

Whether to show or clip overflowing items on the y axis

Show overflowing items on both axes

Clip overflowing items on both axes

Clip overflowing items on the x axis

Clip overflowing items on the y axis

Hide overflowing items on both axes by influencing layout and then clipping

Hide overflowing items on the x axis by influencing layout and then clipping

Hide overflowing items on the y axis by influencing layout and then clipping

Overflow is visible on both axes

Scroll overflowing items on the x axis

Scroll overflowing items on the y axis

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Overflow {
    pub x: OverflowAxis,
    pub y: OverflowAxis,
}
```

Example 2 (javascript):
```javascript
234fn toggle_overflow(
235    mut containers: Query<&mut Node, With<Container>>,
236    instructions: Single<Entity, With<Instructions>>,
237    mut writer: TextUiWriter,
238) {
239    for mut node in &mut containers {
240        node.overflow = match node.overflow {
241            Overflow {
242                x: OverflowAxis::Visible,
243                y: OverflowAxis::Visible,
244            } => Overflow::clip_y(),
245            Overflow {
246                x: OverflowAxis::Visible,
247                y: OverflowAxis::Clip,
248            } => Overflow::clip_x(),
249            Overflow
...
```

Example 3 (javascript):
```javascript
496    pub fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
497        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Overflow)));
498        let image = asset_server.load("branding/icon.png");
499
500        commands
501            .spawn((
502                Node {
503                    width: percent(100),
504                    height: percent(100),
505                    align_items: AlignItems::Center,
506                    justify_content: JustifyContent::SpaceAround,
507                    ..Default::default()
508                },
509                Backgrou
...
```

Example 4 (javascript):
```javascript
13fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
14    commands.spawn(Camera2d);
15
16    let text_style = TextFont::default();
17
18    let image = asset_server.load("branding/icon.png");
19
20    commands
21        .spawn((
22            Node {
23                width: percent(100),
24                height: percent(100),
25                align_items: AlignItems::Center,
26                justify_content: JustifyContent::Center,
27                ..Default::default()
28            },
29            BackgroundColor(ANTIQUE_WHITE.into()),
30        ))
31        .with_childr
...
```

---

## Struct AppFunctionRegistry Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AppFunctionRegistry.html

**Contents:**
- Struct AppFunctionRegistry Copy item path
- Tuple Fields§
- Methods from Deref<Target = FunctionRegistryArc>§
    - pub fn read(&self) -> RwLockReadGuard<'_, FunctionRegistry>
    - pub fn write(&self) -> RwLockWriteGuard<'_, FunctionRegistry>
- Trait Implementations§
  - impl Clone for AppFunctionRegistry
    - fn clone(&self) -> AppFunctionRegistry
    - fn clone_from(&mut self, source: &Self)
  - impl Default for AppFunctionRegistry

A Resource storing FunctionRegistry for function registrations relevant to a whole app.

Takes a read lock on the underlying FunctionRegistry.

Takes a write lock on the underlying FunctionRegistry.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AppFunctionRegistry(pub FunctionRegistryArc);
```

---

## Enum Ime Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Ime.html

**Contents:**
- Enum Ime Copy item path
- Variants§
  - Preedit
    - Fields
  - Commit
    - Fields
  - Enabled
    - Fields
  - Disabled
    - Fields

An Input Method Editor event.

This event is the translated version of the WindowEvent::Ime from the winit crate.

It is only sent if IME was enabled on the window with Window::ime_enabled.

Notifies when a new composing text should be set at the cursor position.

Window that received the event.

Cursor begin and end position.

None indicated the cursor should be hidden

Notifies when text should be inserted into the editor widget.

Window that received the event.

Notifies when the IME was enabled.

After this event, you will receive events Ime::Preedit and Ime::Commit.

Window that received the event.

Notifies when the IME was disabled.

Window that received the event.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Ime {
    Preedit {
        window: Entity,
        value: String,
        cursor: Option<(usize, usize)>,
    },
    Commit {
        window: Entity,
        value: String,
    },
    Enabled {
        window: Entity,
    },
    Disabled {
        window: Entity,
    },
}
```

---

## Struct ComputedNode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ComputedNode.html

**Contents:**
- Struct ComputedNode Copy item path
- Fields§
- Implementations§
  - impl ComputedNode
    - pub const fn size(&self) -> Vec2
      - Examples found in repository?
    - pub const fn content_size(&self) -> Vec2
      - Examples found in repository?
    - pub const fn is_empty(&self) -> bool
    - pub const fn stack_index(&self) -> u32

Provides the computed size and layout properties of the node.

Fields in this struct are public but should not be modified under most circumstances. For example, in a scrollbar you may want to derive the handle’s size from the proportion of scrollable content in-view. You can directly modify ComputedNode after layout to set the handle size without any delays.

The order of the node in the UI layout. Nodes with a higher stack index are drawn on top of and receive interactions before nodes with lower stack indices.

Automatically calculated in UiSystems::Stack.

The size of the node as width and height in physical pixels.

Automatically calculated by ui_layout_system.

Size of this node’s content.

Automatically calculated by ui_layout_system.

Space allocated for scrollbars.

Automatically calculated by ui_layout_system.

Resolved offset of scrolled content

Automatically calculated by ui_layout_system.

The width of this node’s outline. If this value is Auto, negative or 0. then no outline will be rendered. Outline updates bypass change detection.

Automatically calculated by ui_layout_system.

The amount of space between the outline and the edge of the node. Outline updates bypass change detection.

Automatically calculated by ui_layout_system.

The unrounded size of the node as width and height in physical pixels.

Automatically calculated by ui_layout_system.

Resolved border values in physical pixels. Border updates bypass change detection.

Automatically calculated by ui_layout_system.

Resolved border radius values in physical pixels. Border radius updates bypass change detection.

Automatically calculated by ui_layout_system.

Resolved padding values in physical pixels. Padding updates bypass change detection.

Automatically calculated by ui_layout_system.

Inverse scale factor for this Node. Multiply physical coordinates by the inverse scale factor to give logical coordinates.

Automatically calculated by ui_layout_system.

The calculated node size as width and height in physical pixels.

Automatically calculated by ui_layout_system.

The calculated node content size as width and height in physical pixels.

Automatically calculated by ui_layout_system.

Check if the node is empty. A node is considered empty if it has a zero or negative extent along either of its axes.

The order of the node in the UI layout. Nodes with a higher stack index are drawn on top of and receive interactions before nodes with lower stack indices.

Automatically calculated 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct ComputedNode {
    pub stack_index: u32,
    pub size: Vec2,
    pub content_size: Vec2,
    pub scrollbar_size: Vec2,
    pub scroll_position: Vec2,
    pub outline_width: f32,
    pub outline_offset: f32,
    pub unrounded_size: Vec2,
    pub border: BorderRect,
    pub border_radius: ResolvedBorderRadius,
    pub padding: BorderRect,
    pub inverse_scale_factor: f32,
}
```

Example 2 (javascript):
```javascript
438pub fn update_scroll_position(
439    mut mouse_wheel_reader: MessageReader<MouseWheel>,
440    hover_map: Res<HoverMap>,
441    mut scrolled_node_query: Query<(&mut ScrollPosition, &ComputedNode), Without<Scrollbar>>,
442    keyboard_input: Res<ButtonInput<KeyCode>>,
443) {
444    for mouse_wheel in mouse_wheel_reader.read() {
445        let (mut dx, mut dy) = match mouse_wheel.unit {
446            MouseScrollUnit::Line => (mouse_wheel.x * 20., mouse_wheel.y * 20.),
447            MouseScrollUnit::Pixel => (mouse_wheel.x, mouse_wheel.y),
448        };
449
450        if keyboard_input.pres
...
```

Example 3 (javascript):
```javascript
59fn on_scroll_handler(
60    mut scroll: On<Scroll>,
61    mut query: Query<(&mut ScrollPosition, &Node, &ComputedNode)>,
62) {
63    let Ok((mut scroll_position, node, computed)) = query.get_mut(scroll.entity) else {
64        return;
65    };
66
67    let max_offset = (computed.content_size() - computed.size()) * computed.inverse_scale_factor();
68
69    let delta = &mut scroll.delta;
70    if node.overflow.x == OverflowAxis::Scroll && delta.x != 0. {
71        // Is this node already scrolled all the way in the direction of the scroll?
72        let max = if delta.x > 0. {
73            sc
...
```

Example 4 (javascript):
```javascript
438pub fn update_scroll_position(
439    mut mouse_wheel_reader: MessageReader<MouseWheel>,
440    hover_map: Res<HoverMap>,
441    mut scrolled_node_query: Query<(&mut ScrollPosition, &ComputedNode), Without<Scrollbar>>,
442    keyboard_input: Res<ButtonInput<KeyCode>>,
443) {
444    for mouse_wheel in mouse_wheel_reader.read() {
445        let (mut dx, mut dy) = match mouse_wheel.unit {
446            MouseScrollUnit::Line => (mouse_wheel.x * 20., mouse_wheel.y * 20.),
447            MouseScrollUnit::Pixel => (mouse_wheel.x, mouse_wheel.y),
448        };
449
450        if keyboard_input.pres
...
```

---

## Struct ReparamCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReparamCurve.html

**Contents:**
- Struct ReparamCurve Copy item path
- Trait Implementations§
  - impl<T, C, F> Clone for ReparamCurve<T, C, F>where T: Clone, C: Clone, F: Clone,
    - fn clone(&self) -> ReparamCurve<T, C, F>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C, F> Curve<T> for ReparamCurve<T, C, F>where C: Curve<T>, F: Fn(f32) -> f32,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

A curve whose sample space is mapped onto that of some base curve’s before sampling. Curves of this type are produced by CurveExt::reparametrize.

Note: This is not a fully stable implementation of TypePath due to usage of type_name for function members.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReparamCurve<T, C, F> { /* private fields */ }
```

---

## Enum Projection Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Projection.html

**Contents:**
- Enum Projection Copy item path
  - §What’s a projection?
- Variants§
  - Perspective(PerspectiveProjection)
  - Orthographic(OrthographicProjection)
  - Custom(CustomProjection)
- Implementations§
  - impl Projection
    - pub fn custom<P>(projection: P) -> Projectionwhere P: CameraProjection + Debug + Send + Sync + Clone + 'static,
      - Examples found in repository?

Component that defines how to compute a Camera’s projection matrix.

Common projections, like perspective and orthographic, are provided out of the box to handle the majority of use cases. Custom projections can be added using the CameraProjection trait and the Projection::custom constructor.

A camera projection essentially describes how 3d points from the point of view of a camera are projected onto a 2d screen. This is where properties like a camera’s field of view are defined. More specifically, a projection is a 4x4 matrix that transforms points from view space (the point of view of the camera) into clip space. Clip space is almost, but not quite, equivalent to the rectangle that is rendered to your screen, with a depth axis. Any points that land outside the bounds of this cuboid are “clipped” and not rendered.

You can also think of the projection as the thing that describes the shape of a camera’s frustum: the volume in 3d space that is visible to a camera.

Construct a new custom camera projection from a type that implements CameraProjection.

Check if the projection is perspective. For CustomProjection, this checks if the projection matrix’s w-axis’s w is 0.0.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Projection {
    Perspective(PerspectiveProjection),
    Orthographic(OrthographicProjection),
    Custom(CustomProjection),
}
```

Example 2 (unknown):
```unknown
50fn setup(
51    mut commands: Commands,
52    mut meshes: ResMut<Assets<Mesh>>,
53    mut materials: ResMut<Assets<StandardMaterial>>,
54) {
55    commands.spawn((
56        Camera3d::default(),
57        // Use our custom projection:
58        Projection::custom(ObliquePerspectiveProjection {
59            horizontal_obliqueness: 0.2,
60            vertical_obliqueness: 0.6,
61            perspective: PerspectiveProjection::default(),
62        }),
63        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
64    ));
65
66    // Scene setup
67    commands.spawn((
68      
...
```

---

## Struct DragOver Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragOver.html

**Contents:**
- Struct DragOver Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragOver
    - fn clone(&self) -> DragOver
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragOver
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragOver
    - type This<'from_arg> = DragOver

Fires while the dragged entity is being dragged over the target entity.

Pointer button pressed while dragging over.

The entity that was being dragged when the pointer was over the target entity.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragOver {
    pub button: PointerButton,
    pub dragged: Entity,
    pub hit: HitData,
}
```

---

## Function resource_exists Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_exists.html

**Contents:**
- Function resource_exists Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the resource exists.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_exists<T>(res: Option<Res<'_, T>>) -> boolwhere
    T: Resource,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_exists` will only return true if the given resource exists in the world
    my_system.run_if(resource_exists::<Counter>),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `Counter` hasn't been added so `my_system` won't run
app.run(&mut world);
world.init_resource::<Counter>();

// `Counter` has now been added so `my_system` can run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Enum ResamplingError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ResamplingError.html

**Contents:**
- Enum ResamplingError Copy item path
- Variants§
  - NotEnoughSamples(usize)
  - UnboundedDomain
- Trait Implementations§
  - impl Debug for ResamplingError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for ResamplingError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for ResamplingError

An error indicating that a resampling operation could not be performed because of malformed inputs.

This resampling operation was not provided with enough samples to have well-formed output.

This resampling operation failed because of an unbounded interval.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ResamplingError {
    NotEnoughSamples(usize),
    UnboundedDomain,
}
```

---

## Function mat2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.mat2.html

**Contents:**
- Function mat2 Copy item path

Creates a 2x2 matrix from two column vectors.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn mat2(x_axis: Vec2, y_axis: Vec2) -> Mat2
```

---

## Struct CalculatedClip Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CalculatedClip.html

**Contents:**
- Struct CalculatedClip Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for CalculatedClip
    - fn clone(&self) -> CalculatedClip
    - fn clone_from(&mut self, source: &Self)
  - impl Component for CalculatedClipwhere CalculatedClip: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

The calculated clip of the node

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CalculatedClip {
    pub clip: Rect,
}
```

---

## Struct SerializedAnimationGraph Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SerializedAnimationGraph.html

**Contents:**
- Struct SerializedAnimationGraph Copy item path
- Fields§
- Trait Implementations§
  - impl<'de> Deserialize<'de> for SerializedAnimationGraph
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<SerializedAnimationGraph, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,
  - impl Serialize for SerializedAnimationGraph
    - fn serialize<__S>( &self, __serializer: __S, ) -> Result<<__S as Serializer>::Ok, <__S as Serializer>::Error>where __S: Serializer,
  - impl TryFrom<AnimationGraph> for SerializedAnimationGraph
    - type Error = NonPathHandleError
    - fn try_from( animation_graph: AnimationGraph, ) -> Result<SerializedAnimationGraph, NonPathHandleError>

A version of AnimationGraph suitable for serializing as an asset.

Animation nodes can refer to external animation clips, and the AssetId is typically not sufficient to identify the clips, since the bevy_asset::AssetServer assigns IDs in unpredictable ways. That fact motivates this type, which replaces the Handle<AnimationClip> with an asset path. Loading an animation graph via the bevy_asset::AssetServer actually loads a serialized instance of this type, as does serializing an AnimationGraph through serde.

Corresponds to the graph field on AnimationGraph.

Corresponds to the root field on AnimationGraph.

Corresponds to the mask_groups field on AnimationGraph.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SerializedAnimationGraph {
    pub graph: Graph<SerializedAnimationGraphNode, ()>,
    pub root: NodeIndex,
    pub mask_groups: HashMap<AnimationTargetId, u64>,
}
```

---

## Struct DragDrop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragDrop.html

**Contents:**
- Struct DragDrop Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragDrop
    - fn clone(&self) -> DragDrop
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragDrop
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragDrop
    - type This<'from_arg> = DragDrop

Fires when a pointer drops the dropped entity onto the target entity.

Pointer button released to drop.

The entity that was dropped onto the target entity.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragDrop {
    pub button: PointerButton,
    pub dropped: Entity,
    pub hit: HitData,
}
```

---

## Struct Rect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Rect.html

**Contents:**
- Struct Rect Copy item path
- Fields§
- Implementations§
  - impl Rect
    - pub const EMPTY: Rect
    - pub fn new(x0: f32, y0: f32, x1: f32, y1: f32) -> Rect
      - §Examples
    - pub fn from_corners(p0: Vec2, p1: Vec2) -> Rect
      - §Examples
    - pub fn from_center_size(origin: Vec2, size: Vec2) -> Rect

A rectangle defined by two opposite corners.

The rectangle is axis aligned, and defined by its minimum and maximum coordinates, stored in Rect::min and Rect::max, respectively. The minimum/maximum invariant must be upheld by the user when directly assigning the fields, otherwise some methods produce invalid results. It is generally recommended to use one of the constructor methods instead, which will ensure this invariant is met, unless you already have the minimum and maximum corners.

The minimum corner point of the rect.

The maximum corner point of the rect.

An empty Rect, represented by maximum and minimum corner points at Vec2::NEG_INFINITY and Vec2::INFINITY, respectively. This is so the Rect has a infinitely negative size. This is useful, because when taking a union B of a non-empty Rect A and this empty Rect, B will simply equal A.

Create a new rectangle from two corner points.

The two points do not need to be the minimum and/or maximum corners. They only need to be two opposite corners.

Create a new rectangle from two corner points.

The two points do not need to be the minimum and/or maximum corners. They only need to be two opposite corners.

Create a new rectangle from its center and size.

This method panics if any of the components of the size is negative.

Create a new rectangle from its center and half-size.

This method panics if any of the components of the half-size is negative.

Check if the rectangle is empty.

Rectangle width (max.x - min.x).

Rectangle height (max.y - min.y).

The center point of the rectangle.

Check if a point lies within this rectangle, inclusive of its edges.

Build a new rectangle formed of the union of this rectangle and another rectangle.

The union is the smallest rectangle enclosing both rectangles.

Build a new rectangle formed of the union of this rectangle and a point.

The union is the smallest rectangle enclosing both the rectangle and the point. If the point is already inside the rectangle, this method returns a copy of the rectangle.

Build a new rectangle formed of the intersection of this rectangle and another rectangle.

The intersection is the largest rectangle enclosed in both rectangles. If the intersection is empty, this method returns an empty rectangle (Rect::is_empty() returns true), but the actual values of Rect::min and Rect::max are implementation-dependent.

Create a new rectangle by expanding it evenly on all sides.

A positive expansion value produces a larger rectangle, while a 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct Rect {
    pub min: Vec2,
    pub max: Vec2,
}
```

Example 2 (javascript):
```javascript
let r = Rect::new(0., 4., 10., 6.); // w=10 h=2
let r = Rect::new(2., 3., 5., -1.); // w=3 h=4
```

Example 3 (javascript):
```javascript
// Unit rect from [0,0] to [1,1]
let r = Rect::from_corners(Vec2::ZERO, Vec2::ONE); // w=1 h=1
// Same; the points do not need to be ordered
let r = Rect::from_corners(Vec2::ONE, Vec2::ZERO); // w=1 h=1
```

Example 4 (javascript):
```javascript
let r = Rect::from_center_size(Vec2::ZERO, Vec2::ONE); // w=1 h=1
assert!(r.min.abs_diff_eq(Vec2::splat(-0.5), 1e-5));
assert!(r.max.abs_diff_eq(Vec2::splat(0.5), 1e-5));
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/asset/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§
- Derive Macros§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct PointerButtonState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PointerButtonState.html

**Contents:**
- Struct PointerButtonState Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for PointerButtonState
    - fn clone(&self) -> PointerButtonState
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PointerButtonState
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PointerButtonState
    - fn default() -> PointerButtonState

An entry in the cache that drives the pointer_events system, storing additional data about pointer button presses.

Stores the press location and start time for each button currently being pressed by the pointer.

Stores the starting and current locations for each entity currently being dragged by the pointer.

Stores the hit data for each entity currently being dragged over by the pointer.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PointerButtonState {
    pub pressing: HashMap<Entity, (Location, Instant, HitData)>,
    pub dragging: HashMap<Entity, DragEntry>,
    pub dragging_over: HashMap<Entity, HitData>,
}
```

---

## Function vh Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vh.html

**Contents:**
- Function vh Copy item path
      - Examples found in repository?

Returns a Val::Vh representing a percentage of the viewport height.

**Examples:**

Example 1 (unknown):
```unknown
pub fn vh<T>(value: T) -> Valwhere
    T: ValNum,
```

Example 2 (unknown):
```unknown
127fn setup(mut commands: Commands) {
128    commands.spawn(Camera2d);
129
130    commands.spawn((
131        Node {
132            width: vw(100),
133            height: vh(100),
134            flex_direction: FlexDirection::Column,
135            padding: UiRect::all(px(12)),
136            ..default()
137        },
138        LogViewerRoot,
139    ));
140}
```

Example 3 (javascript):
```javascript
263fn spawn_button(
264    commands: &mut ChildSpawnerCommands,
265    background_color: Color,
266    buttons: f32,
267    column: usize,
268    row: usize,
269    spawn_text: bool,
270    border: UiRect,
271    border_color: BorderColor,
272    image: Option<Handle<Image>>,
273) {
274    let width = vw(90.0 / buttons);
275    let height = vh(90.0 / buttons);
276    let margin = UiRect::axes(width * 0.05, height * 0.05);
277    let mut builder = commands.spawn((
278        Button,
279        Node {
280            width,
281            height,
282            margin,
283            align_items:
...
```

Example 4 (unknown):
```unknown
68fn spawn_with_viewport_coords(commands: &mut Commands) {
69    commands
70        .spawn((
71            Node {
72                width: vw(100),
73                height: vh(100),
74                border: UiRect::axes(vw(5), vh(5)),
75                flex_wrap: FlexWrap::Wrap,
76                ..default()
77            },
78            BorderColor::all(PALETTE[0]),
79            Coords::Viewport,
80        ))
81        .with_children(|builder| {
82            builder.spawn((
83                Node {
84                    width: vw(30),
85                    height: vh(30),
86             
...
```

---

## Struct ComputedUiRenderTargetInfo Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ComputedUiRenderTargetInfo.html

**Contents:**
- Struct ComputedUiRenderTargetInfo Copy item path
- Implementations§
  - impl ComputedUiRenderTargetInfo
    - pub const fn scale_factor(&self) -> f32
    - pub const fn physical_size(&self) -> UVec2
    - pub fn logical_size(&self) -> Vec2
- Trait Implementations§
  - impl Clone for ComputedUiRenderTargetInfo
    - fn clone(&self) -> ComputedUiRenderTargetInfo
    - fn clone_from(&mut self, source: &Self)

Derived information about the render target for this UI node.

Returns the size of the target camera’s viewport in physical pixels.

Returns the size of the target camera’s viewport in logical pixels.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ComputedUiRenderTargetInfo { /* private fields */ }
```

---

## Struct FunctionCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FunctionCurve.html

**Contents:**
- Struct FunctionCurve Copy item path
- Implementations§
  - impl<T, F> FunctionCurve<T, F>where F: Fn(f32) -> T,
    - pub fn new(domain: Interval, function: F) -> FunctionCurve<T, F>
      - Examples found in repository?
- Trait Implementations§
  - impl<T, F> Clone for FunctionCurve<T, F>where T: Clone, F: Clone,
    - fn clone(&self) -> FunctionCurve<T, F>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, F> Curve<T> for FunctionCurve<T, F>where F: Fn(f32) -> T,

A curve defined by a function together with a fixed domain.

This is a curve that holds an inner function f which takes numbers (f32) as input and produces output of type T. The value of this curve when sampled at time t is just f(t).

Create a new curve with the given domain from the given function. When sampled, the function is evaluated at the sample time to compute the output.

Note: This is not a fully stable implementation of TypePath due to usage of type_name for function members.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FunctionCurve<T, F> { /* private fields */ }
```

Example 2 (javascript):
```javascript
40fn draw_example_collection(
41    mut gizmos: Gizmos,
42    mut my_gizmos: Gizmos<MyRoundGizmos>,
43    time: Res<Time>,
44) {
45    let sin_t_scaled = ops::sin(time.elapsed_secs()) * 50.;
46    gizmos.line_2d(Vec2::Y * -sin_t_scaled, Vec2::splat(-80.), RED);
47    gizmos.ray_2d(Vec2::Y * sin_t_scaled, Vec2::splat(80.), LIME);
48
49    gizmos
50        .grid_2d(
51            Isometry2d::IDENTITY,
52            UVec2::new(16, 9),
53            Vec2::new(80., 80.),
54            // Dark gray
55            LinearRgba::gray(0.05),
56        )
57        .outer_edges();
58
59    // Triangle
60   
...
```

Example 3 (javascript):
```javascript
98fn draw_example_collection(
99    mut gizmos: Gizmos,
100    mut my_gizmos: Gizmos<MyRoundGizmos>,
101    time: Res<Time>,
102) {
103    gizmos.grid(
104        Quat::from_rotation_x(PI / 2.),
105        UVec2::splat(20),
106        Vec2::new(2., 2.),
107        // Light gray
108        LinearRgba::gray(0.65),
109    );
110    gizmos.grid(
111        Isometry3d::new(Vec3::splat(10.0), Quat::from_rotation_x(PI / 3. * 2.)),
112        UVec2::splat(20),
113        Vec2::new(2., 2.),
114        PURPLE,
115    );
116    gizmos.sphere(Vec3::splat(10.0), 1.0, PURPLE);
117
118    gizmos
119        .
...
```

---

## Struct AnimatableCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimatableCurve.html

**Contents:**
- Struct AnimatableCurve Copy item path
- Fields§
- Implementations§
  - impl<P, C> AnimatableCurve<P, C>where P: AnimatableProperty, C: AnimationCompatibleCurve<<P as AnimatableProperty>::Property>,
    - pub fn new(property: P, curve: C) -> AnimatableCurve<P, C>
      - Examples found in repository?
- Trait Implementations§
  - impl<P, C> AnimationCurve for AnimatableCurve<P, C>where P: Send + Sync + 'static + AnimatableProperty + Clone, C: AnimationCompatibleCurve<<P as AnimatableProperty>::Property> + Clone,
    - fn clone_value(&self) -> Box<dyn AnimationCurve>
    - fn domain(&self) -> Interval

This type allows the conversion of a curve valued in the property type of an AnimatableProperty into an AnimationCurve which animates that property.

The property selector, which defines what component to access and how to access a property on that component.

The inner curve whose values are used to animate the property.

Create an AnimatableCurve (and thus an AnimationCurve) from a curve valued in an animatable property.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimatableCurve<P, C> {
    pub property: P,
    pub curve: C,
}
```

Example 2 (javascript):
```javascript
36    fn create(
37        animation_graphs: &mut Assets<AnimationGraph>,
38        animation_clips: &mut Assets<AnimationClip>,
39    ) -> AnimationInfo {
40        // Create an ID that identifies the text node we're going to animate.
41        let animation_target_name = Name::new("Text");
42        let animation_target_id = AnimationTargetId::from_name(&animation_target_name);
43
44        // Allocate an animation clip.
45        let mut animation_clip = AnimationClip::default();
46
47        // Create a curve that animates font size.
48        animation_clip.add_curve_to_target(
49        
...
```

Example 3 (javascript):
```javascript
93    fn create(
94        animation_graphs: &mut Assets<AnimationGraph>,
95        animation_clips: &mut Assets<AnimationClip>,
96    ) -> AnimationInfo {
97        // Create an ID that identifies the text node we're going to animate.
98        let animation_target_name = Name::new("Cube");
99        let animation_target_id = AnimationTargetId::from_name(&animation_target_name);
100
101        // Allocate an animation clip.
102        let mut animation_clip = AnimationClip::default();
103
104        // Each leg of the translation motion should take 3 seconds.
105        let animation_domain =
...
```

Example 4 (javascript):
```javascript
22fn setup(
23    mut commands: Commands,
24    mut meshes: ResMut<Assets<Mesh>>,
25    mut materials: ResMut<Assets<StandardMaterial>>,
26    mut animations: ResMut<Assets<AnimationClip>>,
27    mut graphs: ResMut<Assets<AnimationGraph>>,
28) {
29    // Camera
30    commands.spawn((
31        Camera3d::default(),
32        Transform::from_xyz(-2.0, 2.5, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
33    ));
34
35    // Light
36    commands.spawn((
37        PointLight {
38            intensity: 500_000.0,
39            ..default()
40        },
41        Transform::from_xyz(0.0, 2.5, 0.0),
42    ));

...
```

---

## Struct UiTargetCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiTargetCamera.html

**Contents:**
- Struct UiTargetCamera Copy item path
- Tuple Fields§
- Implementations§
  - impl UiTargetCamera
    - pub fn entity(&self) -> Entity
- Trait Implementations§
  - impl Clone for UiTargetCamera
    - fn clone(&self) -> UiTargetCamera
    - fn clone_from(&mut self, source: &Self)
  - impl Component for UiTargetCamerawhere UiTargetCamera: Send + Sync + 'static,

Indicates that this root Node entity should be rendered to a specific camera.

UI then will be laid out respecting the camera’s viewport and scale factor, and rendered to this camera’s bevy_camera::RenderTarget.

Setting this component on a non-root node will have no effect. It will be overridden by the root node’s component.

Root node’s without an explicit UiTargetCamera will be rendered to the default UI camera, which is either a single camera with the IsDefaultUiCamera marker component or the highest order camera targeting the primary window.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiTargetCamera(pub Entity);
```

---

## Trait EntityEvent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.EntityEvent.html

**Contents:**
- Trait EntityEvent Copy item path
  - §Trigger Behavior
  - §EntityEvent Propagation
  - §Naming and Usage Conventions
  - §Manually spawning EntityEvent observers
- Required Methods§
    - fn event_target(&self) -> Entity
    - fn event_target_mut(&mut self) -> &mut Entity
- Dyn Compatibility§
- Implementors§

An EntityEvent is an Event that is triggered for a specific EntityEvent::event_target entity:

EntityEvent will set EntityEvent::event_target automatically for named structs with an entity field name (as seen above). It also works for tuple structs whose only field is Entity:

The EntityEvent::event_target can also be manually set using the #[event_target] field attribute:

When derived, EntityEvent defaults to setting Event::Trigger to EntityTrigger, which will run all normal “untargeted” observers added via World::add_observer, just like a default Event would (see the example above).

However it will also run all observers that watch specific entities, which enables you to assign entity-specific logic:

When deriving EntityEvent, you can enable “event propagation” (also known as “event bubbling”) by specifying the #[entity_event(propagate)] attribute:

This will default to using the ChildOf component to propagate the Event “up” the hierarchy (from child to parent).

You can also specify your own Traversal implementation. A common pattern is to use Relationship components, which will follow the relationships to their root (just be sure to avoid cycles … these aren’t detected for performance reasons):

By default, propagation requires observers to opt-in:

But you can enable auto propagation using the #[entity_event(auto_propagate)] attribute:

You can also stop propagation like this:

In most cases, it is recommended to use a named struct field for the “event target” entity, and to use a name that is descriptive as possible, as this makes events easier to understand and read.

For events with only one Entity field, entity is often a reasonable name. But if there are multiple Entity fields, it is often a good idea to use a more descriptive name.

It is also generally recommended to consume “event target” entities directly via their named field, as this can make the context clearer, allows for more specific documentation hints in IDEs, and it generally reads better.

The examples above that call EntityWorldMut::observe to add entity-specific observer logic are just shorthand for spawning an Observer directly and manually watching the entity:

Note that the Observer component is not added to the entity it is observing. Observers should always be their own entities, as there can be multiple observers of the same entity!

You can call Observer::watch_entity more than once or Observer::watch_entities to watch multiple entities with the same Observer.

The Entit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait EntityEvent: Event {
    // Required methods
    fn event_target(&self) -> Entity;
    fn event_target_mut(&mut self) -> &mut Entity;
}
```

Example 2 (unknown):
```unknown
#[derive(EntityEvent)]
struct Explode {
    entity: Entity,
}

world.add_observer(|event: On<Explode>, mut commands: Commands| {
    println!("Entity {} goes BOOM!", event.entity);
    commands.entity(event.entity).despawn();
});

world.trigger(Explode { entity });
```

Example 3 (unknown):
```unknown
#[derive(EntityEvent)]
struct Explode(Entity);
```

Example 4 (unknown):
```unknown
#[derive(EntityEvent)]
struct Explode {
    #[event_target]
    exploded_entity: Entity,
}
```

---

## Trait CurveWithDerivative Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derivatives/trait.CurveWithDerivative.html

**Contents:**
- Trait CurveWithDerivative Copy item path
- Required Methods§
    - fn with_derivative(self) -> SampleDerivativeWrapper<Self>
- Dyn Compatibility§
- Implementors§
  - impl<T, C> CurveWithDerivative<T> for Cwhere T: HasTangent, C: SampleDerivative<T>,

Trait for curves that have a well-defined notion of derivative, allowing for derivatives to be extracted along with values.

This is implemented by implementing SampleDerivative.

This curve, but with its first derivative included in sampling.

Notably, the output type is a Curve<WithDerivative<T>>.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait CurveWithDerivative<T>: Sized + SampleDerivative<T>where
    T: HasTangent,{
    // Required method
    fn with_derivative(self) -> SampleDerivativeWrapper<Self>;
}
```

---

## Trait AnimatableProperty Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AnimatableProperty.html

**Contents:**
- Trait AnimatableProperty Copy item path
- Required Associated Types§
    - type Property: Animatable
- Required Methods§
    - fn get_mut<'a>( &self, entity: &'a mut EntityMutExcept<'_, '_, (AnimationTarget, AnimationPlayer, AnimationGraphHandle)>, ) -> Result<&'a mut Self::Property, AnimationEvaluationError>
    - fn evaluator_id(&self) -> EvaluatorId<'_>
- Implementors§
  - impl<C, A, F> AnimatableProperty for AnimatedField<C, A, F>where C: Component<Mutability = Mutable>, A: Animatable + Clone + Sync + Debug, F: Fn(&mut C) -> &mut A + Send + Sync + 'static,
    - type Property = A

A trait for exposing a value in an entity so that it can be animated.

AnimatableProperty allows any value contained in an entity to be animated as long as it can be obtained by mutable reference. This makes it more flexible than animated_field.

Here, AnimatableProperty is used to animate a value inside an Option, returning an error if the option is None.

You can then create an AnimatableCurve to animate this property like so:

The animated property type.

Retrieves the property from the given entity.

The EvaluatorId used to look up the AnimationCurveEvaluator for this AnimatableProperty. For a given animated property, this ID should always be the same to allow things like animation blending to occur.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AnimatableProperty:
    Send
    + Sync
    + 'static {
    type Property: Animatable;

    // Required methods
    fn get_mut<'a>(
        &self,
        entity: &'a mut EntityMutExcept<'_, '_, (AnimationTarget, AnimationPlayer, AnimationGraphHandle)>,
    ) -> Result<&'a mut Self::Property, AnimationEvaluationError>;
    fn evaluator_id(&self) -> EvaluatorId<'_>;
}
```

Example 2 (javascript):
```javascript
#[derive(Component)]
struct ExampleComponent {
    power_level: Option<f32>
}

#[derive(Clone)]
struct PowerLevelProperty;

impl AnimatableProperty for PowerLevelProperty {
    type Property = f32;
    fn get_mut<'a>(
        &self,
        entity: &'a mut AnimationEntityMut
    ) -> Result<&'a mut Self::Property, AnimationEvaluationError> {
        let component = entity
            .get_mut::<ExampleComponent>()
            .ok_or(AnimationEvaluationError::ComponentNotPresent(
              TypeId::of::<ExampleComponent>()
            ))?
            .into_inner();
        component.power_le
...
```

Example 3 (unknown):
```unknown
AnimatableCurve::new(
    PowerLevelProperty,
    AnimatableKeyframeCurve::new([
        (0.0, 0.0),
        (1.0, 9001.0),
    ]).expect("Failed to create power level curve")
);
```

---

## Function uvec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.uvec4.html

**Contents:**
- Function uvec4 Copy item path

Creates a 4-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn uvec4(x: u32, y: u32, z: u32, w: u32) -> UVec4
```

---

## Trait AnimationCompatibleCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AnimationCompatibleCurve.html

**Contents:**
- Trait AnimationCompatibleCurve Copy item path
- Dyn Compatibility§
- Implementors§
  - impl<T, C> AnimationCompatibleCurve<T> for Cwhere C: Curve<T> + Debug + Clone + Reflectable,

This trait collects the additional requirements on top of Curve<T> needed for a curve to be used as an AnimationCurve.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AnimationCompatibleCurve<T>:
    Curve<T>
    + Debug
    + Clone
    + Reflectable { }
```

---

## Struct WindowResizeConstraints Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.WindowResizeConstraints.html

**Contents:**
- Struct WindowResizeConstraints Copy item path
- Fields§
- Implementations§
  - impl WindowResizeConstraints
    - pub fn check_constraints(&self) -> WindowResizeConstraints
- Trait Implementations§
  - impl Clone for WindowResizeConstraints
    - fn clone(&self) -> WindowResizeConstraints
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for WindowResizeConstraints

The size limits on a Window.

These values are measured in logical pixels (see WindowResolution), so the user’s scale factor does affect the size limits on the window.

Please note that if the window is resizable, then when the window is maximized it may have a size outside of these limits. The functionality required to disable maximizing is not yet exposed by winit.

The minimum width the window can have.

The minimum height the window can have.

The maximum width the window can have.

The maximum height the window can have.

Checks if the constraints are valid.

Will output warnings if it isn’t.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WindowResizeConstraints {
    pub min_width: f32,
    pub min_height: f32,
    pub max_width: f32,
    pub max_height: f32,
}
```

---

## Trait Function Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Function.html

**Contents:**
- Trait Function Copy item path
- §Example
- Required Methods§
    - fn name(&self) -> Option<&Cow<'static, str>>
    - fn info(&self) -> &FunctionInfo
    - fn reflect_call<'a>( &self, args: ArgList<'a>, ) -> Result<Return<'a>, FunctionError>
    - fn to_dynamic_function(&self) -> DynamicFunction<'static>
- Provided Methods§
    - fn arg_count(&self) -> ArgCount
- Implementors§

A trait used to power function-like operations via reflection.

This trait allows types to be called like regular functions with Reflect-based arguments and return values.

By default, this trait is currently only implemented for DynamicFunction, however, it is possible to implement this trait for custom function-like types.

The name of the function, if any.

For DynamicFunctions created using IntoFunction, the default name will always be the full path to the function as returned by core::any::type_name, unless the function is a closure, anonymous function, or function pointer, in which case the name will be None.

The FunctionInfo for this function.

Call this function with the given arguments.

Creates a new DynamicFunction from this function.

Returns the number of arguments the function expects.

For overloaded functions that can have a variable number of arguments, this will contain the full set of counts for all signatures.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Function: PartialReflect + Debug {
    // Required methods
    fn name(&self) -> Option<&Cow<'static, str>>;
    fn info(&self) -> &FunctionInfo;
    fn reflect_call<'a>(
        &self,
        args: ArgList<'a>,
    ) -> Result<Return<'a>, FunctionError>;
    fn to_dynamic_function(&self) -> DynamicFunction<'static>;

    // Provided method
    fn arg_count(&self) -> ArgCount { ... }
}
```

Example 2 (javascript):
```javascript
fn add(a: i32, b: i32) -> i32 {
   a + b
}

let func: Box<dyn Function> = Box::new(add.into_function());
let args = ArgList::new().with_owned(25_i32).with_owned(75_i32);
let value = func.reflect_call(args).unwrap().unwrap_owned();
assert_eq!(value.try_take::<i32>().unwrap(), 100);
```

---

## Struct DebugName Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DebugName.html

**Contents:**
- Struct DebugName Copy item path
- Implementations§
  - impl DebugName
    - pub const fn borrowed(value: &'static str) -> DebugName
    - pub fn owned(value: String) -> DebugName
    - pub fn type_name<T>() -> DebugName
    - pub fn shortname(&self) -> ShortName<'_>
    - pub fn as_string(&self) -> String
      - Examples found in repository?
- Methods from Deref<Target = str>§

Wrapper to help debugging ECS issues. This is used to display the names of systems, components, …

Create a new DebugName from a &str

The value will be ignored if the debug feature is not enabled

Create a new DebugName from a String

The value will be ignored if the debug feature is not enabled

Create a new DebugName from a type by using its core::any::type_name

The value will be ignored if the debug feature is not enabled

Get the ShortName corresponding to this debug name

The value will be a static string if the debug feature is not enabled

Return the string hold by this DebugName

This is intended for debugging purpose, and only available if the debug feature is enabled

Returns the length of self.

This length is in bytes, not chars or graphemes. In other words, it might not be what a human considers the length of the string.

Returns true if self has a length of zero bytes.

Checks that index-th byte is the first byte in a UTF-8 code point sequence or the end of the string.

The start and end of the string (when index == self.len()) are considered to be boundaries.

Returns false if index is greater than self.len().

Finds the closest x not exceeding index where is_char_boundary(x) is true.

This method can help you truncate a string so that it’s still valid UTF-8, but doesn’t exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren’t split. For example, the emoji 🧑‍🔬 (scientist) could be split so that the string only includes 🧑 (person) instead.

Finds the closest x not below index where is_char_boundary(x) is true.

If index is greater than the length of the string, this returns the length of the string.

This method is the natural complement to floor_char_boundary. See that method for more details.

Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the from_utf8 function.

Converts a string slice to a raw pointer.

As string slices are a slice of bytes, the raw pointer points to a u8. This pointer will be pointing to the first byte of the string slice.

The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use as_mut_ptr.

Returns a subslice of str.

This is the non-panicking alternative to indexing the str. Returns None whenever equivalent indexing operation would panic.

Returns an unchecked subslice of str.

This 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct DebugName { /* private fields */ }
```

Example 2 (javascript):
```javascript
99fn build_ui(
100    mut commands: Commands,
101    asset_server: Res<AssetServer>,
102    schedules: Res<Schedules>,
103    mut stepping: ResMut<Stepping>,
104    mut state: ResMut<State>,
105) {
106    let mut text_spans = Vec::new();
107    let mut always_run: Vec<(
108        bevy_ecs::intern::Interned<dyn ScheduleLabel + 'static>,
109        NodeId,
110    )> = Vec::new();
111
112    let Ok(schedule_order) = stepping.schedules() else {
113        return;
114    };
115
116    // go through the stepping schedules and construct a list of systems for
117    // each label
118    for label in 
...
```

Example 3 (javascript):
```javascript
let len = "foo".len();
assert_eq!(3, len);

assert_eq!("ƒoo".len(), 4); // fancy f!
assert_eq!("ƒoo".chars().count(), 3);
```

Example 4 (javascript):
```javascript
let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());
```

---

## Struct AnimationGraph Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationGraph.html

**Contents:**
- Struct AnimationGraph Copy item path
- Fields§
- Implementations§
  - impl AnimationGraph
    - pub fn new() -> AnimationGraph
      - Examples found in repository?
    - pub fn from_clip(clip: Handle<AnimationClip>) -> (AnimationGraph, NodeIndex)
      - Examples found in repository?
    - pub fn from_clips<'a, I>(clips: I) -> (AnimationGraph, Vec<NodeIndex>)where I: IntoIterator<Item = Handle<AnimationClip>>, <I as IntoIterator>::IntoIter: 'a,
      - Examples found in repository?

A graph structure that describes how animation clips are to be blended together.

Applications frequently want to be able to play multiple animations at once and to fine-tune the influence that animations have on a skinned mesh. Bevy uses an animation graph to store this information. Animation graphs are a directed acyclic graph (DAG) that describes how animations are to be weighted and combined together. Every frame, Bevy evaluates the graph from the root and blends the animations together in a bottom-up fashion to produce the final pose.

There are three types of nodes: blend nodes, add nodes, and clip nodes, all of which can have an associated weight. Blend nodes and add nodes have no associated animation clip and combine the animations of their children according to those children’s weights. Clip nodes specify an animation clip to play. When a graph is created, it starts with only a single blend node, the root node.

For example, consider the following graph:

In this case, assuming that Idle, Run, and Walk are all playing with weight 1.0, the Run and Walk animations will be equally blended together, then their weights will be halved and finally blended with the Idle animation. Thus the weight of Run and Walk are effectively half of the weight of Idle.

Nodes can optionally have a mask, a bitfield that restricts the set of animation targets that the node and its descendants affect. Each bit in the mask corresponds to a mask group, which is a set of animation targets (bones). An animation target can belong to any number of mask groups within the context of an animation graph.

When the appropriate bit is set in a node’s mask, neither the node nor its descendants will animate any animation targets belonging to that mask group. That is, setting a mask bit to 1 disables the animation targets in that group. If an animation target belongs to multiple mask groups, masking any one of the mask groups that it belongs to will mask that animation target. (Thus an animation target will only be animated if all of its mask groups are unmasked.)

A common use of masks is to allow characters to hold objects. For this, the typical workflow is to assign each character’s hand to a mask group. Then, when the character picks up an object, the application masks out the hand that the object is held in for the character’s animation set, then positions the hand’s digits as necessary to grasp the object. The character’s animations will continue to play but will not affect the ha

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationGraph {
    pub graph: Graph<AnimationGraphNode, ()>,
    pub root: NodeIndex,
    pub mask_groups: HashMap<AnimationTargetId, u64>,
}
```

Example 2 (text):
```text
┌────────────┐                                      
│            │                                      
│    Idle    ├─────────────────────┐                
│            │                     │                
└────────────┘                     │                
                                   │                
┌────────────┐                     │  ┌────────────┐
│            │                     │  │            │
│    Run     ├──┐                  ├──┤    Root    │
│            │  │  ┌────────────┐  │  │            │
└────────────┘  │  │   Blend    │  │  └────────────┘
                ├
...
```

Example 3 (javascript):
```javascript
151fn setup_assets_programmatically(
152    commands: &mut Commands,
153    asset_server: &mut AssetServer,
154    animation_graphs: &mut Assets<AnimationGraph>,
155    _save: bool,
156) {
157    // Create the nodes.
158    let mut animation_graph = AnimationGraph::new();
159    let blend_node = animation_graph.add_blend(0.5, animation_graph.root);
160    animation_graph.add_clip(
161        asset_server.load(GltfAssetLabel::Animation(0).from_asset("models/animated/Fox.glb")),
162        1.0,
163        animation_graph.root,
164    );
165    animation_graph.add_clip(
166        asset_server.lo
...
```

Example 4 (javascript):
```javascript
340fn setup_animation_graph_once_loaded(
341    mut commands: Commands,
342    asset_server: Res<AssetServer>,
343    mut animation_graphs: ResMut<Assets<AnimationGraph>>,
344    mut players: Query<(Entity, &mut AnimationPlayer), Added<AnimationPlayer>>,
345    targets: Query<(Entity, &AnimationTarget)>,
346) {
347    for (entity, mut player) in &mut players {
348        // Load the animation clip from the glTF file.
349        let mut animation_graph = AnimationGraph::new();
350        let blend_node = animation_graph.add_additive_blend(1.0, animation_graph.root);
351
352        let animation
...
```

---

## Struct Vec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Vec3.html

**Contents:**
- Struct Vec3 Copy item path
- Fields§
- Implementations§
  - impl Vec3
    - pub const ZERO: Vec3
    - pub const ONE: Vec3
    - pub const NEG_ONE: Vec3
    - pub const MIN: Vec3
    - pub const MAX: Vec3
    - pub const NAN: Vec3

A 3-dimensional vector.

All f32::NEG_INFINITY.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

Vec3 uses Rust Portable SIMD

Vec3 uses scalar math

Vec3 uses WebAssembly 128-bit SIMD

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z]

Creates a vector from the first 3 values in slice.

Panics if slice is less than 3 elements long.

Writes the elements of self to the first 3 elements in slice.

Panics if slice is less than 3 elements long.

Creates a 4D vector from self and the given w value.

Creates a 2D vector from the x and y elements of self, discarding z.

Truncation may also be performed by using self.xy().

Creates a 3D vector from self with the given value of x.

Creates a 3D vector from self with the given value of y.

Creates a 3D vector from self with the given value of z.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Computes the cross product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for minNum and may differ on different SIMD architectures.

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for maxNum and may differ on different SIMD architectures.

Component-wise clamping of values, similar to f32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

NaN propogation does not follow IEEE 754-2008 semantics and may differ on different SIMD architectures.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
```

Example 2 (javascript):
```javascript
47const DISTANCE_BETWEEN_SHAPES: Vec3 = Vec3::new(2.0, 0.0, 0.0);
48
49/// Maximum amount of points allowed to be present.
50/// Should be set such that it does not cause large amounts of lag when reached.
51const MAX_POINTS: usize = 3000; // TODO: Test wasm and add a wasm-specific-bound
52
53/// How many points should be spawned each frame
54const POINTS_PER_FRAME: usize = 3;
55
56/// Color used for the inside points
57const INSIDE_POINT_COLOR: LinearRgba = LinearRgba::rgb(0.855, 1.1, 0.01);
58/// Color used for the points on the boundary
59const BOUNDARY_POINT_COLOR: LinearRgba = LinearRgba:
...
```

Example 3 (javascript):
```javascript
21const BALL_STARTING_POSITION: Vec3 = Vec3::new(0.0, -50.0, 1.0);
22const BALL_DIAMETER: f32 = 30.;
23const BALL_SPEED: f32 = 400.0;
24const INITIAL_BALL_DIRECTION: Vec2 = Vec2::new(0.5, -0.5);
25
26const WALL_THICKNESS: f32 = 10.0;
27// x coordinates
28const LEFT_WALL: f32 = -450.;
29const RIGHT_WALL: f32 = 450.;
30// y coordinates
31const BOTTOM_WALL: f32 = -300.;
32const TOP_WALL: f32 = 300.;
33
34const BRICK_SIZE: Vec2 = Vec2::new(100., 30.);
35// These values are exact
36const GAP_BETWEEN_PADDLE_AND_BRICKS: f32 = 270.0;
37const GAP_BETWEEN_BRICKS: f32 = 5.0;
38// These values are lower b
...
```

Example 4 (javascript):
```javascript
153const CUBOID: Cuboid = Cuboid {
154    half_size: Vec3::new(BIG_3D, SMALL_3D, BIG_3D),
155};
156
157const CIRCLE: Circle = Circle { radius: BIG_2D };
158const SPHERE: Sphere = Sphere { radius: BIG_3D };
159
160const ELLIPSE: Ellipse = Ellipse {
161    half_size: Vec2::new(BIG_2D, SMALL_2D),
162};
163
164const TRIANGLE_2D: Triangle2d = Triangle2d {
165    vertices: [
166        Vec2::new(BIG_2D, 0.0),
167        Vec2::new(0.0, BIG_2D),
168        Vec2::new(-BIG_2D, 0.0),
169    ],
170};
171
172const TRIANGLE_3D: Triangle3d = Triangle3d {
173    vertices: [
174        Vec3::new(BIG_3D, 0.0, 0
...
```

---

## Struct Window Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Window.html

**Contents:**
- Struct Window Copy item path
- §Example
- Fields§
    - §Platform-specific
    - §Platform-specific
    - §Platform-specific
    - §Platform-specific
    - §Platform-specific
    - §Platform-specific
    - §Platform-specific

The defining Component for window entities, storing information about how it should appear and behave.

Each window corresponds to an entity, and is uniquely identified by the value of their Entity. When the Window component is added to an entity, a new window will be opened. When it is removed or the entity is despawned, the window will close.

The primary window entity (and the corresponding window) is spawned by default by WindowPlugin and is marked with the PrimaryWindow component.

This component is synchronized with winit through bevy_winit: it will reflect the current state of the window and can be modified to change this state.

Because this component is synchronized with winit, it can be used to perform OS-integrated windowing operations. For example, here’s a simple system to change the window mode:

What presentation mode to give the window.

Which fullscreen or windowing mode should be used.

Where the window should be placed.

What resolution the window should have.

Stores the title of the window.

Stores the application ID (on Wayland), WM_CLASS (on X11) or window class name (on Windows) of the window.

For details about application ID conventions, see the Desktop Entry Spec. For details about WM_CLASS, see the X11 Manual Pages. For details about Windows’s window class names, see About Window Classes.

Notes: Changing this field during runtime will have no effect for now.

How the alpha channel of textures should be handled while compositing.

The limits of the window’s logical size (found in its resolution) when resizing.

Should the window be resizable?

Note: This does not stop the program from fullscreening/setting the size programmatically.

Specifies which window control buttons should be enabled.

iOS, Android, and the Web do not have window control buttons.

On some Linux environments these values have no effect.

Should the window have decorations enabled?

(Decorations are the minimize, maximize, and close buttons on desktop apps)

iOS, Android, and the Web do not have decorations.

Should the window be transparent?

Defines whether the background of the window should be transparent.

macOS transparent works with winit out of the box, so this issue might be related to: https://github.com/gfx-rs/wgpu/issues/687. You should also set the window composite_alpha_mode to CompositeAlphaMode::PostMultiplied.

Get/set whether the window is focused.

It cannot be set unfocused after creation.

Where should the window appear relative to other

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Window {Show 39 fields
    pub present_mode: PresentMode,
    pub mode: WindowMode,
    pub position: WindowPosition,
    pub resolution: WindowResolution,
    pub title: String,
    pub name: Option<String>,
    pub composite_alpha_mode: CompositeAlphaMode,
    pub resize_constraints: WindowResizeConstraints,
    pub resizable: bool,
    pub enabled_buttons: EnabledButtons,
    pub decorations: bool,
    pub transparent: bool,
    pub focused: bool,
    pub window_level: WindowLevel,
    pub canvas: Option<String>,
    pub fit_canvas_to_parent: bool,
    pub prevent_default_event_h
...
```

Example 2 (unknown):
```unknown
fn change_window_mode(mut windows: Query<&mut Window, With<PrimaryWindow>>) {
    // Query returns one window typically.
    for mut window in windows.iter_mut() {
        window.mode =
            WindowMode::Fullscreen(MonitorSelection::Current, VideoModeSelection::Current);
    }
}
```

Example 3 (unknown):
```unknown
21fn minimize_automatically(mut window: Single<&mut Window>, frames: Res<FrameCount>) {
22    if frames.0 != 60 {
23        return;
24    }
25
26    window.set_minimized(true);
27}
```

Example 4 (javascript):
```javascript
122fn move_or_resize_windows(
123    mut windows: Query<&mut Window>,
124    action: Res<LeftClickAction>,
125    input: Res<ButtonInput<MouseButton>>,
126    dir: Res<ResizeDir>,
127) {
128    // Both `start_drag_move()` and `start_drag_resize()` must be called after a
129    // left mouse button press as done here.
130    //
131    // winit 0.30.5 may panic when initiated without a left mouse button press.
132    if input.just_pressed(MouseButton::Left) {
133        for mut window in windows.iter_mut() {
134            match *action {
135                LeftClickAction::Nothing => (),
136   
...
```

---

## Trait Traversal Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/ecs/traversal/trait.Traversal.html

**Contents:**
- Trait Traversal Copy item path
- Required Methods§
    - fn traverse(item: Self::Item<'_, '_>, data: &D) -> Option<Entity>
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl<D> Traversal<D> for ()
    - fn traverse(_: <() as QueryData>::Item<'_, '_>, _data: &D) -> Option<Entity>
  - impl<R, D> Traversal<D> for &Rwhere R: Relationship,
    - §Warning
    - fn traverse(item: <&R as QueryData>::Item<'_, '_>, _data: &D) -> Option<Entity>

A component that can point to another entity, and which can be used to define a path through the ECS.

Traversals are used to specify the direction of event propagation in EntityEvent observers. The default query is ().

Infinite loops are possible, and are not checked for. While looping can be desirable in some contexts (for example, an observer that triggers itself multiple times before stopping), following an infinite traversal loop without an eventual exit will cause your application to hang. Each implementer of Traversal is responsible for documenting possible looping behavior, and consumers of those implementations are responsible for avoiding infinite loops in their code.

Traversals may be parameterized with additional data. For example, in observer event propagation, the parameter D is the event type given in On<E>. This allows traversal to differ depending on event data.

Returns the next entity to visit.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

This provides generalized hierarchy traversal for use in event propagation.

Traversing in a loop could result in infinite loops for relationship graphs with loops.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Traversal<D>: ReadOnlyQueryData + ReleaseStateQueryDatawhere
    D: ?Sized,{
    // Required method
    fn traverse(item: Self::Item<'_, '_>, data: &D) -> Option<Entity>;
}
```

---

## Struct UnevenSampleAutoCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UnevenSampleAutoCurve.html

**Contents:**
- Struct UnevenSampleAutoCurve Copy item path
- Implementations§
  - impl<T> UnevenSampleAutoCurve<T>
    - pub fn new( timed_samples: impl IntoIterator<Item = (f32, T)>, ) -> Result<UnevenSampleAutoCurve<T>, UnevenCoreError>
      - Examples found in repository?
    - pub fn map_sample_times( self, f: impl Fn(f32) -> f32, ) -> UnevenSampleAutoCurve<T>
- Trait Implementations§
  - impl<T> Clone for UnevenSampleAutoCurve<T>where T: Clone,
    - fn clone(&self) -> UnevenSampleAutoCurve<T>
    - fn clone_from(&mut self, source: &Self)

A curve that is defined by interpolation over unevenly spaced samples, interpolated automatically using a particularly well-behaved interpolation.

Create a new UnevenSampleAutoCurve from a given set of timed samples.

The samples are filtered to finite times and sorted internally; if there are not at least 2 valid timed samples, an error will be returned.

This UnevenSampleAutoCurve, but with the sample times moved by the map f. In principle, when f is monotone, this is equivalent to CurveExt::reparametrize, but the function inputs to each are inverses of one another.

The samples are re-sorted by time after mapping and deduplicated by output time, so the function f should generally be injective over the sample times of the curve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UnevenSampleAutoCurve<T> { /* private fields */ }
```

Example 2 (javascript):
```javascript
22fn setup(
23    mut commands: Commands,
24    mut meshes: ResMut<Assets<Mesh>>,
25    mut materials: ResMut<Assets<StandardMaterial>>,
26    mut animations: ResMut<Assets<AnimationClip>>,
27    mut graphs: ResMut<Assets<AnimationGraph>>,
28) {
29    // Camera
30    commands.spawn((
31        Camera3d::default(),
32        Transform::from_xyz(-2.0, 2.5, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
33    ));
34
35    // Light
36    commands.spawn((
37        PointLight {
38            intensity: 500_000.0,
39            ..default()
40        },
41        Transform::from_xyz(0.0, 2.5, 0.0),
42    ));

...
```

---

## Struct DragStart Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragStart.html

**Contents:**
- Struct DragStart Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragStart
    - fn clone(&self) -> DragStart
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragStart
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragStart
    - type This<'from_arg> = DragStart

Fires when the target entity receives a pointer pressed event followed by a pointer move event.

Pointer button pressed and moved to trigger this event.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragStart {
    pub button: PointerButton,
    pub hit: HitData,
}
```

---

## Struct SpritePickingCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpritePickingCamera.html

**Contents:**
- Struct SpritePickingCamera Copy item path
- Trait Implementations§
  - impl Clone for SpritePickingCamera
    - fn clone(&self) -> SpritePickingCamera
    - fn clone_from(&mut self, source: &Self)
  - impl Component for SpritePickingCamerawhere SpritePickingCamera: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

An optional component that marks cameras that should be used in the SpritePickingPlugin.

Only needed if SpritePickingSettings::require_markers is set to true, and ignored otherwise.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpritePickingCamera;
```

---

## Struct AnimationSystems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.AnimationSystems.html

**Contents:**
- Struct AnimationSystems Copy item path
- Trait Implementations§
  - impl Clone for AnimationSystems
    - fn clone(&self) -> AnimationSystems
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for AnimationSystems
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Hash for AnimationSystems
    - fn hash<__H>(&self, state: &mut __H)where __H: Hasher,
    - fn hash_slice<H>(data: &[Self], state: &mut H)where H: Hasher, Self: Sized,

Animation system set. This exists in PostUpdate.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationSystems;
```

---

## Trait GetTupleStructField Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.GetTupleStructField.html

**Contents:**
- Trait GetTupleStructField Copy item path
- §Example
- Required Methods§
    - fn get_field<T>(&self, index: usize) -> Option<&T>where T: Reflect,
    - fn get_field_mut<T>(&mut self, index: usize) -> Option<&mut T>where T: Reflect,
- Dyn Compatibility§
- Implementors§
  - impl GetTupleStructField for dyn TupleStruct
  - impl<S> GetTupleStructField for Swhere S: TupleStruct,

A convenience trait which combines fetching and downcasting of tuple struct fields.

Returns a reference to the value of the field with index index, downcast to T.

Returns a mutable reference to the value of the field with index index, downcast to T.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait GetTupleStructField {
    // Required methods
    fn get_field<T>(&self, index: usize) -> Option<&T>
       where T: Reflect;
    fn get_field_mut<T>(&mut self, index: usize) -> Option<&mut T>
       where T: Reflect;
}
```

Example 2 (javascript):
```javascript
use bevy_reflect::{GetTupleStructField, Reflect};

#[derive(Reflect)]
struct Foo(String);

let mut foo = Foo("Hello, world!".to_string());

foo.get_field_mut::<String>(0).unwrap().truncate(5);
assert_eq!(foo.get_field::<String>(0), Some(&"Hello".to_string()));
```

---

## Function bvec4a Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.bvec4a.html

**Contents:**
- Function bvec4a Copy item path

Creates a 4-dimensional bool vector mask.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn bvec4a(x: bool, y: bool, z: bool, w: bool) -> BVec4A
```

---

## Derive Macro Component Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Component.html

**Contents:**
- Derive Macro Component Copy item path
  - §Immutability
  - §Sparse instead of table-based storage
  - §Required Components
  - §Relationships
  - §Hooks
  - §Ignore this component when cloning an entity

Cheat sheet for derive syntax, see full explanation and examples on the Component trait doc.

On despawn, also despawn all related entities:

where hook_name is on_add, on_insert, on_replace or on_remove; function can be either a path, e.g. some_function::<Self>, or a function call that returns a function that can be turned into a ComponentHook, e.g. get_closure("Hi!").

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Component)]
{
    // Attributes available to this derive:
    #[component]
    #[require]
    #[relationship]
    #[relationship_target]
    #[entities]
}
```

Example 2 (unknown):
```unknown
#[derive(Component)]
#[component(immutable)]
struct MyComponent;
```

Example 3 (unknown):
```unknown
#[derive(Component)]
#[component(storage = "SparseSet")]
struct MyComponent;
```

Example 4 (unknown):
```unknown
#[derive(Component)]
#[require(
    // `Default::default()`
    A,
    // tuple structs
    B(1),
    // named-field structs
    C {
        x: 1,
        ..default()
    },
    // unit structs/variants
    D::One,
    // associated consts
    E::ONE,
    // constructors
    F::new(1),
    // arbitrary expressions
    G = make(1, 2, 3)
)]
struct MyComponent;
```

---

## Type Alias SystemIn Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.SystemIn.html

**Contents:**
- Type Alias SystemIn Copy item path

Shorthand way to get the System::In for a System as a SystemInput::Inner.

**Examples:**

Example 1 (unknown):
```unknown
pub type SystemIn<'a, S> = <<S as System>::In as SystemInput>::Inner<'a>;
```

---

## Struct Sprite Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Sprite.html

**Contents:**
- Struct Sprite Copy item path
- Fields§
- Implementations§
  - impl Sprite
    - pub fn sized(custom_size: Vec2) -> Sprite
      - Examples found in repository?
    - pub fn from_image(image: Handle<Image>) -> Sprite
      - Examples found in repository?
    - pub fn from_atlas_image(image: Handle<Image>, atlas: TextureAtlas) -> Sprite
      - Examples found in repository?

Describes a sprite to be rendered to a 2D camera

The image used to render the sprite

The (optional) texture atlas used to render the sprite

The sprite’s color tint

Flip the sprite along the X axis

Flip the sprite along the Y axis

An optional custom size for the sprite that will be used when rendering, instead of the size of the sprite’s image

An optional rectangle representing the region of the sprite’s image to render, instead of rendering the full image. This is an easy one-off alternative to using a TextureAtlas.

When used with a TextureAtlas, the rect is offset by the atlas’s minimal (top-left) corner position.

How the sprite’s image will be scaled.

Create a Sprite with a custom size

Create a sprite from an image

Create a sprite from an image, with an associated texture atlas

Create a sprite from a solid color

Computes the pixel point where point_relative_to_sprite is sampled from in this sprite. point_relative_to_sprite must be in the sprite’s local frame. Returns an Ok if the point is inside the bounds of the sprite (not just the image), and returns an Err otherwise.

Required Components: Transform, Visibility, VisibilityClass, Anchor.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Sprite {
    pub image: Handle<Image>,
    pub texture_atlas: Option<TextureAtlas>,
    pub color: Color,
    pub flip_x: bool,
    pub flip_y: bool,
    pub custom_size: Option<Vec2>,
    pub rect: Option<Rect>,
    pub image_mode: SpriteImageMode,
}
```

Example 2 (unknown):
```unknown
73fn spawn_curve_sprite<T: CurveColor>(commands: &mut Commands, y: f32, points: [T; 4]) {
74    commands.spawn((
75        Sprite::sized(Vec2::new(75., 75.)),
76        Transform::from_xyz(0., y, 0.),
77        Curve(CubicBezier::new([points]).to_curve().unwrap()),
78    ));
79}
80
81fn spawn_mixed_sprite<T: MixedColor>(commands: &mut Commands, y: f32, colors: [T; 4]) {
82    commands.spawn((
83        Transform::from_xyz(0., y, 0.),
84        Sprite::sized(Vec2::new(75., 75.)),
85        Mixed(colors),
86    ));
87}
```

Example 3 (unknown):
```unknown
116fn setup_game(mut commands: Commands, asset_server: Res<AssetServer>) {
117    commands.spawn(Sprite::from_image(asset_server.load("branding/icon.png")));
118}
```

Example 4 (unknown):
```unknown
194    pub fn setup_game(mut commands: Commands, asset_server: Res<AssetServer>) {
195        commands.spawn(Sprite::from_image(asset_server.load("branding/icon.png")));
196    }
```

---

## Struct SpatialListener Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpatialListener.html

**Contents:**
- Struct SpatialListener Copy item path
- Fields§
- Implementations§
  - impl SpatialListener
    - pub fn new(gap: f32) -> SpatialListener
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for SpatialListener
    - fn clone(&self) -> SpatialListener
    - fn clone_from(&mut self, source: &Self)

Settings for the listener for spatial audio sources.

This is accompanied by Transform and GlobalTransform. Only one entity with a SpatialListener should be present at any given time.

Left ear position relative to the GlobalTransform.

Right ear position relative to the GlobalTransform.

Creates a new SpatialListener component.

gap is the distance between the left and right “ears” of the listener. Ears are positioned on the x axis.

Required Components: Transform.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpatialListener {
    pub left_ear_offset: Vec3,
    pub right_ear_offset: Vec3,
}
```

Example 2 (javascript):
```javascript
26fn setup(
27    mut commands: Commands,
28    mut meshes: ResMut<Assets<Mesh>>,
29    mut materials: ResMut<Assets<ColorMaterial>>,
30    asset_server: Res<AssetServer>,
31) {
32    // Space between the two ears
33    let gap = 400.0;
34
35    // sound emitter
36    commands.spawn((
37        Mesh2d(meshes.add(Circle::new(15.0))),
38        MeshMaterial2d(materials.add(Color::from(BLUE))),
39        Transform::from_translation(Vec3::new(0.0, 50.0, 0.0)),
40        Emitter::default(),
41        AudioPlayer::new(asset_server.load("sounds/Windless Slopes.ogg")),
42        PlaybackSettings::LOOP
...
```

Example 3 (javascript):
```javascript
18fn setup(
19    mut commands: Commands,
20    asset_server: Res<AssetServer>,
21    mut meshes: ResMut<Assets<Mesh>>,
22    mut materials: ResMut<Assets<StandardMaterial>>,
23) {
24    // Space between the two ears
25    let gap = 4.0;
26
27    // sound emitter
28    commands.spawn((
29        Mesh3d(meshes.add(Sphere::new(0.2).mesh().uv(32, 18))),
30        MeshMaterial3d(materials.add(Color::from(BLUE))),
31        Transform::from_xyz(0.0, 0.0, 0.0),
32        Emitter::default(),
33        AudioPlayer::new(asset_server.load("sounds/Windless Slopes.ogg")),
34        PlaybackSettings::LOOP.w
...
```

---

## Enum Handle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Handle.html

**Contents:**
- Enum Handle Copy item path
- Variants§
  - Strong(Arc<StrongHandle>)
  - Uuid(Uuid, PhantomData<fn() -> A>)
- Implementations§
  - impl<A> Handle<A>where A: Asset,
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool

A handle to a specific Asset of type A. Handles act as abstract “references” to assets, whose data are stored in the Assets<A> resource, avoiding the need to store multiple copies of the same data.

If a Handle is Handle::Strong, the Asset will be kept alive until the Handle is dropped. If a Handle is Handle::Uuid, it does not necessarily reference a live Asset, nor will it keep assets alive.

Modifying a handle will change which existing asset is referenced, but modifying the asset (by mutating the Assets resource) will change the asset for all handles referencing it.

Handle can be cloned. If a Handle::Strong is cloned, the referenced Asset will not be freed until all instances of the Handle are dropped.

Handle::Strong, via StrongHandle also provides access to useful Asset metadata, such as the AssetPath (if it exists).

A “strong” reference to a live (or loading) Asset. If a Handle is Handle::Strong, the Asset will be kept alive until the Handle is dropped. Strong handles also provide access to additional asset metadata.

A reference to an Asset using a stable-across-runs / const identifier. Dropping this handle will not result in the asset being dropped.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Converts this Handle to an “untyped” / “generic-less” UntypedHandle, which stores the Asset type information inside UntypedHandle. This will return UntypedHandle::Strong for Handle::Strong and UntypedHandle::Uuid for Handle::Uuid.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Handle<A>where
    A: Asset,{
    Strong(Arc<StrongHandle>),
    Uuid(Uuid, PhantomData<fn() -> A>),
}
```

Example 2 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 3 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

Example 4 (javascript):
```javascript
169fn print_counts(
170    time: Res<Time>,
171    mut timer: Local<PrintingTimer>,
172    texts: Query<&ViewVisibility, With<Text2d>>,
173    atlases: Res<FontAtlasSets>,
174    font: Res<FontHandle>,
175) {
176    timer.tick(time.delta());
177    if !timer.just_finished() {
178        return;
179    }
180
181    let num_atlases = atlases
182        .get(font.0.id())
183        .map(|set| set.iter().map(|atlas| atlas.1.len()).sum())
184        .unwrap_or(0);
185
186    let visible_texts = texts.iter().filter(|visibility| visibility.get()).count();
187
188    info!(
189        "Texts: {} Visib
...
```

---

## Trait Asset Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Asset.html

**Contents:**
- Trait Asset Copy item path
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl Asset for ()
- Implementors§
  - impl Asset for LoadedFolder
  - impl Asset for LoadedUntypedAsset
  - impl Asset for FrametimeGraphMaterial
  - impl Asset for GltfMesh
  - impl Asset for GltfNode

Declares that this type is an asset, which can be loaded and managed by the AssetServer and stored in Assets collections.

Generally, assets are large, complex, and/or expensive to load from disk, and are often authored by artists or designers.

TypePath is largely used for diagnostic purposes, and should almost always be implemented by deriving Reflect on your type. VisitAssetDependencies is used to track asset dependencies, and an implementation is automatically generated when deriving Asset.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Asset:
    VisitAssetDependencies
    + TypePath
    + Send
    + Sync
    + 'static { }
```

---

## Trait GizmoPrimitive3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.GizmoPrimitive3d.html

**Contents:**
- Trait GizmoPrimitive3d Copy item path
- Required Associated Types§
    - type Output<'a> where Self: 'a
- Required Methods§
    - fn primitive_3d( &mut self, primitive: &P, isometry: impl Into<Isometry3d>, color: impl Into<Color>, ) -> Self::Output<'_>
- Dyn Compatibility§
- Implementors§
  - impl<Config, Clear> GizmoPrimitive3d<Capsule3d> for GizmoBuffer<Config, Clear>where Config: GizmoConfigGroup, Clear: 'static + Send + Sync,
    - type Output<'a> = Capsule3dBuilder<'a, Config, Clear> where GizmoBuffer<Config, Clear>: 'a
  - impl<Config, Clear> GizmoPrimitive3d<Cone> for GizmoBuffer<Config, Clear>where Config: GizmoConfigGroup, Clear: 'static + Send + Sync,

A trait for rendering 3D geometric primitives (P) with GizmoBuffer.

The output of primitive_3d. This is a builder to set non-default values.

Renders a 3D primitive with its associated details.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait GizmoPrimitive3d<P>where
    P: Primitive3d,{
    type Output<'a>
       where Self: 'a;

    // Required method
    fn primitive_3d(
        &mut self,
        primitive: &P,
        isometry: impl Into<Isometry3d>,
        color: impl Into<Color>,
    ) -> Self::Output<'_>;
}
```

---

## Struct ReflectSerialize Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectSerialize.html

**Contents:**
- Struct ReflectSerialize Copy item path
- Implementations§
  - impl ReflectSerialize
    - pub fn get_serializable<'a>( &self, value: &'a (dyn Reflect + 'static), ) -> Serializable<'a>
- Trait Implementations§
  - impl Clone for ReflectSerialize
    - fn clone(&self) -> ReflectSerialize
    - fn clone_from(&mut self, source: &Self)
  - impl<T> FromType<T> for ReflectSerializewhere T: TypePath + FromReflect + Serialize,
    - fn from_type() -> ReflectSerialize

A struct used to serialize reflected instances of a type.

A ReflectSerialize for type T can be obtained via FromType::from_type.

Turn the value into a serializable representation

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectSerialize { /* private fields */ }
```

---

## Struct ZipCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ZipCurve.html

**Contents:**
- Struct ZipCurve Copy item path
- Trait Implementations§
  - impl<S, T, C, D> Clone for ZipCurve<S, T, C, D>where S: Clone, T: Clone, C: Clone, D: Clone,
    - fn clone(&self) -> ZipCurve<S, T, C, D>
    - fn clone_from(&mut self, source: &Self)
  - impl<S, T, C, D> Curve<(S, T)> for ZipCurve<S, T, C, D>where C: Curve<S>, D: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> (S, T)
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

A curve that combines the output data from two constituent curves into a tuple output. Curves of this type are produced by CurveExt::zip.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ZipCurve<S, T, C, D> { /* private fields */ }
```

---

## Struct Line3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Line3d.html

**Contents:**
- Struct Line3d Copy item path
- Fields§
- Trait Implementations§
  - impl Bounded3d for Line3d
    - fn aabb_3d(&self, isometry: impl Into<Isometry3d>) -> Aabb3d
    - fn bounding_sphere(&self, isometry: impl Into<Isometry3d>) -> BoundingSphere
  - impl Clone for Line3d
    - fn clone(&self) -> Line3d
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Line3d

An infinite line going through the origin along a direction in 3D space.

For a finite line: Segment3d

The direction of the line

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Line3d {
    pub direction: Dir3,
}
```

---

## Struct DespawnOnExit Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DespawnOnExit.html

**Contents:**
- Struct DespawnOnExit Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<S> Clone for DespawnOnExit<S>where S: Clone + States,
    - fn clone(&self) -> DespawnOnExit<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Component for DespawnOnExit<S>where S: States, DespawnOnExit<S>: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Entities marked with this component will be removed when the world’s state of the matching type no longer matches the supplied value.

If you need to disable this behavior, add the attribute #[states(scoped_entities = false)] when deriving States.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DespawnOnExit<S>(pub S)
where
    S: States;
```

Example 2 (unknown):
```unknown
use bevy_state::prelude::*;
use bevy_ecs::prelude::*;
use bevy_ecs::system::ScheduleSystem;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Default, States)]
enum GameState {
    #[default]
    MainMenu,
    SettingsMenu,
    InGame,
}


fn spawn_player(mut commands: Commands) {
    commands.spawn((
        DespawnOnExit(GameState::InGame),
        Player
    ));
}


app.init_state::<GameState>();
app.add_systems(OnEnter(GameState::InGame), spawn_player);
```

---

## Function update_reparented Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/fn.update_reparented.html

**Contents:**
- Function update_reparented Copy item path

add/remove Inherited::<C> and C for entities which have changed relationship

**Examples:**

Example 1 (unknown):
```unknown
pub fn update_reparented<C, F, R>(
    commands: Commands<'_, '_>,
    moved: Query<'_, '_, (Entity, &R, Option<&Inherited<C>>), (Changed<R>, Without<Propagate<C>>, Without<PropagateStop<C>>, F)>,
    relations: Query<'_, '_, &Inherited<C>>,
    orphaned: Query<'_, '_, Entity, (With<Inherited<C>>, Without<Propagate<C>>, Without<R>, F)>,
)where
    C: Component + Clone + PartialEq,
    F: QueryFilter,
    R: Relationship,
```

---

## Enum GamepadButton Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GamepadButton.html

**Contents:**
- Enum GamepadButton Copy item path
  - §Usage
- Variants§
  - South
  - East
  - North
  - West
  - C
  - Z
  - LeftTrigger

Represents gamepad input types that are mapped in the range [0.0, 1.0].

This is used to determine which button has changed its value when receiving gamepad button events. It is also used in the Gamepad component.

The bottom action button of the action pad (i.e. PS: Cross, Xbox: A).

The right action button of the action pad (i.e. PS: Circle, Xbox: B).

The upper action button of the action pad (i.e. PS: Triangle, Xbox: Y).

The left action button of the action pad (i.e. PS: Square, Xbox: X).

The first left trigger.

The second left trigger.

The first right trigger.

The second right trigger.

The left thumb stick button.

The right thumb stick button.

The up button of the D-Pad.

The down button of the D-Pad.

The left button of the D-Pad.

The right button of the D-Pad.

Miscellaneous buttons, considered non-standard (i.e. Extra buttons on a flight stick that do not have a gamepad equivalent).

Returns an array of all the standard GamepadButton.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GamepadButton {
Show 20 variants    South,
    East,
    North,
    West,
    C,
    Z,
    LeftTrigger,
    LeftTrigger2,
    RightTrigger,
    RightTrigger2,
    Select,
    Start,
    Mode,
    LeftThumb,
    RightThumb,
    DPadUp,
    DPadDown,
    DPadLeft,
    DPadRight,
    Other(u8),
}
```

---

## Struct UiPickingPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiPickingPlugin.html

**Contents:**
- Struct UiPickingPlugin Copy item path
- Trait Implementations§
  - impl Clone for UiPickingPlugin
    - fn clone(&self) -> UiPickingPlugin
    - fn clone_from(&mut self, source: &Self)
  - impl Plugin for UiPickingPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

A plugin that adds picking support for UI nodes.

This is included by default in UiPlugin.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiPickingPlugin;
```

---

## Struct AnimationPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationPlugin.html

**Contents:**
- Struct AnimationPlugin Copy item path
- Trait Implementations§
  - impl Default for AnimationPlugin
    - fn default() -> AnimationPlugin
  - impl Plugin for AnimationPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

Adds animation support to an app

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationPlugin;
```

---

## Struct SpawnIter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpawnIter.html

**Contents:**
- Struct SpawnIter Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<R, I, B> SpawnableList<R> for SpawnIter<I>where R: Relationship, I: Iterator<Item = B> + Send + Sync + 'static, B: Bundle,
    - fn spawn(this: MovingPtr<'_, SpawnIter<I>>, world: &mut World, entity: Entity)
    - fn size_hint(&self) -> usize
- Auto Trait Implementations§
  - impl<I> Freeze for SpawnIter<I>where I: Freeze,
  - impl<I> RefUnwindSafe for SpawnIter<I>where I: RefUnwindSafe,
  - impl<I> Send for SpawnIter<I>where I: Send,

A SpawnableList that spawns entities using an iterator of a given Bundle:

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpawnIter<I>(pub I);
```

Example 2 (javascript):
```javascript
let mut world = World::new();
world.spawn((
    Name::new("Root"),
    Children::spawn((
        Spawn(Name::new("Child1")),
        SpawnIter(["Child2", "Child3"].into_iter().map(Name::new)),
    )),
));
```

---

## Struct TextureAtlasSources Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextureAtlasSources.html

**Contents:**
- Struct TextureAtlasSources Copy item path
- Fields§
- Implementations§
  - impl TextureAtlasSources
    - pub fn texture_index(&self, texture: impl Into<AssetId<Image>>) -> Option<usize>
    - pub fn handle( &self, layout: Handle<TextureAtlasLayout>, texture: impl Into<AssetId<Image>>, ) -> Option<TextureAtlas>
      - Examples found in repository?
    - pub fn texture_rect( &self, layout: &TextureAtlasLayout, texture: impl Into<AssetId<Image>>, ) -> Option<URect>
    - pub fn uv_rect( &self, layout: &TextureAtlasLayout, texture: impl Into<AssetId<Image>>, ) -> Option<Rect>
- Trait Implementations§

Stores a mapping from sub texture handles to the related area index.

Generated by TextureAtlasBuilder.

Maps from a specific image handle to the index in textures where they can be found.

Retrieves the texture section index of the given texture handle.

Creates a TextureAtlas handle for the given texture handle.

Retrieves the texture section rectangle of the given texture handle in pixels.

Retrieves the texture section rectangle of the given texture handle in UV coordinates. These are within the range [0..1], as a fraction of the entire texture atlas’ size.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureAtlasSources {
    pub texture_ids: HashMap<AssetId<Image>, usize>,
}
```

Example 2 (unknown):
```unknown
251fn create_sprite_from_atlas(
252    commands: &mut Commands,
253    translation: (f32, f32, f32),
254    atlas_texture: Handle<Image>,
255    atlas_sources: TextureAtlasSources,
256    atlas_handle: Handle<TextureAtlasLayout>,
257    vendor_handle: &Handle<Image>,
258) {
259    commands.spawn((
260        Transform {
261            translation: Vec3::new(translation.0, translation.1, translation.2),
262            scale: Vec3::splat(3.0),
263            ..default()
264        },
265        Sprite::from_atlas_image(
266            atlas_texture,
267            atlas_sources.handle(atlas_hand
...
```

---

## Struct MeshMaterial3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshMaterial3d.html

**Contents:**
- Struct MeshMaterial3d Copy item path
- §Example
- Tuple Fields§
- Methods from Deref<Target = Handle<M>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§

A material used for rendering a Mesh3d.

See Material for general information about 3D materials and how to implement your own materials.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshMaterial3d<M>(pub Handle<M>)
where
    M: Material;
```

Example 2 (unknown):
```unknown
// Spawn an entity with a mesh using `StandardMaterial`.
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    commands.spawn((
        Mesh3d(meshes.add(Capsule3d::default())),
        MeshMaterial3d(materials.add(StandardMaterial {
            base_color: RED.into(),
            ..Default::default()
        })),
    ));
}
```

Example 3 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 4 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

---

## Struct Arc2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Arc2d.html

**Contents:**
- Struct Arc2d Copy item path
- Fields§
- Implementations§
  - impl Arc2d
    - pub const fn new(radius: f32, half_angle: f32) -> Arc2d
    - pub const fn from_radians(radius: f32, angle: f32) -> Arc2d
    - pub const fn from_degrees(radius: f32, angle: f32) -> Arc2d
    - pub const fn from_turns(radius: f32, fraction: f32) -> Arc2d
    - pub const fn angle(&self) -> f32
    - pub const fn length(&self) -> f32

A primitive representing an arc between two points on a circle.

An arc has no area. If you want to include the portion of a circle’s area swept out by the arc, use the pie-shaped CircularSector. If you want to include only the space inside the convex hull of the arc, use the bowl-shaped CircularSegment.

The arc is drawn starting from Vec2::Y, extending by half_angle radians on either side. The center of the circle is the origin Vec2::ZERO. Note that this means that the origin may not be within the Arc2d’s convex hull.

Warning: Arcs with negative angle or radius, or with angle greater than an entire circle, are not officially supported. It is recommended to normalize arcs to have an angle in [0, 2π].

The radius of the circle

Half the angle defining the arc

Create a new Arc2d from a radius and a half_angle

Create a new Arc2d from a radius and an angle in radians

Create a new Arc2d from a radius and an angle in degrees.

Create a new Arc2d from a radius and a fraction of a single turn.

For instance, 0.5 turns is a semicircle.

Get the angle of the arc

Get the length of the arc

Get the right-hand end point of the arc

Get the left-hand end point of the arc

Get the endpoints of the arc

Get the midpoint of the arc

Get half the distance between the endpoints (half the length of the chord)

Get the distance between the endpoints (the length of the chord)

Get the midpoint of the two endpoints (the midpoint of the chord)

Get the length of the apothem of this arc, that is, the distance from the center of the circle to the midpoint of the chord, in the direction of the midpoint of the arc. Equivalently, the radius minus the sagitta.

Note that for a major arc, the apothem will be negative.

Get the length of the sagitta of this arc, that is, the length of the line between the midpoints of the arc and its chord. Equivalently, the height of the triangle whose base is the chord and whose apex is the midpoint of the arc.

The sagitta is also the sum of the radius and the apothem.

Produces true if the arc is at most half a circle.

Note: This is not the negation of is_major: an exact semicircle is both major and minor.

Produces true if the arc is at least half a circle.

Note: This is not the negation of is_minor: an exact semicircle is both major and minor.

Returns the default Arc2d with radius 0.5, covering one third of a circle

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of F

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Arc2d {
    pub radius: f32,
    pub half_angle: f32,
}
```

---

## Struct GizmoLineConfig Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GizmoLineConfig.html

**Contents:**
- Struct GizmoLineConfig Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for GizmoLineConfig
    - fn clone(&self) -> GizmoLineConfig
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for GizmoLineConfig
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for GizmoLineConfig
    - fn default() -> GizmoLineConfig

A struct that stores configuration for gizmos.

Line width specified in pixels.

If perspective is true then this is the size in pixels at the camera’s near plane.

Apply perspective to gizmo lines.

This setting only affects 3D, non-orthographic cameras.

Determine the style of gizmo lines.

Describe how lines should join.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GizmoLineConfig {
    pub width: f32,
    pub perspective: bool,
    pub style: GizmoLineStyle,
    pub joints: GizmoLineJoint,
}
```

---

## Trait PartialReflect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.PartialReflect.html

**Contents:**
- Trait PartialReflect Copy item path
- Required Methods§
    - fn get_represented_type_info(&self) -> Option<&'static TypeInfo>
    - fn into_partial_reflect(self: Box<Self>) -> Box<dyn PartialReflect>
    - fn as_partial_reflect(&self) -> &(dyn PartialReflect + 'static)
    - fn as_partial_reflect_mut(&mut self) -> &mut (dyn PartialReflect + 'static)
    - fn try_into_reflect( self: Box<Self>, ) -> Result<Box<dyn Reflect>, Box<dyn PartialReflect>>
    - fn try_as_reflect(&self) -> Option<&(dyn Reflect + 'static)>
    - fn try_as_reflect_mut(&mut self) -> Option<&mut (dyn Reflect + 'static)>
    - fn try_apply( &mut self, value: &(dyn PartialReflect + 'static), ) -> Result<(), ApplyError>

The foundational trait of bevy_reflect, used for accessing and modifying data dynamically.

This is a supertrait of Reflect, meaning any type which implements Reflect implements PartialReflect by definition.

It’s recommended to use the derive macro for Reflect rather than manually implementing this trait. Doing so will automatically implement this trait as well as many other useful traits for reflection, including one of the appropriate subtraits: Struct, TupleStruct or Enum.

See the crate-level documentation to see how this trait and its subtraits can be used.

Returns the TypeInfo of the type represented by this value.

For most types, this will simply return their own TypeInfo. However, for dynamic types, such as DynamicStruct or DynamicList, this will return the type they represent (or None if they don’t represent any particular type).

This method is great if you have an instance of a type or a dyn Reflect, and want to access its TypeInfo. However, if this method is to be called frequently, consider using TypeRegistry::get_type_info as it can be more performant for such use cases.

Casts this type to a boxed, reflected value.

This is useful for coercing trait objects.

Casts this type to a reflected value.

This is useful for coercing trait objects.

Casts this type to a mutable, reflected value.

This is useful for coercing trait objects.

Attempts to cast this type to a boxed, fully-reflected value.

Attempts to cast this type to a fully-reflected value.

Attempts to cast this type to a mutable, fully-reflected value.

Tries to apply a reflected value to this value.

Functions the same as the apply function but returns an error instead of panicking.

This function may leave self in a partially mutated state if a error was encountered on the way. consider maintaining a cloned instance of this data you can switch to if a error is encountered.

Returns an immutable enumeration of “kinds” of type.

Returns a mutable enumeration of “kinds” of type.

Returns an owned enumeration of “kinds” of type.

Applies a reflected value to this value.

If Self implements a reflection subtrait, then the semantics of this method are as follows:

Note that Reflect must be implemented manually for Lists, Maps, and Sets in order to achieve the correct semantics, as derived implementations will have the semantics for Struct, TupleStruct, Enum or none of the above depending on the kind of type. For lists, maps, and sets, use the list_apply, map_apply, and set_apply helpe

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait PartialReflect:
    DynamicTypePath
    + Send
    + Sync
    + 'static {
Show 20 methods    // Required methods
    fn get_represented_type_info(&self) -> Option<&'static TypeInfo>;
    fn into_partial_reflect(self: Box<Self>) -> Box<dyn PartialReflect>;
    fn as_partial_reflect(&self) -> &(dyn PartialReflect + 'static);
    fn as_partial_reflect_mut(&mut self) -> &mut (dyn PartialReflect + 'static);
    fn try_into_reflect(
        self: Box<Self>,
    ) -> Result<Box<dyn Reflect>, Box<dyn PartialReflect>>;
    fn try_as_reflect(&self) -> Option<&(dyn Reflect + 'static)>;
    fn t
...
```

Example 2 (javascript):
```javascript
54fn setup(type_registry: Res<AppTypeRegistry>) {
55    let mut value = Foo {
56        a: 1,
57        _ignored: NonReflectedValue { _a: 10 },
58        nested: Bar { b: 8 },
59    };
60
61    // You can set field values like this. The type must match exactly or this will fail.
62    *value.get_field_mut("a").unwrap() = 2usize;
63    assert_eq!(value.a, 2);
64    assert_eq!(*value.get_field::<usize>("a").unwrap(), 2);
65
66    // You can also get the `&dyn PartialReflect` value of a field like this
67    let field = value.field("a").unwrap();
68
69    // But values introspected via `PartialRe
...
```

Example 3 (javascript):
```javascript
67fn setup() {
68    let mut z = <HashMap<_, _>>::default();
69    z.insert("Hello".to_string(), 1.0);
70    let value: Box<dyn Reflect> = Box::new(A {
71        x: 1,
72        y: vec![1, 2],
73        z,
74    });
75
76    // There are a number of different "reflect traits", which each expose different operations on
77    // the underlying type
78    match value.reflect_ref() {
79        // `Struct` is a trait automatically implemented for structs that derive Reflect. This trait
80        // allows you to interact with fields via their string names or indices
81        ReflectRef::Struct(val
...
```

Example 4 (javascript):
```javascript
12fn main() {
13    #[derive(Reflect, Default, PartialEq, Debug)]
14    #[reflect(Identifiable, Default)]
15    struct Player {
16        id: u32,
17    }
18
19    #[reflect_trait]
20    trait Identifiable {
21        fn id(&self) -> u32;
22    }
23
24    impl Identifiable for Player {
25        fn id(&self) -> u32 {
26            self.id
27        }
28    }
29
30    // Normally, when instantiating a type, you get back exactly that type.
31    // This is because the type is known at compile time.
32    // We call this the "concrete" or "canonical" type.
33    let player: Player = Player { id: 
...
```

---

## Enum TextError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.TextError.html

**Contents:**
- Enum TextError Copy item path
- Variants§
  - NoSuchFont
  - FailedToAddGlyph(u16)
  - FailedToGetGlyphImage(CacheKey)
- Trait Implementations§
  - impl Debug for TextError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for TextError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>

Errors related to the textsystem

Font was not found, this could be that the font has not yet been loaded, or that the font failed to load for some other reason

Failed to add glyph to a newly created atlas for some reason

Failed to get scaled glyph image for cache key

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum TextError {
    NoSuchFont,
    FailedToAddGlyph(u16),
    FailedToGetGlyphImage(CacheKey),
}
```

---

## Struct ForeverCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ForeverCurve.html

**Contents:**
- Struct ForeverCurve Copy item path
- §Notes
- §Domain
- Trait Implementations§
  - impl<T, C> Clone for ForeverCurve<T, C>where T: Clone, C: Clone,
    - fn clone(&self) -> ForeverCurve<T, C>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C> Curve<T> for ForeverCurve<T, C>where C: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T

The curve that results from repeating a curve forever.

Curves of this type are produced by CurveExt::forever.

The original curve’s domain must be bounded to get a valid ForeverCurve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ForeverCurve<T, C> { /* private fields */ }
```

---

## Struct IRect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.IRect.html

**Contents:**
- Struct IRect Copy item path
- Fields§
- Implementations§
  - impl IRect
    - pub const EMPTY: IRect
    - pub fn new(x0: i32, y0: i32, x1: i32, y1: i32) -> IRect
      - §Examples
    - pub fn from_corners(p0: IVec2, p1: IVec2) -> IRect
      - §Examples
    - pub fn from_center_size(origin: IVec2, size: IVec2) -> IRect

A rectangle defined by two opposite corners.

The rectangle is axis aligned, and defined by its minimum and maximum coordinates, stored in IRect::min and IRect::max, respectively. The minimum/maximum invariant must be upheld by the user when directly assigning the fields, otherwise some methods produce invalid results. It is generally recommended to use one of the constructor methods instead, which will ensure this invariant is met, unless you already have the minimum and maximum corners.

The minimum corner point of the rect.

The maximum corner point of the rect.

An empty IRect, represented by maximum and minimum corner points with max == IVec2::MIN and min == IVec2::MAX, so the rect has an extremely large negative size. This is useful, because when taking a union B of a non-empty IRect A and this empty IRect, B will simply equal A.

Create a new rectangle from two corner points.

The two points do not need to be the minimum and/or maximum corners. They only need to be two opposite corners.

Create a new rectangle from two corner points.

The two points do not need to be the minimum and/or maximum corners. They only need to be two opposite corners.

Create a new rectangle from its center and size.

If the size contains odd numbers they will be rounded down to the nearest whole number.

This method panics if any of the components of the size is negative.

Create a new rectangle from its center and half-size.

This method panics if any of the components of the half-size is negative.

Check if the rectangle is empty.

Rectangle width (max.x - min.x).

Rectangle height (max.y - min.y).

If the full size contains odd numbers they will be rounded down to the nearest whole number when calculating the half size.

The center point of the rectangle.

If the (min + max) contains odd numbers they will be rounded down to the nearest whole number when calculating the center.

Check if a point lies within this rectangle, inclusive of its edges.

Build a new rectangle formed of the union of this rectangle and another rectangle.

The union is the smallest rectangle enclosing both rectangles.

Build a new rectangle formed of the union of this rectangle and a point.

The union is the smallest rectangle enclosing both the rectangle and the point. If the point is already inside the rectangle, this method returns a copy of the rectangle.

Build a new rectangle formed of the intersection of this rectangle and another rectangle.

The intersection is the largest rectangle enclo

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct IRect {
    pub min: IVec2,
    pub max: IVec2,
}
```

Example 2 (javascript):
```javascript
let r = IRect::new(0, 4, 10, 6); // w=10 h=2
let r = IRect::new(2, 3, 5, -1); // w=3 h=4
```

Example 3 (javascript):
```javascript
// Unit rect from [0,0] to [1,1]
let r = IRect::from_corners(IVec2::ZERO, IVec2::ONE); // w=1 h=1
// Same; the points do not need to be ordered
let r = IRect::from_corners(IVec2::ONE, IVec2::ZERO); // w=1 h=1
```

Example 4 (javascript):
```javascript
let r = IRect::from_center_size(IVec2::ZERO, IVec2::new(3, 2)); // w=2 h=2
assert_eq!(r.min, IVec2::splat(-1));
assert_eq!(r.max, IVec2::splat(1));
```

---

## Struct Name Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Name.html

**Contents:**
- Struct Name Copy item path
- Implementations§
  - impl Name
    - pub fn new(name: impl Into<Cow<'static, str>>) -> Name
      - Examples found in repository?
    - pub fn set(&mut self, name: impl Into<Cow<'static, str>>)
    - pub fn mutate<F>(&mut self, f: F)where F: FnOnce(&mut String),
    - pub fn as_str(&self) -> &str
      - Examples found in repository?
- Methods from Deref<Target = str>§

Component used to identify an entity. Stores a hash for faster comparisons.

The hash is eagerly re-computed upon each update to the name.

Name should not be treated as a globally unique identifier for entities, as multiple entities can have the same name. Entity should be used instead as the default unique identifier.

Creates a new Name from any string-like type.

The internal hash will be computed immediately.

Sets the entity’s name.

The internal hash will be re-computed.

Updates the name of the entity in place.

This will allocate a new string if the name was previously created from a borrow.

Gets the name of the entity as a &str.

Returns the length of self.

This length is in bytes, not chars or graphemes. In other words, it might not be what a human considers the length of the string.

Returns true if self has a length of zero bytes.

Checks that index-th byte is the first byte in a UTF-8 code point sequence or the end of the string.

The start and end of the string (when index == self.len()) are considered to be boundaries.

Returns false if index is greater than self.len().

Finds the closest x not exceeding index where is_char_boundary(x) is true.

This method can help you truncate a string so that it’s still valid UTF-8, but doesn’t exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren’t split. For example, the emoji 🧑‍🔬 (scientist) could be split so that the string only includes 🧑 (person) instead.

Finds the closest x not below index where is_char_boundary(x) is true.

If index is greater than the length of the string, this returns the length of the string.

This method is the natural complement to floor_char_boundary. See that method for more details.

Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the from_utf8 function.

Converts a string slice to a raw pointer.

As string slices are a slice of bytes, the raw pointer points to a u8. This pointer will be pointing to the first byte of the string slice.

The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use as_mut_ptr.

Returns a subslice of str.

This is the non-panicking alternative to indexing the str. Returns None whenever equivalent indexing operation would panic.

Returns an unchecked subslice of str.

This is the unchecked alternative to indexing

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Name { /* private fields */ }
```

Example 2 (javascript):
```javascript
175fn spawn_player(mut commands: Commands) {
176    commands.spawn((Camera3d::default(), CameraSensitivity::default()));
177    commands.spawn((
178        Name::new("Player"),
179        Transform::from_scale(Vec3::splat(0.3)),
180        AccumulatedInput::default(),
181        Velocity::default(),
182        PhysicalTranslation::default(),
183        PreviousPhysicalTranslation::default(),
184    ));
185}
186
187/// Spawn a field of floating spheres to fly around in
188fn spawn_environment(
189    mut commands: Commands,
190    mut meshes: ResMut<Assets<Mesh>>,
191    mut materials: ResMut<A
...
```

Example 3 (unknown):
```unknown
27fn setup(mut commands: Commands) {
28    commands
29        .spawn((Name::new("Goblin"), HitPoints(50)))
30        .observe(take_damage)
31        .with_children(|parent| {
32            parent
33                .spawn((Name::new("Helmet"), Armor(5)))
34                .observe(block_attack);
35            parent
36                .spawn((Name::new("Socks"), Armor(10)))
37                .observe(block_attack);
38            parent
39                .spawn((Name::new("Shirt"), Armor(15)))
40                .observe(block_attack);
41        });
42}
```

Example 4 (unknown):
```unknown
46fn setup(
47    mut commands: Commands,
48    mut meshes: ResMut<Assets<Mesh>>,
49    mut materials: ResMut<Assets<StandardMaterial>>,
50) {
51    commands.spawn((
52        Name::new("Camera"),
53        Camera3d::default(),
54        Transform::from_xyz(5.0, 5.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
55    ));
56
57    commands.spawn((
58        Name::new("Plane"),
59        Mesh3d(meshes.add(Plane3d::default().mesh().size(5.0, 5.0))),
60        MeshMaterial3d(materials.add(StandardMaterial {
61            base_color: Color::srgb(0.3, 0.5, 0.3),
62            // Turning off culling keeps t
...
```

---

## Struct LogPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/log/struct.LogPlugin.html

**Contents:**
- Struct LogPlugin Copy item path
- §Example Setup
  - §Log levels
  - §Per module logging levels
  - §Further reading
- §Panics
- §Performance
- Fields§
- Trait Implementations§
  - impl Default for LogPlugin

Adds logging to Apps. This plugin is part of the DefaultPlugins. Adding this plugin will setup a collector appropriate to your target platform:

You can configure this plugin.

Log level can also be changed using the RUST_LOG environment variable. For example, using RUST_LOG=wgpu=error,bevy_render=info,bevy_ecs=trace cargo run ..

It has the same syntax as the field LogPlugin::filter, see EnvFilter. If you define the RUST_LOG environment variable, the LogPlugin settings will be ignored.

Also, to disable color terminal output (ANSI escape codes), you can set the environment variable NO_COLOR to any value. This common convention is documented at no-color.org. For example:

If you want to setup your own tracing collector, you should disable this plugin from DefaultPlugins:

For a quick setup that enables all first-party logging while not showing any of your dependencies’ log data, you can configure the plugin as shown below.

The filter (in this case an EnvFilter) chooses whether to print the log. The most specific filters apply with higher priority. Let’s start with an example: filter: "warn".to_string() will only print logs with level warn level or greater. From here, we can change to filter: "warn,my_crate=trace".to_string(). Logs will print at level warn unless it’s in mycrate, which will instead print at trace level because my_crate=trace is more specific.

Events can be logged at various levels of importance. Only events at your configured log level and higher will be shown.

In addition to format! style arguments, you can print a variable’s debug value by using syntax like: trace(?my_value).

Modules can have different logging levels using syntax like crate_name::module_name=debug.

The idea is that instead of deleting logs when they are no longer immediately applicable, you just disable them. If you do need to log in the future, then you can enable the logs instead of having to rewrite them.

The tracing crate has much more functionality than these examples can show. Much of this configuration can be done with “layers” in the log crate. Check out:

This plugin should not be added multiple times in the same process. This plugin sets up global logging configuration for all Apps in a given process, and rerunning the same initialization multiple times will lead to a panic.

Filters applied through this plugin are computed at runtime, which will have a non-zero impact on performance. To achieve maximum performance, consider using compile time filters prov

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct LogPlugin {
    pub filter: String,
    pub level: Level,
    pub custom_layer: fn(&mut App) -> Option<Box<dyn Layer<Registry> + Sync + Send>>,
    pub fmt_layer: fn(&mut App) -> Option<Box<dyn Layer<Layered<ErrorLayer<Layered<EnvFilter, Layered<Option<Box<dyn Layer<Registry> + Sync + Send>>, Registry>>>, Layered<EnvFilter, Layered<Option<Box<dyn Layer<Registry> + Sync + Send>>, Registry>>>> + Sync + Send>>,
}
```

Example 2 (unknown):
```unknown
fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(LogPlugin {
            level: Level::DEBUG,
            filter: "wgpu=error,bevy_render=info,bevy_ecs=trace".to_string(),
            custom_layer: |_| None,
            fmt_layer: |_| None,
        }))
        .run();
}
```

Example 3 (unknown):
```unknown
fn main() {
    std::env::set_var("NO_COLOR", "1");
    App::new()
       .add_plugins(DefaultPlugins)
       .run();
}
```

Example 4 (unknown):
```unknown
fn main() {
    App::new()
        .add_plugins(DefaultPlugins.build().disable::<LogPlugin>())
        .run();
}
```

---

## Struct TaskPoolOptions Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TaskPoolOptions.html

**Contents:**
- Struct TaskPoolOptions Copy item path
- Fields§
- Implementations§
  - impl TaskPoolOptions
    - pub fn with_num_threads(thread_count: usize) -> TaskPoolOptions
      - Examples found in repository?
    - pub fn create_default_pools(&self)
- Trait Implementations§
  - impl Clone for TaskPoolOptions
    - fn clone(&self) -> TaskPoolOptions

Helper for configuring and creating the default task pools. For end-users who want full control, set up TaskPoolPlugin

If the number of physical cores is less than min_total_threads, force using min_total_threads

If the number of physical cores is greater than max_total_threads, force using max_total_threads

Used to determine number of IO threads to allocate

Used to determine number of async compute threads to allocate

Used to determine number of compute threads to allocate

Create a configuration that forces using the given number of threads.

Inserts the default thread pools into the given resource map based on the configured values

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TaskPoolOptions {
    pub min_total_threads: usize,
    pub max_total_threads: usize,
    pub io: TaskPoolThreadAssignmentPolicy,
    pub async_compute: TaskPoolThreadAssignmentPolicy,
    pub compute: TaskPoolThreadAssignmentPolicy,
}
```

Example 2 (unknown):
```unknown
6fn main() {
7    App::new()
8        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
9            task_pool_options: TaskPoolOptions::with_num_threads(4),
10        }))
11        .run();
12}
```

---

## Trait GetPath Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.GetPath.html

**Contents:**
- Trait GetPath Copy item path
- §Syntax
  - §Structs
    - §Example
  - §Tuples and Tuple Structs
    - §Example
  - §Lists and Arrays
    - §Example
  - §Enums
    - §Example

A trait which allows nested Reflect values to be retrieved with path strings.

Using these functions repeatedly with the same string requires parsing the string every time. To avoid this cost, it’s recommended to construct a ParsedPath instead.

Field paths for Struct elements use the standard Rust field access syntax of dot and field name: .field_name.

Additionally, struct fields may be accessed by their index within the struct’s definition. This is accomplished by using the hash symbol (#) in place of the standard dot: #0.

Accessing a struct’s field by index can speed up fetches at runtime due to the removed need for string matching. And while this can be more performant, it’s best to keep in mind the tradeoffs when utilizing such optimizations. For example, this can result in fairly fragile code as the string paths will need to be kept in sync with the struct definitions since the order of fields could be easily changed. Because of this, storing these kinds of paths in persistent storage (i.e. game assets) is strongly discouraged.

Note that a leading dot (.) or hash (#) token is implied for the first item in a path, and may therefore be omitted.

Additionally, an empty path may be used to get the struct itself.

Tuple and TupleStruct elements also follow a conventional Rust syntax. Fields are accessed with a dot and the field index: .0.

Note that a leading dot (.) token is implied for the first item in a path, and may therefore be omitted.

List and Array elements are accessed with brackets: [0].

Pathing for Enum elements works a bit differently than in normal Rust. Usually, you would need to pattern match an enum, branching off on the desired variants. Paths used by this trait do not have any pattern matching capabilities; instead, they assume the variant is already known ahead of time.

The syntax used, therefore, depends on the variant being accessed:

If the variant cannot be known ahead of time, the path will need to be split up and proper enum pattern matching will need to be handled manually.

Using the aforementioned syntax, path items may be chained one after another to create a full path to a nested element.

Returns a reference to the value specified by path.

To retrieve a statically typed reference, use path.

Returns a mutable reference to the value specified by path.

To retrieve a statically typed mutable reference, use path_mut.

Returns a statically typed reference to the value specified by path.

This will automatically handle do

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait GetPath: PartialReflect {
    // Provided methods
    fn reflect_path<'p>(
        &self,
        path: impl ReflectPath<'p>,
    ) -> Result<&(dyn PartialReflect + 'static), ReflectPathError<'p>> { ... }
    fn reflect_path_mut<'p>(
        &mut self,
        path: impl ReflectPath<'p>,
    ) -> Result<&mut (dyn PartialReflect + 'static), ReflectPathError<'p>> { ... }
    fn path<'p, T>(
        &self,
        path: impl ReflectPath<'p>,
    ) -> Result<&T, ReflectPathError<'p>>
       where T: Reflect { ... }
    fn path_mut<'p, T>(
        &mut self,
        path: impl ReflectPath
...
```

Example 2 (javascript):
```javascript
#[derive(Reflect, PartialEq, Debug)]
struct MyStruct {
  value: u32
}

let my_struct = MyStruct { value: 123 };
// Access via field name
assert_eq!(my_struct.path::<u32>(".value").unwrap(), &123);
// Access via field index
assert_eq!(my_struct.path::<u32>("#0").unwrap(), &123);
// Access self
assert_eq!(*my_struct.path::<MyStruct>("").unwrap(), my_struct);
```

Example 3 (javascript):
```javascript
#[derive(Reflect)]
struct MyTupleStruct(u32);

let my_tuple_struct = MyTupleStruct(123);
assert_eq!(my_tuple_struct.path::<u32>(".0").unwrap(), &123);
```

Example 4 (javascript):
```javascript
let my_list: Vec<u32> = vec![1, 2, 3];
assert_eq!(my_list.path::<u32>("[2]").unwrap(), &3);
```

---

## Type Alias AnimationDiGraph Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.AnimationDiGraph.html

**Contents:**
- Type Alias AnimationDiGraph Copy item path
- Aliased Type§

A type alias for the petgraph data structure that defines the animation graph.

**Examples:**

Example 1 (unknown):
```unknown
pub type AnimationDiGraph = Graph<AnimationGraphNode, ()>;
```

Example 2 (unknown):
```unknown
pub struct AnimationDiGraph { /* private fields */ }
```

---

## Enum ParallaxMappingMethod Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ParallaxMappingMethod.html

**Contents:**
- Enum ParallaxMappingMethod Copy item path
- Variants§
  - Occlusion
  - Relief
    - Fields
- Implementations§
  - impl ParallaxMappingMethod
    - pub const DEFAULT_RELIEF_MAPPING: ParallaxMappingMethod
- Trait Implementations§
  - impl Clone for ParallaxMappingMethod

The parallax mapping method to use to compute depth based on the material’s depth_map.

Parallax Mapping uses a depth map texture to give the illusion of depth variation on a mesh surface that is geometrically flat.

See the parallax_mapping.wgsl shader code for implementation details and explanation of the methods used.

A simple linear interpolation, using a single texture sample.

This method is named “Parallax Occlusion Mapping”.

Unlike ParallaxMappingMethod::Relief, only requires a single lookup, but may skip small details and result in writhing material artifacts.

Discovers the best depth value based on binary search.

Each iteration incurs a texture sample. The result has fewer visual artifacts than ParallaxMappingMethod::Occlusion.

This method is named “Relief Mapping”.

How many additional steps to use at most to find the depth value.

ParallaxMappingMethod::Relief with a 5 steps, a reasonable default.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ParallaxMappingMethod {
    Occlusion,
    Relief {
        max_steps: u32,
    },
}
```

---

## Struct MeshPickingCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshPickingCamera.html

**Contents:**
- Struct MeshPickingCamera Copy item path
- Trait Implementations§
  - impl Clone for MeshPickingCamera
    - fn clone(&self) -> MeshPickingCamera
    - fn clone_from(&mut self, source: &Self)
  - impl Component for MeshPickingCamerawhere MeshPickingCamera: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

An optional component that marks cameras that should be used in the MeshPickingPlugin.

Only needed if MeshPickingSettings::require_markers is set to true, and ignored otherwise.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshPickingCamera;
```

---

## Trait Ease Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Ease.html

**Contents:**
- Trait Ease Copy item path
- Required Methods§
    - fn interpolating_curve_unbounded(start: Self, end: Self) -> impl Curve<Self>
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl<T> Ease for (T₁, T₂, …, Tₙ)where T: Ease,
    - fn interpolating_curve_unbounded(start: (T,), end: (T,)) -> impl Curve<(T,)>
- Implementors§
  - impl Ease for Dir2
  - impl Ease for Dir3

A type whose values can be eased between.

This requires the construction of an interpolation curve that actually extends beyond the curve segment that connects two values, because an easing curve may extrapolate before the starting value and after the ending value. This is especially common in easing functions that mimic elastic or springlike behavior.

Given start and end values, produce a curve with unlimited domain that:

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

This trait is implemented for tuples up to 11 items long.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Ease: Sized {
    // Required method
    fn interpolating_curve_unbounded(start: Self, end: Self) -> impl Curve<Self>;
}
```

---

## Struct CircularSector Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CircularSector.html

**Contents:**
- Struct CircularSector Copy item path
- Fields§
- Implementations§
  - impl CircularSector
    - pub const fn new(radius: f32, angle: f32) -> CircularSector
      - Examples found in repository?
    - pub const fn from_radians(radius: f32, angle: f32) -> CircularSector
    - pub const fn from_degrees(radius: f32, angle: f32) -> CircularSector
    - pub const fn from_turns(radius: f32, fraction: f32) -> CircularSector
      - Examples found in repository?

A primitive representing a circular sector: a pie slice of a circle.

The segment is positioned so that it always includes Vec2::Y and is vertically symmetrical. To orient the sector differently, apply a rotation. The sector is drawn with the center of its circle at the origin Vec2::ZERO.

Warning: Circular sectors with negative angle or radius, or with angle greater than an entire circle, are not officially supported. We recommend normalizing circular sectors to have an angle in [0, 2π].

The arc defining the sector

Create a new CircularSector from a radius and an angle

Create a new CircularSector from a radius and an angle in radians.

Create a new CircularSector from a radius and an angle in degrees.

Create a new CircularSector from a radius and a number of turns of a circle.

For instance, 0.5 turns is a semicircle.

Get half the angle of the sector

Get the angle of the sector

Get the radius of the sector

Get the length of the arc defining the sector

Get half the length of the chord defined by the sector

See Arc2d::half_chord_length

Get the length of the chord defined by the sector

See Arc2d::chord_length

Get the midpoint of the chord defined by the sector

See Arc2d::chord_midpoint

Get the length of the apothem of this sector

Get the length of the sagitta of this sector

Returns the default CircularSector with radius 0.5 and covering a third of a circle

Converts this sector into a Mesh using a default CircularSectorMeshBuilder.

See the documentation of CircularSectorMeshBuilder for more details.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CircularSector {
    pub arc: Arc2d,
}
```

Example 2 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 3 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

Example 4 (javascript):
```javascript
34fn setup(
35    mut commands: Commands,
36    asset_server: Res<AssetServer>,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    let material = materials.add(asset_server.load("branding/icon.png"));
41
42    commands.spawn((
43        Camera2d,
44        Camera {
45            clear_color: ClearColorConfig::Custom(GRAY.into()),
46            ..default()
47        },
48    ));
49
50    const NUM_SLICES: i32 = 8;
51    const SPACING_X: f32 = 100.0;
52    const OFFSET_X: f32 = SPACING_X * (NUM_SLICES - 1) as f32 / 2.0;
53
54    // This draws 
...
```

---

## Struct MorphWeights Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MorphWeights.html

**Contents:**
- Struct MorphWeights Copy item path
- Implementations§
  - impl MorphWeights
    - pub fn new( weights: Vec<f32>, first_mesh: Option<Handle<Mesh>>, ) -> Result<MorphWeights, MorphBuildError>
    - pub fn first_mesh(&self) -> Option<&Handle<Mesh>>
    - pub fn weights(&self) -> &[f32]
    - pub fn weights_mut(&mut self) -> &mut [f32]
- Trait Implementations§
  - impl Clone for MorphWeights
    - fn clone(&self) -> MorphWeights

Controls the morph targets for all child Mesh3d entities. In most cases, MorphWeights should be considered the “source of truth” when writing morph targets for meshes. However you can choose to write child MeshMorphWeights if your situation requires more granularity. Just note that if you set MorphWeights, it will overwrite child MeshMorphWeights values.

This exists because Bevy’s Mesh corresponds to a single surface / material, whereas morph targets as defined in the GLTF spec exist on “multi-primitive meshes” (where each primitive is its own surface with its own material). Therefore in Bevy MorphWeights an a parent entity are the “canonical weights” from a GLTF perspective, which then synchronized to child Mesh3d / MeshMorphWeights (which correspond to “primitives” / “surfaces” from a GLTF perspective).

Add this to the parent of one or more Entities with a Mesh3d with a MeshMorphWeights.

The first child Mesh3d primitive controlled by these weights. This can be used to look up metadata information such as Mesh::morph_target_names.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MorphWeights { /* private fields */ }
```

---

## Enum Interaction Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Interaction.html

**Contents:**
- Enum Interaction Copy item path
- §See also
- Variants§
  - Pressed
  - Hovered
  - None
- Trait Implementations§
  - impl Clone for Interaction
    - fn clone(&self) -> Interaction
    - fn clone_from(&mut self, source: &Self)

Describes what type of input interaction has occurred for a UI node.

This is commonly queried with a Changed<Interaction> filter.

Updated in ui_focus_system.

If a UI node has both Interaction and InheritedVisibility components, Interaction will always be Interaction::None when InheritedVisibility::get() is false. This ensures that hidden UI nodes are not interactable, and do not end up stuck in an active state if hidden at the wrong time.

Note that you can also control the visibility of a node using the Display property, which fully collapses it during layout calculations.

The node has been pressed.

Note: This does not capture click/press-release action.

The node has been hovered over

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Interaction {
    Pressed,
    Hovered,
    None,
}
```

---

## Struct ThreadLockedRawWindowHandleWrapper Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/window/struct.ThreadLockedRawWindowHandleWrapper.html

**Contents:**
- Struct ThreadLockedRawWindowHandleWrapper Copy item path
- Trait Implementations§
  - impl HasDisplayHandle for ThreadLockedRawWindowHandleWrapper
    - fn display_handle(&self) -> Result<DisplayHandle<'_>, HandleError>
  - impl HasWindowHandle for ThreadLockedRawWindowHandleWrapper
    - fn window_handle(&self) -> Result<WindowHandle<'_>, HandleError>
- Auto Trait Implementations§
  - impl Freeze for ThreadLockedRawWindowHandleWrapper
  - impl !RefUnwindSafe for ThreadLockedRawWindowHandleWrapper
  - impl Send for ThreadLockedRawWindowHandleWrapper

A RawHandleWrapper that cannot be sent across threads.

This safely exposes RawWindowHandle and RawDisplayHandle, but care must be taken to ensure that the construction itself is correct.

This can only be constructed via the RawHandleWrapper::get_handle() method; be sure to read the safety docs there about platform-specific limitations. In many cases, this should only be constructed on the main thread.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ThreadLockedRawWindowHandleWrapper(/* private fields */);
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/animation/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§
- Functions§
- Type Aliases§

The animation prelude.

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct SmootherStepCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SmootherStepCurve.html

**Contents:**
- Struct SmootherStepCurve Copy item path
- Trait Implementations§
  - impl Clone for SmootherStepCurve
    - fn clone(&self) -> SmootherStepCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SmootherStepCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = 6t⁵ - 15t⁴ + 10t³

This is the Hermite interpolator for

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SmootherStepCurve;
```

---

## Struct AssetServer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AssetServer.html

**Contents:**
- Struct AssetServer Copy item path
- Implementations§
  - impl AssetServer
    - pub fn new( sources: AssetSources, mode: AssetServerMode, watching_for_changes: bool, unapproved_path_mode: UnapprovedPathMode, ) -> AssetServer
    - pub fn new_with_meta_check( sources: AssetSources, mode: AssetServerMode, meta_check: AssetMetaCheck, watching_for_changes: bool, unapproved_path_mode: UnapprovedPathMode, ) -> AssetServer
    - pub fn get_source<'a>( &self, source: impl Into<AssetSourceId<'a>>, ) -> Result<&AssetSource, MissingAssetSourceError>
    - pub fn watching_for_changes(&self) -> bool
    - pub fn register_loader<L>(&self, loader: L)where L: AssetLoader,
    - pub fn register_asset<A>(&self, assets: &Assets<A>)where A: Asset,
    - pub async fn get_asset_loader_with_extension( &self, extension: &str, ) -> Result<Arc<dyn ErasedAssetLoader>, MissingAssetLoaderForExtensionError>

Loads and tracks the state of Asset values from a configured AssetReader. This can be used to kick off new asset loads and retrieve their current load states.

The general process to load an asset is:

AssetServer can be cloned. It is backed by an Arc so clones will share state. Clones can be freely used in parallel.

Create a new instance of AssetServer. If watch_for_changes is true, the AssetReader storage will watch for changes to asset sources and hot-reload them.

Create a new instance of AssetServer. If watch_for_changes is true, the AssetReader storage will watch for changes to asset sources and hot-reload them.

Retrieves the AssetSource for the given source.

Returns true if the AssetServer watches for changes.

Registers a new AssetLoader. AssetLoaders must be registered before they can be used.

Registers a new Asset type. Asset types must be registered before assets of that type can be loaded.

Returns the registered AssetLoader associated with the given extension, if it exists.

Returns the registered AssetLoader associated with the given core::any::type_name, if it exists.

Retrieves the default AssetLoader for the given path, if one can be found.

Retrieves the default AssetLoader for the given Asset TypeId, if one can be found.

Retrieves the default AssetLoader for the given Asset type, if one can be found.

Begins loading an Asset of type A stored at path. This will not block on the asset load. Instead, it returns a “strong” Handle. When the Asset is loaded (and enters LoadState::Loaded), it will be added to the associated Assets resource.

Note that if the asset at this path is already loaded, this function will return the existing handle, and will not waste work spawning a new load task.

In case the file path contains a hashtag (#), the path must be specified using Path or AssetPath because otherwise the hashtag would be interpreted as separator between the file path and the label. For example:

Furthermore, if you need to load a file with a hashtag in its name and a label, you can manually construct an AssetPath.

You can check the asset’s load state by reading AssetEvent events, calling AssetServer::load_state, or checking the Assets storage to see if the Asset exists yet.

The asset load will fail and an error will be printed to the logs if the asset stored at path is not of type A.

Same as load, but you can load assets from unapproved paths if AssetPlugin::unapproved_path_mode is Deny.

See UnapprovedPathMode and AssetPath::is_una

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct AssetServer { /* private fields */ }
```

Example 2 (unknown):
```unknown
// `#path` is a label.
asset_server.load("some/file#path");

// `#path` is part of the file name.
asset_server.load(Path::new("some/file#path"));
```

Example 3 (unknown):
```unknown
asset_server.load(AssetPath::from_path(Path::new("some/file#path")).with_label("subasset"));
```

Example 4 (unknown):
```unknown
116fn setup_game(mut commands: Commands, asset_server: Res<AssetServer>) {
117    commands.spawn(Sprite::from_image(asset_server.load("branding/icon.png")));
118}
```

---

## Macro once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.once.html

**Contents:**
- Macro once Copy item path

Call some expression only once per call site.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! once {
    ($expression:expr) => { ... };
}
```

---

## Enum UnapprovedPathMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/asset/enum.UnapprovedPathMode.html

**Contents:**
- Enum UnapprovedPathMode Copy item path
- Variants§
  - Allow
  - Deny
  - Forbid
- Trait Implementations§
  - impl Clone for UnapprovedPathMode
    - fn clone(&self) -> UnapprovedPathMode
    - fn clone_from(&mut self, source: &Self)
  - impl Default for UnapprovedPathMode

Determines how to react to attempts to load assets not inside the approved folders.

Approved folders are AssetPlugin::file_path and the folder of each AssetSource. Subfolders within these folders are also valid.

It is strongly discouraged to use Allow if your app will include scripts or modding support, as it could allow arbitrary file access for malicious code.

The default value is Forbid.

See AssetPath::is_unapproved

Unapproved asset loading is allowed. This is strongly discouraged.

Fails to load any asset that is unapproved, unless an override method is used, like AssetServer::load_override.

Fails to load any asset that is unapproved.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum UnapprovedPathMode {
    Allow,
    Deny,
    Forbid,
}
```

---

## Enum PositionType Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.PositionType.html

**Contents:**
- Enum PositionType Copy item path
- Variants§
  - Relative
  - Absolute
- Implementations§
  - impl PositionType
    - pub const DEFAULT: PositionType = Self::Relative
- Trait Implementations§
  - impl Clone for PositionType
    - fn clone(&self) -> PositionType

The strategy used to position this node

Relative to all other nodes with the PositionType::Relative value.

Independent of all other nodes, but relative to its parent node.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum PositionType {
    Relative,
    Absolute,
}
```

---

## Struct CubicBSpline Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicBSpline.html

**Contents:**
- Struct CubicBSpline Copy item path
    - §Interpolation
    - §Tangency
    - §Continuity
    - §Parametrization
    - §Usage
- Fields§
- Implementations§
  - impl<P> CubicBSpline<P>where P: VectorSpace,
    - pub fn new(control_points: impl IntoIterator<Item = P>) -> CubicBSpline<P>

A spline interpolated continuously across the nearest four control points. The curve does not necessarily pass through any of the control points.

The curve does not necessarily pass through its control points.

Tangents are automatically computed based on the positions of control points.

The curve is C2 continuous, meaning it has no holes or jumps, the tangent vector changes smoothly along the entire curve, and the acceleration also varies continuously. The acceleration continuity of this spline makes it useful for camera paths.

Each curve segment is defined by a window of four control points taken in sequence. When to_curve_cyclic is used to form a cyclic curve, the three additional segments used to close the curve come last.

The control points of the spline

Build a new B-Spline.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicBSpline<P>where
    P: VectorSpace,{
    pub control_points: Vec<P>,
}
```

Example 2 (javascript):
```javascript
let points = [
    vec2(-1.0, -20.0),
    vec2(3.0, 2.0),
    vec2(5.0, 3.0),
    vec2(9.0, 8.0),
];
let b_spline = CubicBSpline::new(points).to_curve().unwrap();
let positions: Vec<_> = b_spline.iter_positions(100).collect();
```

Example 3 (javascript):
```javascript
202fn form_curve(
203    control_points: &ControlPoints,
204    spline_mode: SplineMode,
205    cycling_mode: CyclingMode,
206) -> Curve {
207    let (points, tangents): (Vec<_>, Vec<_>) =
208        control_points.points_and_tangents.iter().copied().unzip();
209
210    match spline_mode {
211        SplineMode::Hermite => {
212            let spline = CubicHermite::new(points, tangents);
213            Curve(match cycling_mode {
214                CyclingMode::NotCyclic => spline.to_curve().ok(),
215                CyclingMode::Cyclic => spline.to_curve_cyclic().ok(),
216            })
217   
...
```

---

## Struct CircularOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CircularOutCurve.html

**Contents:**
- Struct CircularOutCurve Copy item path
- Trait Implementations§
  - impl Clone for CircularOutCurve
    - fn clone(&self) -> CircularOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for CircularOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = sqrt((2.0 - t) * t)

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CircularOutCurve;
```

---

## Struct On Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.On.html

**Contents:**
- Struct On Copy item path
- Implementations§
  - impl<'w, 't, E, B> On<'w, 't, E, B>where E: Event, B: Bundle,
    - pub fn new( event: &'w mut E, observer: Entity, trigger: &'w mut <E as Event>::Trigger<'t>, trigger_context: &'w TriggerContext, ) -> On<'w, 't, E, B>
    - pub fn event_key(&self) -> EventKey
    - pub fn event(&self) -> &E
      - Examples found in repository?
    - pub fn event_mut(&mut self) -> &mut E
    - pub fn event_ptr(&self) -> Ptr<'_>
    - pub fn trigger(&self) -> &<E as Event>::Trigger<'t>

A system parameter used by an observer to process events. See Observer and Event for examples.

On contains the triggered Event data for a given run of an Observer. It also provides access to the Trigger, which for things like EntityEvent with a PropagateEntityTrigger, includes control over event propagation.

The generic B: Bundle is used to further specialize the events that this observer is interested in. The entity involved does not have to have these components, but the observer will only be triggered if the event matches the components in B.

This is used to to avoid providing a generic argument in your event, as is done for Add and the other lifecycle events.

Providing multiple components in this bundle will cause this event to be triggered by any matching component in the bundle, rather than requiring all of them to be present.

Creates a new instance of On for the given triggered event.

Returns the event type of this On instance.

Returns a reference to the triggered event.

Returns a mutable reference to the triggered event.

Returns a pointer to the triggered event.

Returns the Trigger context for this event.

Returns the mutable Trigger context for this event.

Returns the Entity of the Observer of the triggered event. This allows you to despawn the observer, ceasing observation.

Returns the source code location that triggered this observer, if the track_location cargo feature is enabled.

A deprecated way to retrieve the entity that this EntityEvent targeted at.

Access the event via On::event, then read the entity that the event was targeting. Prefer using the field name directly for clarity, but if you are working in a generic context, you can use EntityEvent::event_target.

Returns the original Entity that this EntityEvent targeted via EntityEvent::event_target when it was first triggered, prior to any propagation logic.

Enables or disables event propagation, allowing the same event to trigger observers on a chain of different entities.

The path an EntityEvent will propagate along is specified by the Traversal component defined in PropagateEntityTrigger.

EntityEvent does not propagate by default. To enable propagation, you must:

You can prevent an event from propagating further using propagate(false). This will prevent the event from triggering on the next Entity in the Traversal, but note that all remaining observers for the current entity will still run.

Returns the value of the flag that controls event propagation. See propagate

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct On<'w, 't, E, B = ()>where
    E: Event,
    B: Bundle,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
108fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
109    // Camera
110    commands.spawn((Camera2d, IsDefaultUiCamera));
111
112    // Font
113    let font_handle = asset_server.load("fonts/FiraSans-Bold.ttf");
114
115    // root node
116    commands
117        .spawn(Node {
118            width: percent(100),
119            height: percent(100),
120            justify_content: JustifyContent::SpaceBetween,
121            flex_direction: FlexDirection::Column,
122            ..default()
123        })
124        .with_children(|parent| {
125            // horizontal scroll e
...
```

Example 3 (javascript):
```javascript
45fn observe_on_step(
46    step: On<Step>,
47    particle: Res<ParticleAssets>,
48    mut commands: Commands,
49    transforms: Query<&GlobalTransform>,
50    mut seeded_rng: ResMut<SeededRng>,
51) -> Result {
52    let translation = transforms
53        .get(step.trigger().animation_player)?
54        .translation();
55    // Spawn a bunch of particles.
56    for _ in 0..14 {
57        let horizontal = seeded_rng.0.random::<Dir2>() * seeded_rng.0.random_range(8.0..12.0);
58        let vertical = seeded_rng.0.random_range(0.0..4.0);
59        let size = seeded_rng.0.random_range(0.2..1.0);
60
...
```

Example 4 (javascript):
```javascript
#[derive(EntityEvent)]  
struct AssertEvent {
    entity: Entity,
}

fn assert_observer(event: On<AssertEvent>) {  
    assert_eq!(event.observer(), event.entity);  
}  

let mut world = World::new();  
let entity = world.spawn(Observer::new(assert_observer)).id();  

world.trigger(AssertEvent { entity });
```

---

## Function mat4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.mat4.html

**Contents:**
- Function mat4 Copy item path

Creates a 4x4 matrix from four column vectors.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn mat4(
    x_axis: Vec4,
    y_axis: Vec4,
    z_axis: Vec4,
    w_axis: Vec4,
) -> Mat4
```

---

## Function mat3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.mat3.html

**Contents:**
- Function mat3 Copy item path

Creates a 3x3 matrix from three column vectors.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn mat3(x_axis: Vec3, y_axis: Vec3, z_axis: Vec3) -> Mat3
```

---

## Type Alias RunFixedMainLoopSystem Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/type.RunFixedMainLoopSystem.html

**Contents:**
- Type Alias RunFixedMainLoopSystem Copy item path
- Aliased Type§
- Variants§
  - BeforeFixedMainLoop
    - §Example
  - FixedMainLoop
    - §Example
  - AfterFixedMainLoop
    - §Example

Deprecated alias for RunFixedMainLoopSystems.

Runs before the fixed update logic.

A good example of a system that fits here is camera movement, which needs to be updated in a variable timestep, as you want the camera to move with as much precision and updates as the frame rate allows. A physics system that needs to read the camera position and orientation, however, should run in the fixed update logic, as it needs to be deterministic and run at a fixed rate for better stability. Note that we are not placing the camera movement system in Update, as that would mean that the physics system already ran at that point.

Contains the fixed update logic. Runs FixedMain zero or more times based on delta of Time<Virtual> and Time::overstep.

Don’t place systems here, use FixedUpdate and friends instead. Use this system instead to order your systems to run specifically inbetween the fixed update logic and all other systems that run in RunFixedMainLoopSystems::BeforeFixedMainLoop or RunFixedMainLoopSystems::AfterFixedMainLoop.

Runs after the fixed update logic.

A good example of a system that fits here is a system that interpolates the transform of an entity between the last and current fixed update. See the fixed timestep example for more details.

**Examples:**

Example 1 (unknown):
```unknown
pub type RunFixedMainLoopSystem = RunFixedMainLoopSystems;
```

Example 2 (unknown):
```unknown
pub enum RunFixedMainLoopSystem {
    BeforeFixedMainLoop,
    FixedMainLoop,
    AfterFixedMainLoop,
}
```

Example 3 (unknown):
```unknown
App::new()
  .add_systems(
    RunFixedMainLoop,
    update_camera_rotation.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop))
  .add_systems(FixedUpdate, update_physics);
```

Example 4 (unknown):
```unknown
App::new()
  .add_systems(FixedUpdate, update_physics)
  .add_systems(
    RunFixedMainLoop,
    (
      // This system will be called before all interpolation systems
      // that third-party plugins might add.
      prepare_for_interpolation
        .after(RunFixedMainLoopSystems::FixedMainLoop)
        .before(RunFixedMainLoopSystems::AfterFixedMainLoop),
    )
  );
```

---

## Struct SmoothStepCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SmoothStepCurve.html

**Contents:**
- Struct SmoothStepCurve Copy item path
- Trait Implementations§
  - impl Clone for SmoothStepCurve
    - fn clone(&self) -> SmoothStepCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SmoothStepCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

This is the Hermite interpolator for

See also smoothstep in GLSL.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SmoothStepCurve;
```

---

## Macro warn Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.warn.html

**Contents:**
- Macro warn Copy item path
- §Examples

Constructs an event at the warn level.

This functions similarly to the event! macro. See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! warn {
    (name: $name:expr, target: $target:expr, parent: $parent:expr, { $($field:tt)* }, $($arg:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, ?$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, %$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($arg:tt)+ ) => { ... };
    (name: $name:expr, target: $target:expr, {
...
```

Example 2 (javascript):
```javascript
use tracing::warn;

let warn_description = "Invalid Input";
let input = &[0x27, 0x45];

warn!(?input, warning = warn_description);
warn!(
    target: "input_events",
    warning = warn_description,
    "Received warning for input: {:?}", input,
);
warn!(name: "invalid", ?input);
```

---

## Struct Image Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Image.html

**Contents:**
- Struct Image Copy item path
  - §Remote Inspection
- Fields§
    - §Field Usage Notes
    - §Field Usage Notes
- Implementations§
  - impl Image
    - pub fn new( size: Extent3d, dimension: TextureDimension, data: Vec<u8>, format: TextureFormat, asset_usage: RenderAssetUsages, ) -> Image
      - §Panics
    - pub fn new_uninit( size: Extent3d, dimension: TextureDimension, format: TextureFormat, asset_usage: RenderAssetUsages, ) -> Image

An image, optimized for usage in rendering.

To transmit an Image between two running Bevy apps, e.g. through BRP, use SerializedImage. This type is only meant for short-term transmission between same versions and should not be stored anywhere.

Raw pixel data. If the image is being used as a storage texture which doesn’t need to be initialized by the CPU, then this should be None. Otherwise, it should always be Some.

For texture data with layers and mips, this field controls how wgpu interprets the buffer layout.

Use TextureDataOrder::default() for all other cases.

Describes the data layout of the GPU texture. For example, whether a texture contains 1D/2D/3D data, and what the format of the texture data is.

The ImageSampler to use during rendering.

Describes how the GPU texture should be interpreted. For example, 2D image data could be read as plain 2D, an array texture of layers of 2D with the same dimensions (and the number of layers in that case), a cube map, an array of cube maps, etc.

Whether this image should be copied on the GPU when resized.

Creates a new image from raw binary data and the corresponding metadata.

Panics if the length of the data, volume of the size and the size of the format do not match.

Exactly the same as Image::new, but doesn’t initialize the image

A transparent white 1x1x1 image.

Contrast to Image::default, which is opaque.

Creates a new uninitialized 1x1x1 image

Creates a new image from raw binary data and the corresponding metadata, by filling the image data with the pixel data repeated multiple times.

Panics if the size of the format is not a multiple of the length of the pixel data.

Create a new zero-filled image with a given size, which can be rendered to. Useful for mirrors, UI, or exporting images for example. This is primarily for use as a render target for a Camera. See RenderTarget::Image.

For Standard Dynamic Range (SDR) images you can use TextureFormat::Rgba8UnormSrgb. For High Dynamic Range (HDR) images you can use TextureFormat::Rgba16Float.

The default TextureUsages are TEXTURE_BINDING, COPY_DST, RENDER_ATTACHMENT.

The default RenderAssetUsages is MAIN_WORLD | RENDER_WORLD so that it is accessible from the CPU and GPU. You can customize this by changing the asset_usage field.

Returns the width of a 2D image.

Returns the height of a 2D image.

Returns the aspect ratio (width / height) of a 2D image.

Returns the size of a 2D image as f32.

Returns the size of a 2D image.

Resizes the image to

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Image {
    pub data: Option<Vec<u8>>,
    pub data_order: TextureDataOrder,
    pub texture_descriptor: TextureDescriptor<Option<&'static str>, &'static [TextureFormat]>,
    pub sampler: ImageSampler,
    pub texture_view_descriptor: Option<TextureViewDescriptor<Option<&'static str>>>,
    pub asset_usage: RenderAssetUsages,
    pub copy_on_resize: bool,
}
```

Example 2 (javascript):
```javascript
349    fn from_world(world: &mut World) -> Self {
350        let mut images = world.resource_mut::<Assets<Image>>();
351
352        // Create a new 32-bit floating point depth texture.
353        let mut depth_image = Image::new_uninit(
354            Extent3d {
355                width: DEPTH_TEXTURE_SIZE,
356                height: DEPTH_TEXTURE_SIZE,
357                depth_or_array_layers: 1,
358            },
359            TextureDimension::D2,
360            TextureFormat::Depth32Float,
361            RenderAssetUsages::default(),
362        );
363
364        // Create a sampler. Note 
...
```

Example 3 (javascript):
```javascript
25fn test(
26    mut commands: Commands,
27    mut images: ResMut<Assets<Image>>,
28    mut meshes: ResMut<Assets<Mesh>>,
29    mut materials: ResMut<Assets<StandardMaterial>>,
30) {
31    // Spawn a UI camera
32    commands.spawn(Camera3d::default());
33
34    // Set up an texture for the 3D camera to render to.
35    // The size of the texture will be based on the viewport's ui size.
36    let mut image = Image::new_uninit(
37        default(),
38        TextureDimension::D2,
39        TextureFormat::Bgra8UnormSrgb,
40        RenderAssetUsages::all(),
41    );
42    image.texture_descriptor.
...
```

Example 4 (javascript):
```javascript
70fn setup(
71    mut commands: Commands,
72    mut images: ResMut<Assets<Image>>,
73    mut buffers: ResMut<Assets<ShaderStorageBuffer>>,
74) {
75    // Create a storage buffer with some data
76    let buffer: Vec<u32> = (0..BUFFER_LEN as u32).collect();
77    let mut buffer = ShaderStorageBuffer::from(buffer);
78    // We need to enable the COPY_SRC usage so we can copy the buffer to the cpu
79    buffer.buffer_description.usage |= BufferUsages::COPY_SRC;
80    let buffer = buffers.add(buffer);
81
82    // Create a storage texture with some data
83    let size = Extent3d {
84        width: B
...
```

---

## Trait Hue Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Hue.html

**Contents:**
- Trait Hue Copy item path
- Required Methods§
    - fn with_hue(&self, hue: f32) -> Self
    - fn hue(&self) -> f32
    - fn set_hue(&mut self, hue: f32)
- Provided Methods§
    - fn rotate_hue(&self, degrees: f32) -> Self
      - Examples found in repository?
- Dyn Compatibility§
- Implementors§

Trait for manipulating the hue of a color.

Return a new version of this color with the hue channel set to the given value.

Return the hue of this color [0.0, 360.0].

Sets the hue of this color.

Return a new version of this color with the hue channel rotated by the given degrees.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Hue: Sized {
    // Required methods
    fn with_hue(&self, hue: f32) -> Self;
    fn hue(&self) -> f32;
    fn set_hue(&mut self, hue: f32);

    // Provided method
    fn rotate_hue(&self, degrees: f32) -> Self { ... }
}
```

Example 2 (javascript):
```javascript
13fn setup(
14    mut commands: Commands,
15    asset_server: Res<AssetServer>,
16    mut meshes: ResMut<Assets<Mesh>>,
17    mut materials: ResMut<Assets<StandardMaterial>>,
18) {
19    commands.spawn((
20        Camera3d::default(),
21        Transform::from_xyz(3.0, 1.0, 3.0).looking_at(Vec3::new(0.0, -0.5, 0.0), Vec3::Y),
22        EnvironmentMapLight {
23            diffuse_map: asset_server.load("environment_maps/pisa_diffuse_rgb9e5_zstd.ktx2"),
24            specular_map: asset_server.load("environment_maps/pisa_specular_rgb9e5_zstd.ktx2"),
25            intensity: 2_000.0,
26          
...
```

Example 3 (javascript):
```javascript
16fn find_top_material_and_mesh(
17    mut materials: ResMut<Assets<StandardMaterial>>,
18    mut meshes: ResMut<Assets<Mesh>>,
19    time: Res<Time>,
20    mat_query: Query<(
21        &MeshMaterial3d<StandardMaterial>,
22        &Mesh3d,
23        &GltfMaterialName,
24    )>,
25) {
26    for (mat_handle, mesh_handle, name) in mat_query.iter() {
27        // locate a material by material name
28        if name.0 == "Top" {
29            if let Some(material) = materials.get_mut(mat_handle) {
30                if let Color::Hsla(ref mut hsla) = material.base_color {
31                    *hsla
...
```

---

## Struct SineInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SineInCurve.html

**Contents:**
- Struct SineInCurve Copy item path
- Trait Implementations§
  - impl Clone for SineInCurve
    - fn clone(&self) -> SineInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SineInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = 1.0 - cos(t * π / 2.0)

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SineInCurve;
```

---

## Trait Meshable Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Meshable.html

**Contents:**
- Trait Meshable Copy item path
- Required Associated Types§
    - type Output: MeshBuilder
- Required Methods§
    - fn mesh(&self) -> Self::Output
- Implementors§
  - impl Meshable for Annulus
    - type Output = AnnulusMeshBuilder
  - impl Meshable for Capsule2d
    - type Output = Capsule2dMeshBuilder

A trait for shapes that can be turned into a Mesh.

The output of Self::mesh. This will be a MeshBuilder used for creating a Mesh.

Creates a Mesh for a shape.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Meshable {
    type Output: MeshBuilder;

    // Required method
    fn mesh(&self) -> Self::Output;
}
```

---

## Struct InfinitePlane3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.InfinitePlane3d.html

**Contents:**
- Struct InfinitePlane3d Copy item path
- Fields§
- Implementations§
  - impl InfinitePlane3d
    - pub fn new<T>(normal: T) -> InfinitePlane3dwhere T: TryInto<Dir3>, <T as TryInto<Dir3>>::Error: Debug,
      - §Panics
      - Examples found in repository?
    - pub fn from_points(a: Vec3, b: Vec3, c: Vec3) -> (InfinitePlane3d, Vec3)
      - §Panics
    - pub fn signed_distance( &self, isometry: impl Into<Isometry3d>, point: Vec3, ) -> f32

An unbounded plane in 3D space. It forms a separating surface through the origin, stretching infinitely far

The normal of the plane. The plane will be placed perpendicular to this direction

Create a new InfinitePlane3d from a normal

Panics if the given normal is zero (or very close to zero), or non-finite.

Create a new InfinitePlane3d based on three points and compute the geometric center of those points.

The direction of the plane normal is determined by the winding order of the triangular shape formed by the points.

Panics if a valid normal can not be computed, for example when the points are collinear and lie on the same line.

Computes the shortest distance between a plane transformed with the given isometry and a point. The result is a signed value; it’s positive if the point lies in the half-space that the plane’s normal vector points towards.

Injects the point into this plane transformed with the given isometry.

This projects the point orthogonally along the shortest path onto the plane.

Computes an Isometry3d which transforms points from the plane in 3D space with the given origin to the XY-plane.

See isometries_xy for example usescases.

Computes an Isometry3d which transforms points from the XY-plane to this plane with the given origin.

See isometries_xy for example usescases.

Computes both isometries which transforms points from the plane in 3D space with the given origin to the XY-plane and back.

The projection and its inverse can be used to run 2D algorithms on flat shapes in 3D. The workflow would usually look like this:

Returns the default InfinitePlane3d with a normal pointing in the +Y direction.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct InfinitePlane3d {
    pub normal: Dir3,
}
```

Example 2 (javascript):
```javascript
13fn draw_cursor(
14    camera_query: Single<(&Camera, &GlobalTransform)>,
15    ground: Single<&GlobalTransform, With<Ground>>,
16    window: Single<&Window>,
17    mut gizmos: Gizmos,
18) {
19    let (camera, camera_transform) = *camera_query;
20
21    if let Some(cursor_position) = window.cursor_position()
22        // Calculate a ray pointing from the camera into the world based on the cursor's position.
23        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
24        // Calculate if and at what distance the ray is hitting the ground plane.
25        && let 
...
```

Example 3 (javascript):
```javascript
449fn handle_mouse_clicks(
450    buttons: Res<ButtonInput<MouseButton>>,
451    windows: Query<&Window, With<PrimaryWindow>>,
452    cameras: Query<(&Camera, &GlobalTransform)>,
453    mut main_objects: Query<&mut Transform, With<MainObject>>,
454) {
455    if !buttons.pressed(MouseButton::Left) {
456        return;
457    }
458    let Some(mouse_position) = windows.iter().next().and_then(Window::cursor_position) else {
459        return;
460    };
461    let Some((camera, camera_transform)) = cameras.iter().next() else {
462        return;
463    };
464
465    // Figure out where the user cl
...
```

Example 4 (javascript):
```javascript
let triangle_3d @ [a, b, c] = [Vec3::X, Vec3::Y, Vec3::Z];
let center = (a + b + c) / 3.0;

let plane = InfinitePlane3d::new(Vec3::ONE);

let (to_xy, from_xy) = plane.isometries_xy(center);

let triangle_2d = triangle_3d.map(|vec3| to_xy * vec3).map(|vec3| vec3.truncate());

// apply some algorithm to `triangle_2d`

let triangle_3d = triangle_2d.map(|vec2| vec2.extend(0.0)).map(|vec3| from_xy * vec3);
```

---

## Trait Bundle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Bundle.html

**Contents:**
- Trait Bundle Copy item path
  - §Insertion
  - §Removal
- §Implementers
- §Safety
- Required Methods§
    - fn get_component_ids( components: &Components, ids: &mut impl FnMut(Option<ComponentId>), )
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl Bundle for ()

The Bundle trait enables insertion and removal of Components from an entity.

Implementers of the Bundle trait are called ‘bundles’.

Each bundle represents a static set of Component types. Currently, bundles can only contain one of each Component, and will panic once initialized if this is not met.

The primary use for bundles is to add a useful collection of components to an entity.

Adding a value of bundle to an entity will add the components from the set it represents to the entity. The values of these components are taken from the bundle. If an entity already had one of these components, the entity’s original component value will be overwritten.

Importantly, bundles are only their constituent set of components. You should not use bundles as a unit of behavior. The behavior of your app can only be considered in terms of components, as systems, which drive the behavior of a bevy application, operate on combinations of components.

This rule is also important because multiple bundles may contain the same component type, calculated in different ways — adding both of these bundles to one entity would create incoherent behavior. This would be unexpected if bundles were treated as an abstraction boundary, as the abstraction would be unmaintainable for these cases.

For this reason, there is intentionally no Query to match whether an entity contains the components of a bundle. Queries should instead only select the components they logically operate on.

Bundles are also used when removing components from an entity.

Removing a bundle from an entity will remove any of its components attached to the entity from the entity. That is, if the entity does not have all the components of the bundle, those which are present will be removed.

Every type which implements Component also implements Bundle, since Component types can be added to or removed from an entity.

Additionally, Tuples of bundles are also Bundle (with up to 15 bundles). These bundles contain the items of the ‘inner’ bundles. This is a convenient shorthand which is primarily used when spawning entities.

unit, otherwise known as (), is a Bundle containing no components (since it can also be considered as the empty tuple). This can be useful for spawning large numbers of empty entities using World::spawn_batch.

Tuple bundles can be nested, which can be used to create an anonymous bundle with more than 15 items. However, in most cases where this is required, the derive macro Bundle should be used ins

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub unsafe trait Bundle:
    DynamicBundle
    + Send
    + Sync
    + 'static {
    // Required method
    fn get_component_ids(
        components: &Components,
        ids: &mut impl FnMut(Option<ComponentId>),
    );
}
```

Example 2 (unknown):
```unknown
use bevy_ecs::{component::Component, bundle::Bundle};

#[derive(Component)]
struct XPosition(i32);
#[derive(Component)]
struct YPosition(i32);

#[derive(Bundle)]
struct PositionBundle {
    // A bundle can contain components
    x: XPosition,
    y: YPosition,
}

// You have to implement `Default` for ignored field types in bundle structs.
#[derive(Default)]
struct Other(f32);

#[derive(Bundle)]
struct NamedPointBundle<T: Send + Sync + 'static> {
    // Or other bundles
    a: PositionBundle,
    // In addition to more components
    z: PointName,

    // when you need to use `PhantomData` you
...
```

---

## Trait StableInterpolate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.StableInterpolate.html

**Contents:**
- Trait StableInterpolate Copy item path
- Required Methods§
    - fn interpolate_stable(&self, other: &Self, t: f32) -> Self
- Provided Methods§
    - fn interpolate_stable_assign(&mut self, other: &Self, t: f32)
    - fn smooth_nudge(&mut self, target: &Self, decay_rate: f32, delta: f32)
      - §Example
      - Examples found in repository?
- Dyn Compatibility§
- Implementations on Foreign Types§

A type with a natural interpolation that provides strong subdivision guarantees.

Although the only required method is interpolate_stable, many things are expected of it:

The notion of interpolation should follow naturally from the semantics of the type, so that inferring the interpolation mode from the type alone is sensible.

The interpolation recovers something equivalent to the starting value at t = 0.0 and likewise with the ending value at t = 1.0. They do not have to be data-identical, but they should be semantically identical. For example, Quat::slerp doesn’t always yield its second rotation input exactly at t = 1.0, but it always returns an equivalent rotation.

Importantly, the interpolation must be subdivision-stable: for any interpolation curve between two (unnamed) values and any parameter-value pairs (t0, p) and (t1, q), the interpolation curve between p and q must be the linear reparameterization of the original interpolation curve restricted to the interval [t0, t1].

The last of these conditions is very strong and indicates something like constant speed. It is called “subdivision stability” because it guarantees that breaking up the interpolation into segments and joining them back together has no effect.

Here is a diagram depicting it:

Note that some common forms of interpolation do not satisfy this criterion. For example, Quat::lerp and Rot2::nlerp are not subdivision-stable.

Furthermore, this is not to be used as a general trait for abstract interpolation. Consumers rely on the strong guarantees in order for behavior based on this trait to be well-behaved.

Interpolate between this value and the other given value using the parameter t. At t = 0.0, a value equivalent to self is recovered, while t = 1.0 recovers a value equivalent to other, with intermediate values interpolating between the two. See the trait-level documentation for details.

A version of interpolate_stable that assigns the result to self for convenience.

Smoothly nudge this value towards the target at a given decay rate. The decay_rate parameter controls how fast the distance between self and target decays relative to the units of delta; the intended usage is for decay_rate to generally remain fixed, while delta is something like delta_time from an updating system. This produces a smooth following of the target that is independent of framerate.

More specifically, when this is called repeatedly, the result is that the distance between self and a fixed target attenuat

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait StableInterpolate: Clone {
    // Required method
    fn interpolate_stable(&self, other: &Self, t: f32) -> Self;

    // Provided methods
    fn interpolate_stable_assign(&mut self, other: &Self, t: f32) { ... }
    fn smooth_nudge(&mut self, target: &Self, decay_rate: f32, delta: f32) { ... }
}
```

Example 2 (text):
```text
top curve = u.interpolate_stable(v, t)

             t0 => p   t1 => q    
  |-------------|---------|-------------|
0 => u         /           \          1 => v
             /               \
           /                   \
         /        linear         \
       /     reparameterization    \
     /   t = t0 * (1 - s) + t1 * s   \
   /                                   \
  |-------------------------------------|
0 => p                                1 => q

bottom curve = p.interpolate_stable(q, s)
```

Example 3 (javascript):
```javascript
let mut object_position: Vec3 = Vec3::ZERO;
let target_position: Vec3 = Vec3::new(2.0, 3.0, 5.0);
// Decay rate of ln(10) => after 1 second, remaining distance is 1/10th
let decay_rate = f32::ln(10.0);
// Calling this repeatedly will move `object_position` towards `target_position`:
object_position.smooth_nudge(&target_position, decay_rate, delta_time);
```

Example 4 (javascript):
```javascript
140fn rotate_ship(ship: Single<(&mut Ship, &mut Transform)>, time: Res<Time>) {
141    let (mut ship, mut ship_transform) = ship.into_inner();
142
143    if !ship.in_motion {
144        return;
145    }
146
147    let target_rotation = ship.target_transform.rotation;
148
149    ship_transform
150        .rotation
151        .smooth_nudge(&target_rotation, 3.0, time.delta_secs());
152
153    if ship_transform.rotation.angle_between(target_rotation) <= f32::EPSILON {
154        ship.in_motion = false;
155    }
156}
```

---

## Trait ToString Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ToString.html

**Contents:**
- Trait ToString Copy item path
- Required Methods§
    - fn to_string(&self) -> String
      - §Examples
- Implementors§
  - impl ToString for Semantic
  - impl ToString for Checked<Semantic>
  - impl<T> ToString for Twhere T: Display + ?Sized,
    - §Panics

A trait for converting a value to a String.

This trait is automatically implemented for any type which implements the Display trait. As such, ToString shouldn’t be implemented directly: Display should be implemented instead, and you get the ToString implementation for free.

Converts the given value to a String.

In this implementation, the to_string method panics if the Display implementation returns an error. This indicates an incorrect Display implementation since fmt::Write for String never returns an error itself.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ToString {
    // Required method
    fn to_string(&self) -> String;
}
```

Example 2 (javascript):
```javascript
let i = 5;
let five = String::from("5");

assert_eq!(five, i.to_string());
```

---

## Struct DefaultGizmoConfigGroup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DefaultGizmoConfigGroup.html

**Contents:**
- Struct DefaultGizmoConfigGroup Copy item path
- Trait Implementations§
  - impl Default for DefaultGizmoConfigGroup
    - fn default() -> DefaultGizmoConfigGroup
  - impl FromArg for DefaultGizmoConfigGroup
    - type This<'from_arg> = DefaultGizmoConfigGroup
    - fn from_arg( arg: Arg<'_>, ) -> Result<<DefaultGizmoConfigGroup as FromArg>::This<'_>, ArgError>
  - impl FromReflect for DefaultGizmoConfigGroup
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<DefaultGizmoConfigGroup>
    - fn take_from_reflect( reflect: Box<dyn PartialReflect>, ) -> Result<Self, Box<dyn PartialReflect>>

The default gizmo config group.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DefaultGizmoConfigGroup;
```

---

## Trait IntoFunction Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.IntoFunction.html

**Contents:**
- Trait IntoFunction Copy item path
- §Trait Parameters
- Required Methods§
    - fn into_function(self) -> DynamicFunction<'env>
- Implementors§
  - impl<'env> IntoFunction<'env, ()> for DynamicFunction<'env>
  - impl<'env, F, Marker1, Marker2> IntoFunction<'env, (Marker1, Marker2)> for Fwhere F: ReflectFn<'env, Marker1> + TypedFunction<Marker2> + Send + Sync + 'env,

A trait for types that can be converted into a DynamicFunction.

This trait is automatically implemented for any type that implements ReflectFn and TypedFunction.

See the module-level documentation for more information.

This trait has a Marker type parameter that is used to get around issues with unconstrained type parameters when defining impls with generic arguments or return types. This Marker can be any type, provided it doesn’t conflict with other implementations.

Additionally, it has a lifetime parameter, 'env, that is used to bound the lifetime of the function. For named functions and some closures, this will end up just being 'static, however, closures that borrow from their environment will have a lifetime bound to that environment.

Converts Self into a DynamicFunction.

**Examples:**

Example 1 (unknown):
```unknown
pub trait IntoFunction<'env, Marker> {
    // Required method
    fn into_function(self) -> DynamicFunction<'env>;
}
```

---

## Enum JustifyContent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.JustifyContent.html

**Contents:**
- Enum JustifyContent Copy item path
- Variants§
  - Default
  - Start
  - End
  - FlexStart
  - FlexEnd
  - Center
  - Stretch
  - SpaceBetween

Used to control how items are distributed.

https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content

The items are packed in their default position as if no alignment was applied.

The items are packed towards the start of the axis.

The items are packed towards the end of the axis.

The items are packed towards the start of the axis, unless the flex direction is reversed; then the items are packed towards the end of the axis.

The items are packed towards the end of the axis, unless the flex direction is reversed; then the items are packed towards the start of the axis.

The items are packed along the center of the axis.

The items are stretched to fill the container along the axis.

The items are distributed such that the gap between any two items is equal.

The items are distributed such that the gap between and around any two items is equal.

The items are distributed such that the gap between and around any two items is equal, with half-size gaps on either end.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum JustifyContent {
    Default,
    Start,
    End,
    FlexStart,
    FlexEnd,
    Center,
    Stretch,
    SpaceBetween,
    SpaceEvenly,
    SpaceAround,
}
```

---

## Struct TransitionSchedules Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TransitionSchedules.html

**Contents:**
- Struct TransitionSchedules Copy item path
- Trait Implementations§
  - impl<S> Clone for TransitionSchedules<S>where S: Clone + States,
    - fn clone(&self) -> TransitionSchedules<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for TransitionSchedules<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Default for TransitionSchedules<S>where S: States,
    - fn default() -> TransitionSchedules<S>
  - impl<S> Hash for TransitionSchedules<S>where S: Hash + States,

System set that runs transition schedule(s) for state S.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TransitionSchedules<S>(/* private fields */)
where
    S: States;
```

---

## Struct FixedPreUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedPreUpdate.html

**Contents:**
- Struct FixedPreUpdate Copy item path
- Trait Implementations§
  - impl Clone for FixedPreUpdate
    - fn clone(&self) -> FixedPreUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedPreUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedPreUpdate
    - fn default() -> FixedPreUpdate
  - impl Hash for FixedPreUpdate

The schedule that contains logic that must run before FixedUpdate.

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedPreUpdate;
```

---

## Trait CommandsStatesExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.CommandsStatesExt.html

**Contents:**
- Trait CommandsStatesExt Copy item path
- Required Methods§
    - fn set_state<S>(&mut self, state: S)where S: FreelyMutableState,
- Dyn Compatibility§
- Implementors§
  - impl CommandsStatesExt for Commands<'_, '_>

Extension trait for Commands adding bevy_state helpers.

Sets the next state the app should move to.

Internally this schedules a command that updates the NextState<S> resource with state.

Note that commands introduce sync points to the ECS schedule, so modifying NextState directly may be more efficient depending on your use-case.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait CommandsStatesExt {
    // Required method
    fn set_state<S>(&mut self, state: S)
       where S: FreelyMutableState;
}
```

---

## Module sample_curves Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/sample_curves/index.html

**Contents:**
- Module sample_curves Copy item path
- Structs§

Sample-interpolated curves constructed using the Curve API.

---

## Struct PointerTraversal Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PointerTraversal.html

**Contents:**
- Struct PointerTraversal Copy item path
- Trait Implementations§
  - impl QueryData for PointerTraversal
    - unsafe fn fetch<'__w, '__s>( _state: &'__s <PointerTraversal as WorldQuery>::State, _fetch: &mut <PointerTraversal as WorldQuery>::Fetch<'__w>, _entity: Entity, _table_row: TableRow, ) -> <PointerTraversal as QueryData>::Item<'__w, '__s>
    - const IS_READ_ONLY: bool = true
    - type ReadOnly = PointerTraversal
    - type Item<'__w, '__s> = PointerTraversalItem<'__w, '__s>
    - fn shrink<'__wlong, '__wshort, '__s>( item: <PointerTraversal as QueryData>::Item<'__wlong, '__s>, ) -> <PointerTraversal as QueryData>::Item<'__wshort, '__s>where '__wlong: '__wshort,
    - fn provide_extra_access( state: &mut <PointerTraversal as WorldQuery>::State, access: &mut Access, available_access: &Access, )
  - impl ReleaseStateQueryData for PointerTraversalwhere Option<&'static ChildOf>: for<'__a> ReleaseStateQueryData, Option<&'static Window>: for<'__a> ReleaseStateQueryData,

A traversal query (i.e. it implements Traversal) intended for use with Pointer events.

This will always traverse to the parent, if the entity being visited has one. Otherwise, it propagates to the pointer’s window and stops there.

SAFETY: we assert fields are readonly below

SAFETY: we call fetch for each member that implements Fetch.

SAFETY: we call set_archetype for each member that implements Fetch

SAFETY: we call set_table for each member that implements Fetch

SAFETY: we assert fields are readonly below

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PointerTraversal { /* private fields */ }
```

---

## Struct MessageWriter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MessageWriter.html

**Contents:**
- Struct MessageWriter Copy item path
- §Usage
- §Concurrency
- §Untyped messages
- Implementations§
  - impl<'w, E> MessageWriter<'w, E>where E: Message,
    - pub fn write(&mut self, message: E) -> MessageId<E>
      - Examples found in repository?
    - pub fn write_batch( &mut self, messages: impl IntoIterator<Item = E>, ) -> WriteBatchIds<E> ⓘ
      - Examples found in repository?

Writes Messages of type T.

MessageWriters are usually declared as a SystemParam.

MessageWriter param has ResMut<Messages<T>> inside. So two systems declaring MessageWriter<T> params for the same message type won’t be executed concurrently.

MessageWriter can only write messages of one specific type, which must be known at compile-time. This is not a problem most of the time, but you may find a situation where you cannot know ahead of time every kind of message you’ll need to write. In this case, you can use the “type-erased message” pattern.

Note that this is considered non-idiomatic, and should only be used when MessageWriter will not work.

Writes an message, which can later be read by MessageReaders. This method returns the ID of the written message.

See Messages for details.

Writes a list of messages all at once, which can later be read by MessageReaders. This is more efficient than writing each message individually. This method returns the IDs of the written messages.

See Messages for details.

Writes the default value of the message. Useful when the message is an empty struct. This method returns the ID of the written message.

See Messages for details.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MessageWriter<'w, E>where
    E: Message,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
#[derive(Message)]
pub struct MyMessage; // Custom message type.
fn my_system(mut writer: MessageWriter<MyMessage>) {
    writer.write(MyMessage);
}
```

Example 3 (unknown):
```unknown
fn write_untyped(mut commands: Commands) {
    // Write a message of a specific type without having to declare that
    // type as a SystemParam.
    //
    // Effectively, we're just moving the type parameter from the /type/ to the /method/,
    // which allows one to do all kinds of clever things with type erasure, such as sending
    // custom messages to unknown 3rd party plugins (modding API).
    //
    // NOTE: the message won't actually be sent until commands get applied during
    // apply_deferred.
    commands.queue(|w: &mut World| {
        w.write_message(MyMessage);
    });
}
```

Example 4 (javascript):
```javascript
59fn read_and_write_different_message_types(mut a: MessageWriter<A>, mut b: MessageReader<B>) {
60    for _ in b.read() {}
61    a.write(A);
62}
63
64/// A dummy message type.
65#[derive(Debug, Clone, Message)]
66struct DebugMessage {
67    resend_from_param_set: bool,
68    resend_from_local_message_reader: bool,
69    times_sent: u8,
70}
71
72/// A system that sends all combinations of messages.
73fn send_messages(mut debug_messages: MessageWriter<DebugMessage>, frame_count: Res<FrameCount>) {
74    println!("Sending messages for frame {}", frame_count.0);
75
76    debug_messages.write(Debug
...
```

---

## Struct FixedMain Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedMain.html

**Contents:**
- Struct FixedMain Copy item path
- Implementations§
  - impl FixedMain
    - pub fn run_fixed_main(world: &mut World)
- Trait Implementations§
  - impl Clone for FixedMain
    - fn clone(&self) -> FixedMain
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedMain
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

The schedule that contains systems which only run after a fixed period of time has elapsed.

This is run by the RunFixedMainLoop schedule. If you need to order your variable timestep systems before or after the fixed update logic, use the RunFixedMainLoopSystems system set.

Frequency of execution is configured by inserting Time<Fixed> resource, 64 Hz by default. See this example.

See the Main schedule for some details about how schedules are run.

A system that runs the fixed timestep’s “main schedule”

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedMain;
```

---

## Function percent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.percent.html

**Contents:**
- Function percent Copy item path
      - Examples found in repository?

Returns a Val::Percent representing a percentage of the parent node’s length along a specific axis.

If the UI node has no parent, the percentage is based on the window’s length along that axis.

**Examples:**

Example 1 (unknown):
```unknown
pub fn percent<T>(value: T) -> Valwhere
    T: ValNum,
```

Example 2 (javascript):
```javascript
50    fn update(&self, t: f32, transform: &mut UiTransform) {
51        transform.translation.x = percent(ops::sin(t * TAU - FRAC_PI_2) * 50.);
52        transform.translation.y = percent(-ops::cos(t * TAU - FRAC_PI_2) * 50.);
53    }
54}
55
56#[derive(Component)]
57struct Scale;
58
59impl UpdateTransform for Scale {
60    fn update(&self, t: f32, transform: &mut UiTransform) {
61        transform.scale.x = 1.0 + 0.5 * ops::cos(t * TAU).max(0.0);
62        transform.scale.y = 1.0 + 0.5 * ops::cos(t * TAU + PI).max(0.0);
63    }
64}
65
66#[derive(Component)]
67struct Rotate;
68
69impl UpdateTra
...
```

Example 3 (unknown):
```unknown
35fn setup_ui(mut commands: Commands) {
36    // Node that fills entire background
37    commands
38        .spawn(Node {
39            width: percent(100),
40            ..default()
41        })
42        // Text where we display current resolution
43        .with_child((
44            Text::new("Resolution"),
45            TextFont {
46                font_size: 42.0,
47                ..default()
48            },
49            ResolutionText,
50        ));
51}
```

Example 4 (unknown):
```unknown
391fn display_score(mut commands: Commands, game: Res<Game>) {
392    commands.spawn((
393        DespawnOnExit(GameState::GameOver),
394        Node {
395            width: percent(100),
396            align_items: AlignItems::Center,
397            justify_content: JustifyContent::Center,
398            ..default()
399        },
400        children![(
401            Text::new(format!("Cake eaten: {}", game.cake_eaten)),
402            TextFont {
403                font_size: 67.0,
404                ..default()
405            },
406            TextColor(Color::srgb(0.5, 0.5, 1.0)),
407      
...
```

---

## Enum Display Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Display.html

**Contents:**
- Enum Display Copy item path
- Variants§
  - Flex
  - Grid
  - Block
  - None
- Implementations§
  - impl Display
    - pub const DEFAULT: Display = Self::Flex
- Trait Implementations§

Defines the layout model used by this node.

Part of the Node component.

Use Flexbox layout model to determine the position of this Node’s children.

Use CSS Grid layout model to determine the position of this Node’s children.

Use CSS Block layout model to determine the position of this Node’s children.

Use no layout, don’t render this node and its children.

If you want to hide a node and its children, but keep its layout in place, set its Visibility component instead.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Display {
    Flex,
    Grid,
    Block,
    None,
}
```

---

## Struct Fixed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Fixed.html

**Contents:**
- Struct Fixed Copy item path
- Trait Implementations§
  - impl Clone for Fixed
    - fn clone(&self) -> Fixed
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Fixed
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Fixed
    - fn default() -> Fixed
  - impl FromArg for Fixed

The fixed timestep game clock following virtual time.

A specialization of the Time structure. For method documentation, see Time<Fixed>.

It is automatically inserted as a resource by TimePlugin and updated based on Time<Virtual>. The fixed clock is automatically set as the generic Time resource during FixedUpdate schedule processing.

The fixed timestep clock advances in fixed-size increments, which is extremely useful for writing logic (like physics) that should have consistent behavior, regardless of framerate.

The default timestep() is 64 hertz, or 15625 microseconds. This value was chosen because using 60 hertz has the potential for a pathological interaction with the monitor refresh rate where the game alternates between running two fixed timesteps and zero fixed timesteps per frame (for example when running two fixed timesteps takes longer than a frame). Additionally, the value is a power of two which losslessly converts into f32 and f64.

To run a system on a fixed timestep, add it to one of the FixedMain schedules, most commonly FixedUpdate.

This schedule is run a number of times between PreUpdate and Update according to the accumulated overstep() time divided by the timestep(). This means the schedule may run 0, 1 or more times during a single update (which typically corresponds to a rendered frame).

Time<Fixed> and the generic Time resource will report a delta() equal to timestep() and always grow elapsed() by one timestep() per iteration.

The fixed timestep clock follows the Time<Virtual> clock, which means it is affected by pause(), set_relative_speed() and set_max_delta() from virtual time. If the virtual clock is paused, the FixedUpdate schedule will not run. It is guaranteed that the elapsed() time in Time<Fixed> is always between the previous elapsed() and the current elapsed() value in Time<Virtual>, so the values are compatible.

Changing the timestep size while the game is running should not normally be done, as having a regular interval is the point of this schedule, but it may be necessary for effects like “bullet-time” if the normal granularity of the fixed timestep is too big for the slowed down time. In this case, set_timestep() and be called to set a new value. The new value will be used immediately for the next run of the FixedUpdate schedule, meaning that it will affect the delta() value for the very next FixedUpdate, even if it is still during the same frame. Any overstep() present in the accumulator will be processed acco

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Fixed { /* private fields */ }
```

---

## Function any_with_component Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.any_with_component.html

**Contents:**
- Function any_with_component Copy item path
- §Example

A SystemCondition-satisfying system that returns true if there are any entities with the given component type.

**Examples:**

Example 1 (unknown):
```unknown
pub fn any_with_component<T>(query: Query<'_, '_, (), With<T>>) -> boolwhere
    T: Component,
```

Example 2 (unknown):
```unknown
app.add_systems(
    my_system.run_if(any_with_component::<MyComponent>),
);

#[derive(Component)]
struct MyComponent;

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// No entities exist yet with a `MyComponent` component so `my_system` won't run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 0);

world.spawn(MyComponent);

// An entities with `MyComponent` now exists so `my_system` will run
app.run(&mut world);
assert_eq!(world.resource::<Counter>().0, 1);
```

---

## Struct Gltf Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Gltf.html

**Contents:**
- Struct Gltf Copy item path
- Fields§
- Trait Implementations§
  - impl Debug for Gltf
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl TypePath for Gltf
    - fn type_path() -> &'static str
    - fn short_type_path() -> &'static str
    - fn type_ident() -> Option<&'static str>
    - fn crate_name() -> Option<&'static str>

Representation of a loaded glTF file.

All scenes loaded from the glTF file.

Named scenes loaded from the glTF file.

All meshes loaded from the glTF file.

Named meshes loaded from the glTF file.

All materials loaded from the glTF file.

Named materials loaded from the glTF file.

All nodes loaded from the glTF file.

Named nodes loaded from the glTF file.

All skins loaded from the glTF file.

Named skins loaded from the glTF file.

Default scene to be displayed.

All animations loaded from the glTF file.

Named animations loaded from the glTF file.

The gltf root of the gltf asset, see https://docs.rs/gltf/latest/gltf/struct.Gltf.html. Only has a value when GltfLoaderSettings::include_source is true.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Gltf {Show 14 fields
    pub scenes: Vec<Handle<Scene>>,
    pub named_scenes: HashMap<Box<str>, Handle<Scene>>,
    pub meshes: Vec<Handle<GltfMesh>>,
    pub named_meshes: HashMap<Box<str>, Handle<GltfMesh>>,
    pub materials: Vec<Handle<StandardMaterial>>,
    pub named_materials: HashMap<Box<str>, Handle<StandardMaterial>>,
    pub nodes: Vec<Handle<GltfNode>>,
    pub named_nodes: HashMap<Box<str>, Handle<GltfNode>>,
    pub skins: Vec<Handle<GltfSkin>>,
    pub named_skins: HashMap<Box<str>, Handle<GltfSkin>>,
    pub default_scene: Option<Handle<Scene>>,
    pub animations: 
...
```

---

## Enum SceneFilter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.SceneFilter.html

**Contents:**
- Enum SceneFilter Copy item path
- Variants§
  - Unset
  - Allowlist(HashSet<TypeId>)
  - Denylist(HashSet<TypeId>)
- Implementations§
  - impl SceneFilter
    - pub fn allow_all() -> SceneFilter
    - pub fn deny_all() -> SceneFilter
    - pub fn allow<T>(self) -> SceneFilterwhere T: Any,

A filter used to control which types can be added to a DynamicScene.

This scene filter can be used more generically to represent a filter for any given type; however, note that its intended usage with DynamicScene only considers components and resources. Adding types that are not a component or resource will have no effect when used with DynamicScene.

Represents an unset filter.

This is the equivalent of an empty Denylist or an Allowlist containing every type— essentially, all types are permissible.

Allowing a type will convert this filter to an Allowlist. Similarly, denying a type will convert this filter to a Denylist.

Contains the set of permitted types by their TypeId.

Types not contained within this set should not be allowed to be saved to an associated DynamicScene.

Contains the set of prohibited types by their TypeId.

Types contained within this set should not be allowed to be saved to an associated DynamicScene.

Creates a filter where all types are allowed.

This is the equivalent of creating an empty Denylist.

Creates a filter where all types are denied.

This is the equivalent of creating an empty Allowlist.

Allow the given type, T.

If this filter is already set as a Denylist, then the given type will be removed from the denied set.

If this filter is Unset, then it will be completely replaced by a new Allowlist.

Allow the given type.

If this filter is already set as a Denylist, then the given type will be removed from the denied set.

If this filter is Unset, then it will be completely replaced by a new Allowlist.

Deny the given type, T.

If this filter is already set as an Allowlist, then the given type will be removed from the allowed set.

If this filter is Unset, then it will be completely replaced by a new Denylist.

If this filter is already set as an Allowlist, then the given type will be removed from the allowed set.

If this filter is Unset, then it will be completely replaced by a new Denylist.

Returns true if the given type, T, is allowed by the filter.

If the filter is Unset, this will always return true.

Returns true if the given type is allowed by the filter.

If the filter is Unset, this will always return true.

Returns true if the given type, T, is denied by the filter.

If the filter is Unset, this will always return false.

Returns true if the given type is denied by the filter.

If the filter is Unset, this will always return false.

Returns an iterator over the items in the filter.

If the filter is Unset, 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub enum SceneFilter {
    Unset,
    Allowlist(HashSet<TypeId>),
    Denylist(HashSet<TypeId>),
}
```

---

## Trait MeshBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.MeshBuilder.html

**Contents:**
- Trait MeshBuilder Copy item path
- Required Methods§
    - fn build(&self) -> Mesh
- Implementors§
  - impl MeshBuilder for AnnulusMeshBuilder
  - impl MeshBuilder for Capsule2dMeshBuilder
  - impl MeshBuilder for Capsule3dMeshBuilder
  - impl MeshBuilder for CircleMeshBuilder
  - impl MeshBuilder for CircularSectorMeshBuilder
  - impl MeshBuilder for CircularSegmentMeshBuilder

A trait used to build Meshes from a configuration

Builds a Mesh based on the configuration in self.

**Examples:**

Example 1 (unknown):
```unknown
pub trait MeshBuilder {
    // Required method
    fn build(&self) -> Mesh;
}
```

---

## Struct GlobalVolume Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GlobalVolume.html

**Contents:**
- Struct GlobalVolume Copy item path
- Fields§
- Implementations§
  - impl GlobalVolume
    - pub fn new(volume: Volume) -> GlobalVolume
- Trait Implementations§
  - impl Clone for GlobalVolume
    - fn clone(&self) -> GlobalVolume
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for GlobalVolume

Use this Resource to control the global volume of all audio.

Note: Changing GlobalVolume does not affect already playing audio.

The global volume of all audio.

Create a new GlobalVolume with the given volume.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GlobalVolume {
    pub volume: Volume,
}
```

---

## Enum AppLifecycle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/window/enum.AppLifecycle.html

**Contents:**
- Enum AppLifecycle Copy item path
- Variants§
  - Idle
  - Running
  - WillSuspend
  - Suspended
  - WillResume
- Implementations§
  - impl AppLifecycle
    - pub fn is_active(&self) -> bool

Application lifetime events

The application is not started yet.

The application is running.

The application is going to be suspended. Applications have one frame to react to this event before being paused in the background.

The application was suspended.

The application is going to be resumed. Applications have one extra frame to react to this event before being fully resumed.

Return true if the app can be updated.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AppLifecycle {
    Idle,
    Running,
    WillSuspend,
    Suspended,
    WillResume,
}
```

---

## Type Alias Trigger Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.Trigger.html

**Contents:**
- Type Alias Trigger Copy item path
- Aliased Type§

Deprecated in favor of On.

**Examples:**

Example 1 (unknown):
```unknown
pub type Trigger<'w, 't, E, B = ()> = On<'w, 't, E, B>;
```

Example 2 (unknown):
```unknown
pub struct Trigger<'w, 't, E, B = ()> { /* private fields */ }
```

---

## Trait SubStates Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SubStates.html

**Contents:**
- Trait SubStates Copy item path
- Required Associated Types§
    - type SourceStates: StateSet
- Required Methods§
    - fn should_exist(sources: Self::SourceStates) -> Option<Self>
- Provided Methods§
    - fn register_sub_state_systems(schedule: &mut Schedule)
- Dyn Compatibility§
- Implementors§

A sub-state is a state that exists only when the source state meet certain conditions, but unlike ComputedStates - while they exist they can be manually modified.

The default approach to creating SubStates is using the derive macro, and defining a single source state and value to determine its existence.

you can then add it to an App, and from there you use the state as normal:

In more complex situations, the recommendation is to use an intermediary computed state, like so:

However, you can also manually implement them. If you do so, you’ll also need to manually implement the States & FreelyMutableState traits.

The set of states from which the Self is derived.

This can either be a single type that implements States, or a tuple containing multiple types that implement States, or any combination of types implementing States and Options of types implementing States.

This function gets called whenever one of the SourceStates changes. The result is used to determine the existence of State<Self>.

If the result is None, the State<Self> resource will be removed from the world, otherwise if the State<Self> resource doesn’t exist it will be created from the returned Some as the initial state.

Value within Some is ignored if the state already exists in the world and only symbolizes that the state should still exist.

Initial value can also be overwritten by NextState.

This function sets up systems that compute the state whenever one of the SourceStates change. It is called by App::add_computed_state, but can be called manually if App is not used.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait SubStates: States + FreelyMutableState {
    type SourceStates: StateSet;

    // Required method
    fn should_exist(sources: Self::SourceStates) -> Option<Self>;

    // Provided method
    fn register_sub_state_systems(schedule: &mut Schedule) { ... }
}
```

Example 2 (unknown):
```unknown
#[derive(States, Clone, PartialEq, Eq, Hash, Debug, Default)]
enum AppState {
    #[default]
    Menu,
    InGame
}


#[derive(SubStates, Clone, PartialEq, Eq, Hash, Debug, Default)]
#[source(AppState = AppState::InGame)]
enum GamePhase {
    #[default]
    Setup,
    Battle,
    Conclusion
}
```

Example 3 (unknown):
```unknown
App::new()
        .init_state::<AppState>()
        .add_sub_state::<GamePhase>();
```

Example 4 (javascript):
```javascript
/// Computed States require some state to derive from
#[derive(States, Clone, PartialEq, Eq, Hash, Debug, Default)]
enum AppState {
    #[default]
    Menu,
    InGame { paused: bool }
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
struct InGame;

impl ComputedStates for InGame {
    /// We set the source state to be the state, or set of states,
    /// we want to depend on. Any of the states can be wrapped in an Option.
    type SourceStates = Option<AppState>;

    /// We then define the compute function, which takes in the AppState
    fn compute(sources: Option<AppState>) -> Option<Self> 
...
```

---

## Type Alias AnimationMask Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.AnimationMask.html

**Contents:**
- Type Alias AnimationMask Copy item path

The type of an animation mask bitfield.

Bit N corresponds to mask group N.

Because this is a 64-bit value, there is currently a limitation of 64 mask groups per animation graph.

**Examples:**

Example 1 (unknown):
```unknown
pub type AnimationMask = u64;
```

---

## Struct Pitch Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Pitch.html

**Contents:**
- Struct Pitch Copy item path
- Fields§
- Implementations§
  - impl Pitch
    - pub fn new(frequency: f32, duration: Duration) -> Pitch
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for Pitch
    - fn clone(&self) -> Pitch
    - fn clone_from(&mut self, source: &Self)

A source of sine wave sound

Frequency at which sound will be played

Duration for which sound will be played

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Pitch {
    pub frequency: f32,
    pub duration: Duration,
}
```

Example 2 (unknown):
```unknown
25fn play_pitch(
26    mut pitch_assets: ResMut<Assets<Pitch>>,
27    frequency: Res<PitchFrequency>,
28    mut play_pitch_reader: MessageReader<PlayPitch>,
29    mut commands: Commands,
30) {
31    for _ in play_pitch_reader.read() {
32        info!("playing pitch with frequency: {}", frequency.0);
33        commands.spawn((
34            AudioPlayer(pitch_assets.add(Pitch::new(frequency.0, Duration::new(1, 0)))),
35            PlaybackSettings::DESPAWN,
36        ));
37        info!("number of pitch assets: {}", pitch_assets.len());
38    }
39}
```

---

## Struct ComponentHooks Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/ecs/lifecycle/struct.ComponentHooks.html

**Contents:**
- Struct ComponentHooks Copy item path
- §Example
- Implementations§
  - impl ComponentHooks
    - pub fn on_add( &mut self, hook: for<'w> fn(DeferredWorld<'w>, HookContext), ) -> &mut ComponentHooks
      - §Panics
      - Examples found in repository?
    - pub fn on_insert( &mut self, hook: for<'w> fn(DeferredWorld<'w>, HookContext), ) -> &mut ComponentHooks
      - §Warning
      - §Panics

World-mutating functions that run as part of lifecycle events of a Component.

Hooks are functions that run when a component is added, overwritten, or removed from an entity. These are intended to be used for structural side effects that need to happen when a component is added or removed, and are not intended for general-purpose logic.

For example, you might use a hook to update a cached index when a component is added, to clean up resources when a component is removed, or to keep hierarchical data structures across entities in sync.

This information is stored in the ComponentInfo of the associated component.

There are two ways of configuring hooks for a component:

Register a ComponentHook that will be run when this component is added to an entity. An on_add hook will always run before on_insert hooks. Spawning an entity counts as adding all of its components.

Will panic if the component already has an on_add hook

Register a ComponentHook that will be run when this component is added (with .insert) or replaced.

An on_insert hook always runs after any on_add hooks (if the entity didn’t already have the component).

The hook won’t run if the component is already present and is only mutated, such as in a system via a query. As a result, this needs to be combined with immutable components to serve as a mechanism for reliably updating indexes and other caches.

Will panic if the component already has an on_insert hook

Register a ComponentHook that will be run when this component is about to be dropped, such as being replaced (with .insert) or removed.

If this component is inserted onto an entity that already has it, this hook will run before the value is replaced, allowing access to the previous data just before it is dropped. This hook does not run if the entity did not already have this component.

An on_replace hook always runs before any on_remove hooks (if the component is being removed from the entity).

The hook won’t run if the component is already present and is only mutated, such as in a system via a query. As a result, this needs to be combined with immutable components to serve as a mechanism for reliably updating indexes and other caches.

Will panic if the component already has an on_replace hook

Register a ComponentHook that will be run when this component is removed from an entity. Despawning an entity counts as removing all of its components.

Will panic if the component already has an on_remove hook

Register a ComponentHook that wi

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct ComponentHooks { /* private fields */ }
```

Example 2 (javascript):
```javascript
use bevy_ecs::prelude::*;
use bevy_platform::collections::HashSet;

#[derive(Component)]
struct MyTrackedComponent;

#[derive(Resource, Default)]
struct TrackedEntities(HashSet<Entity>);

let mut world = World::new();
world.init_resource::<TrackedEntities>();

// No entities with `MyTrackedComponent` have been added yet, so we can safely add component hooks
let mut tracked_component_query = world.query::<&MyTrackedComponent>();
assert!(tracked_component_query.iter(&world).next().is_none());

world.register_component_hooks::<MyTrackedComponent>().on_add(|mut world, context| {
   let mut tracked
...
```

Example 3 (javascript):
```javascript
61fn setup(world: &mut World) {
62    // In order to register component hooks the component must:
63    // - not be currently in use by any entities in the world
64    // - not already have a hook of that kind registered
65    // This is to prevent overriding hooks defined in plugins and other crates as well as keeping things fast
66    world
67        .register_component_hooks::<MyComponent>()
68        // There are 4 component lifecycle hooks: `on_add`, `on_insert`, `on_replace` and `on_remove`
69        // A hook has 2 arguments:
70        // - a `DeferredWorld`, this allows access to resou
...
```

Example 4 (javascript):
```javascript
61fn setup(world: &mut World) {
62    // In order to register component hooks the component must:
63    // - not be currently in use by any entities in the world
64    // - not already have a hook of that kind registered
65    // This is to prevent overriding hooks defined in plugins and other crates as well as keeping things fast
66    world
67        .register_component_hooks::<MyComponent>()
68        // There are 4 component lifecycle hooks: `on_add`, `on_insert`, `on_replace` and `on_remove`
69        // A hook has 2 arguments:
70        // - a `DeferredWorld`, this allows access to resou
...
```

---

## Struct Dir3A Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Dir3A.html

**Contents:**
- Struct Dir3A Copy item path
- Implementations§
  - impl Dir3A
    - pub const X: Dir3A
    - pub const Y: Dir3A
    - pub const Z: Dir3A
    - pub const NEG_X: Dir3A
    - pub const NEG_Y: Dir3A
    - pub const NEG_Z: Dir3A
    - pub const AXES: [Dir3A; 3]

A normalized SIMD vector pointing in a direction in 3D space.

This type stores a 16 byte aligned Vec3A. This may or may not be faster than Dir3: make sure to benchmark!

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

The directional axes.

Create a direction from a finite, nonzero Vec3A, normalizing it.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Create a Dir3A from a Vec3A that is already normalized.

value must be normalized, i.e its length must be 1.0.

Create a direction from a finite, nonzero Vec3A, normalizing it and also returning its original length.

Returns Err(InvalidDirectionError) if the length of the given vector is zero (or very close to zero), infinite, or NaN.

Create a direction from its x, y, and z components.

Returns Err(InvalidDirectionError) if the length of the vector formed by the components is zero (or very close to zero), infinite, or NaN.

Create a direction from its x, y, and z components, assuming the resulting vector is normalized.

The vector produced from x, y, and z must be normalized, i.e its length must be 1.0.

Returns the inner Vec3A

Performs a spherical linear interpolation between self and rhs based on the value s.

This corresponds to interpolating between the two directions at a constant angular velocity.

When s == 0.0, the result will be equal to self. When s == 1.0, the result will be equal to rhs.

Returns self after an approximate normalization, assuming the value is already nearly normalized. Useful for preventing numerical error accumulation.

See Dir3::fast_renormalize for an example of when such error accumulation might occur.

Converts self to [x, y, z]

Moves towards rhs based on the value d.

When d is 0.0, the result will be equal to self. When d is equal to self.distance(rhs), the result will be equal to rhs. Will not go past rhs.

Returns some vector that is orthogonal to the given one.

The input vector must be finite and non-zero.

The output vector is not necessarily unit length. For that use Self::any_orthonormal_vector() instead.

Returns any unit vector that is orthogonal to the given one.

The input vector must be unit length.

Will panic if self is not normali

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Dir3A(/* private fields */);
```

Example 2 (javascript):
```javascript
let dir1 = Dir3A::X;
let dir2 = Dir3A::Y;

let result1 = dir1.slerp(dir2, 1.0 / 3.0);
#[cfg(feature = "approx")]
assert_relative_eq!(
    result1,
    Dir3A::from_xyz(0.75_f32.sqrt(), 0.5, 0.0).unwrap(),
    epsilon = 0.000001
);

let result2 = dir1.slerp(dir2, 0.5);
#[cfg(feature = "approx")]
assert_relative_eq!(result2, Dir3A::from_xyz(0.5_f32.sqrt(), 0.5_f32.sqrt(), 0.0).unwrap());
```

---

## Enum OverflowClipBox Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.OverflowClipBox.html

**Contents:**
- Enum OverflowClipBox Copy item path
- Variants§
  - ContentBox
  - PaddingBox
  - BorderBox
- Trait Implementations§
  - impl Clone for OverflowClipBox
    - fn clone(&self) -> OverflowClipBox
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for OverflowClipBox

Used to determine the bounds of the visible area when a UI node is clipped.

Clip any content that overflows outside the content box

Clip any content that overflows outside the padding box

Clip any content that overflows outside the border box

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum OverflowClipBox {
    ContentBox,
    PaddingBox,
    BorderBox,
}
```

---

## Struct Touches Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Touches.html

**Contents:**
- Struct Touches Copy item path
  - §Usage
  - §Updating
- Implementations§
  - impl Touches
    - pub fn iter(&self) -> impl Iterator<Item = &Touch>
      - Examples found in repository?
    - pub fn get_pressed(&self, id: u64) -> Option<&Touch>
    - pub fn any_just_pressed(&self) -> bool
      - Examples found in repository?

A collection of Touches.

It is used to create a bevy resource that stores the data of the touches on a touchscreen and can be accessed inside of a system.

The resource is updated inside of the touch_screen_input_system.

An iterator visiting every pressed Touch input in arbitrary order.

Returns the Touch input corresponding to the id if it is being pressed.

Checks if any touch input was just pressed.

Register a release for a given touch input.

Registers a release for all currently pressed touch inputs.

Returns true if the input corresponding to the id has just been pressed.

Clears the just_pressed state of the touch input and returns true if the touch input has just been pressed.

Future calls to Touches::just_pressed for the given touch input will return false until a new press event occurs.

An iterator visiting every just pressed Touch input in arbitrary order.

Returns the Touch input corresponding to the id if it has just been released.

Checks if any touch input was just released.

Returns true if the input corresponding to the id has just been released.

Clears the just_released state of the touch input and returns true if the touch input has just been released.

Future calls to Touches::just_released for the given touch input will return false until a new release event occurs.

An iterator visiting every just released Touch input in arbitrary order.

Checks if any touch input was just canceled.

Returns true if the input corresponding to the id has just been canceled.

Clears the just_canceled state of the touch input and returns true if the touch input has just been canceled.

Future calls to Touches::just_canceled for the given touch input will return false until a new cancel event occurs.

An iterator visiting every just canceled Touch input in arbitrary order.

Retrieves the position of the first currently pressed touch, if any

Clears just_pressed, just_released, and just_canceled data for every touch input.

See also Touches::reset_all for a full reset.

Clears pressed, just_pressed, just_released, and just_canceled data for every touch input.

See also Touches::clear for clearing only touches that have just been pressed, released or canceled.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Touches { /* private fields */ }
```

Example 2 (unknown):
```unknown
12fn touch_system(touches: Res<Touches>) {
13    for touch in touches.iter_just_pressed() {
14        info!(
15            "just pressed touch with id: {}, at: {}",
16            touch.id(),
17            touch.position()
18        );
19    }
20
21    for touch in touches.iter_just_released() {
22        info!(
23            "just released touch with id: {}, at: {}",
24            touch.id(),
25            touch.position()
26        );
27    }
28
29    for touch in touches.iter_just_canceled() {
30        info!("canceled touch with id: {}", touch.id());
31    }
32
33    // you can also iterate
...
```

Example 3 (unknown):
```unknown
66fn has_user_input(
67    keyboard_input: Res<ButtonInput<KeyCode>>,
68    mouse_button_input: Res<ButtonInput<MouseButton>>,
69    touch_input: Res<Touches>,
70) -> bool {
71    keyboard_input.just_pressed(KeyCode::Space)
72        || keyboard_input.just_pressed(KeyCode::Enter)
73        || mouse_button_input.just_pressed(MouseButton::Left)
74        || mouse_button_input.just_pressed(MouseButton::Right)
75        || touch_input.any_just_pressed()
76}
```

Example 4 (unknown):
```unknown
12fn touch_system(touches: Res<Touches>) {
13    for touch in touches.iter_just_pressed() {
14        info!(
15            "just pressed touch with id: {}, at: {}",
16            touch.id(),
17            touch.position()
18        );
19    }
20
21    for touch in touches.iter_just_released() {
22        info!(
23            "just released touch with id: {}, at: {}",
24            touch.id(),
25            touch.position()
26        );
27    }
28
29    for touch in touches.iter_just_canceled() {
30        info!("canceled touch with id: {}", touch.id());
31    }
32
33    // you can also iterate
...
```

---

## Module interval Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/interval/index.html

**Contents:**
- Module interval Copy item path
- Structs§
- Functions§

The Interval type for nonempty intervals used by the Curve trait.

---

## Enum Color Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Color.html

**Contents:**
- Enum Color Copy item path
- §Conversion
- §Operations
- Variants§
  - Srgba(Srgba)
  - LinearRgba(LinearRgba)
  - Hsla(Hsla)
  - Hsva(Hsva)
  - Hwba(Hwba)
  - Laba(Laba)

An enumerated type that can represent any of the color types in this crate.

This is useful when you need to store a color in a data structure that can’t be generic over the color type.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

Color supports all the standard color operations, such as mixing, luminance and hue adjustment, and diffing. These operations delegate to the concrete color space contained by Color, but will convert to Oklch for operations which aren’t supported in the current space. After performing the operation, if a conversion was required, the result will be converted back into the original color space.

Oklch has been chosen as the intermediary space in cases where conversion is required due to its perceptual uniformity and broad support for Bevy’s color operations. To avoid the cost of repeated conversion, and ensure consistent results where that is desired, first convert this Color into your desired color space.

A color in the sRGB color space with alpha.

A color in the linear sRGB color space with alpha.

A color in the HSL color space with alpha.

A color in the HSV color space with alpha.

A color in the HWB color space with alpha.

A color in the LAB color space with alpha.

A color in the LCH color space with alpha.

A color in the Oklab color space with alpha.

A color in the Oklch color space with alpha.

A color in the XYZ color space with alpha.

A fully white Color::LinearRgba color with an alpha of 1.0.

A fully black Color::LinearRgba color with an alpha of 1.0.

A fully transparent Color::LinearRgba color with 0 red, green and blue.

Return the color as a linear RGBA color.

Return the color as an SRGBA color.

Creates a new Color object storing a Srgba color.

Creates a new Co

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub enum Color {
    Srgba(Srgba),
    LinearRgba(LinearRgba),
    Hsla(Hsla),
    Hsva(Hsva),
    Hwba(Hwba),
    Laba(Laba),
    Lcha(Lcha),
    Oklaba(Oklaba),
    Oklcha(Oklcha),
    Xyza(Xyza),
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

Example 3 (javascript):
```javascript
let red_hsv = Color::hsv(0., 1., 1.);
let red_srgb = Color::srgb(1., 0., 0.);

// HSV has a definition of hue, so it will be returned.
red_hsv.hue();

// SRGB doesn't have a native definition for hue.
// Converts to Oklch and returns that result.
red_srgb.hue();
```

Example 4 (javascript):
```javascript
90fn animate(
91    mut materials: ResMut<Assets<CustomUiMaterial>>,
92    q: Query<&MaterialNode<CustomUiMaterial>>,
93    time: Res<Time>,
94) {
95    let duration = 2.0;
96    for handle in &q {
97        if let Some(material) = materials.get_mut(handle) {
98            // rainbow color effect
99            let new_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 1., 0.5);
100            let border_color = Color::hsl((time.elapsed_secs() * 60.0) % 360.0, 0.75, 0.75);
101            material.color = new_color.to_linear().to_vec4();
102            material.slider.x =
103              
...
```

---

## Struct GizmoConfigStore Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GizmoConfigStore.html

**Contents:**
- Struct GizmoConfigStore Copy item path
- Implementations§
  - impl GizmoConfigStore
    - pub fn get_config_dyn( &self, config_type_id: &TypeId, ) -> Option<(&GizmoConfig, &(dyn Reflect + 'static))>
    - pub fn config<T>(&self) -> (&GizmoConfig, &T)where T: GizmoConfigGroup,
    - pub fn get_config_mut_dyn( &mut self, config_type_id: &TypeId, ) -> Option<(&mut GizmoConfig, &mut (dyn Reflect + 'static))>
    - pub fn config_mut<T>(&mut self) -> (&mut GizmoConfig, &mut T)where T: GizmoConfigGroup,
      - Examples found in repository?
    - pub fn iter( &self, ) -> impl Iterator<Item = (&TypeId, &GizmoConfig, &(dyn Reflect + 'static))>
    - pub fn iter_mut( &mut self, ) -> impl Iterator<Item = (&TypeId, &mut GizmoConfig, &mut (dyn Reflect + 'static))>

A Resource storing GizmoConfig and GizmoConfigGroup structs

Use app.init_gizmo_group::<T>() to register a custom config group.

Returns GizmoConfig and GizmoConfigGroup associated with TypeId of a GizmoConfigGroup

Returns GizmoConfig and GizmoConfigGroup associated with GizmoConfigGroup T

Returns mutable GizmoConfig and GizmoConfigGroup associated with TypeId of a GizmoConfigGroup

Returns mutable GizmoConfig and GizmoConfigGroup associated with GizmoConfigGroup T

Returns an iterator over all GizmoConfigs.

Returns an iterator over all GizmoConfigs, by mutable reference.

Inserts GizmoConfig and GizmoConfigGroup replacing old values

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GizmoConfigStore { /* private fields */ }
```

Example 2 (javascript):
```javascript
125fn update_config(
126    mut config_store: ResMut<GizmoConfigStore>,
127    keyboard: Res<ButtonInput<KeyCode>>,
128    time: Res<Time>,
129) {
130    let (config, _) = config_store.config_mut::<DefaultGizmoConfigGroup>();
131    if keyboard.pressed(KeyCode::ArrowRight) {
132        config.line.width += 5. * time.delta_secs();
133        config.line.width = config.line.width.clamp(0., 50.);
134    }
135    if keyboard.pressed(KeyCode::ArrowLeft) {
136        config.line.width -= 5. * time.delta_secs();
137        config.line.width = config.line.width.clamp(0., 50.);
138    }
139    if keybo
...
```

Example 3 (javascript):
```javascript
38fn setup(
39    mut commands: Commands,
40    mut meshes: ResMut<Assets<Mesh>>,
41    mut materials: ResMut<Assets<StandardMaterial>>,
42    mut config_store: ResMut<GizmoConfigStore>,
43) {
44    // Circular base.
45    commands.spawn((
46        Mesh3d(meshes.add(Circle::new(4.0))),
47        MeshMaterial3d(materials.add(Color::WHITE)),
48        Transform::from_rotation(Quat::from_rotation_x(-FRAC_PI_2)),
49    ));
50
51    // Cubes.
52    {
53        let mesh = meshes.add(Cuboid::new(1.0, 1.0, 1.0));
54        let material = materials.add(Color::srgb_u8(124, 144, 255));
55        for x i
...
```

Example 4 (javascript):
```javascript
206fn update_config(
207    mut config_store: ResMut<GizmoConfigStore>,
208    keyboard: Res<ButtonInput<KeyCode>>,
209    time: Res<Time>,
210) {
211    if keyboard.just_pressed(KeyCode::KeyT) {
212        for (_, config, _) in config_store.iter_mut() {
213            config.depth_bias = if config.depth_bias == 0. { -1. } else { 0. };
214        }
215    }
216    if keyboard.just_pressed(KeyCode::KeyP) {
217        for (_, config, _) in config_store.iter_mut() {
218            // Toggle line perspective
219            config.line.perspective ^= true;
220            // Increase the line width 
...
```

---

## Struct SineInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SineInOutCurve.html

**Contents:**
- Struct SineInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for SineInOutCurve
    - fn clone(&self) -> SineInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for SineInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as SineIn for t < 0.5 and as SineOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SineInOutCurve;
```

---

## Struct CursorEntered Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CursorEntered.html

**Contents:**
- Struct CursorEntered Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for CursorEntered
    - fn clone(&self) -> CursorEntered
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for CursorEntered
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'de> Deserialize<'de> for CursorEntered
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<CursorEntered, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,

An event that is sent whenever the user’s cursor enters a window.

Window that the cursor entered.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CursorEntered {
    pub window: Entity,
}
```

---

## Function ivec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.ivec4.html

**Contents:**
- Function ivec4 Copy item path

Creates a 4-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn ivec4(x: i32, y: i32, z: i32, w: i32) -> IVec4
```

---

## Struct BVec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BVec3.html

**Contents:**
- Struct BVec3 Copy item path
- Fields§
- Implementations§
  - impl BVec3
    - pub const FALSE: BVec3
    - pub const TRUE: BVec3
    - pub const fn new(x: bool, y: bool, z: bool) -> BVec3
    - pub const fn splat(v: bool) -> BVec3
    - pub const fn from_array(a: [bool; 3]) -> BVec3
    - pub fn bitmask(self) -> u32

A 3-dimensional bool vector mask.

Creates a new vector mask.

Creates a vector mask with all elements set to v.

Creates a new vector mask from a bool array.

Returns a bitmask with the lowest 3 bits set from the elements of self.

A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc.

Returns true if any of the elements are true, false otherwise.

Returns true if all the elements are true, false otherwise.

Tests the value at index.

Panics if index is greater than 2.

Sets the element at index.

Panics if index is greater than 2.

Deserialize expects a sequence of 3 values.

Serialize as a sequence of 3 values.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C, align(1))]pub struct BVec3 {
    pub x: bool,
    pub y: bool,
    pub z: bool,
}
```

---

## Module iterable Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/iterable/index.html

**Contents:**
- Module iterable Copy item path
- Traits§

Iterable curves, which sample in the form of an iterator in order to support Vec-like output whose length cannot be known statically.

---

## Struct Box Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Box.html

**Contents:**
- Struct Box Copy item path
- Implementations§
  - impl<A> Box<dyn Any, A>where A: Allocator,
    - pub fn downcast<T>(self) -> Result<Box<T, A>, Box<dyn Any, A>>where T: Any,
      - §Examples
    - pub unsafe fn downcast_unchecked<T>(self) -> Box<T, A>where T: Any,
      - §Examples
      - §Safety
  - impl<A> Box<dyn Any + Send, A>where A: Allocator,
    - pub fn downcast<T>(self) -> Result<Box<T, A>, Box<dyn Any + Send, A>>where T: Any,

A pointer type that uniquely owns a heap allocation of type T.

See the module-level documentation for more.

Attempts to downcast the box to a concrete type.

Downcasts the box to a concrete type.

For a safe alternative see downcast.

The contained value must be of type T. Calling this method with the incorrect type is undefined behavior.

Attempts to downcast the box to a concrete type.

Downcasts the box to a concrete type.

For a safe alternative see downcast.

The contained value must be of type T. Calling this method with the incorrect type is undefined behavior.

Attempts to downcast the box to a concrete type.

Downcasts the box to a concrete type.

For a safe alternative see downcast.

The contained value must be of type T. Calling this method with the incorrect type is undefined behavior.

Allocates memory on the heap and then places x into it.

This doesn’t actually allocate if T is zero-sized.

Constructs a new box with uninitialized contents.

Constructs a new Box with uninitialized contents, with the memory being filled with 0 bytes.

See MaybeUninit::zeroed for examples of correct and incorrect usage of this method.

Constructs a new Pin<Box<T>>. If T does not implement Unpin, then x will be pinned in memory and unable to be moved.

Constructing and pinning of the Box can also be done in two steps: Box::pin(x) does the same as Box::into_pin(Box::new(x)). Consider using into_pin if you already have a Box<T>, or if you want to construct a (pinned) Box in a different way than with Box::new.

Allocates memory on the heap then places x into it, returning an error if the allocation fails

This doesn’t actually allocate if T is zero-sized.

Constructs a new box with uninitialized contents on the heap, returning an error if the allocation fails

Constructs a new Box with uninitialized contents, with the memory being filled with 0 bytes on the heap

See MaybeUninit::zeroed for examples of correct and incorrect usage of this method.

Allocates memory in the given allocator then places x into it.

This doesn’t actually allocate if T is zero-sized.

Allocates memory in the given allocator then places x into it, returning an error if the allocation fails

This doesn’t actually allocate if T is zero-sized.

Constructs a new box with uninitialized contents in the provided allocator.

Constructs a new box with uninitialized contents in the provided allocator, returning an error if the allocation fails

Constructs a new Box with uninitialized contents, with

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Box<T, A = Global>(/* private fields */)
where
    A: Allocator,
    T: ?Sized;
```

Example 2 (javascript):
```javascript
use std::any::Any;

fn print_if_string(value: Box<dyn Any>) {
    if let Ok(string) = value.downcast::<String>() {
        println!("String ({}): {}", string.len(), string);
    }
}

let my_string = "Hello World".to_string();
print_if_string(Box::new(my_string));
print_if_string(Box::new(0i8));
```

Example 3 (javascript):
```javascript
#![feature(downcast_unchecked)]

use std::any::Any;

let x: Box<dyn Any> = Box::new(1_usize);

unsafe {
    assert_eq!(*x.downcast_unchecked::<usize>(), 1);
}
```

Example 4 (javascript):
```javascript
use std::any::Any;

fn print_if_string(value: Box<dyn Any + Send>) {
    if let Ok(string) = value.downcast::<String>() {
        println!("String ({}): {}", string.len(), string);
    }
}

let my_string = "Hello World".to_string();
print_if_string(Box::new(my_string));
print_if_string(Box::new(0i8));
```

---

## Module hotpatch Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/hotpatch/index.html

**Contents:**
- Module hotpatch Copy item path
- Structs§
- Traits§
- Functions§

Utilities for hotpatching code.

---

## Struct AmbientLight Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AmbientLight.html

**Contents:**
- Struct AmbientLight Copy item path
- §Examples
- Fields§
- Implementations§
  - impl AmbientLight
    - pub const NONE: AmbientLight
- Trait Implementations§
  - impl Clone for AmbientLight
    - fn clone(&self) -> AmbientLight
    - fn clone_from(&mut self, source: &Self)

An ambient light, which lights the entire scene equally.

This resource is inserted by the LightPlugin and by default it is set to a low ambient light.

It can also be added to a camera to override the resource (or default) ambient for that camera only.

Make ambient light slightly brighter:

A direct scale factor multiplied with color before being passed to the shader.

After applying this multiplier, the resulting value should be in units of cd/m^2.

Whether this ambient light has an effect on meshes with lightmaps.

Set this to false if your lightmap baking tool bakes the ambient light into the lightmaps, to avoid rendering that light twice.

By default, this is set to true.

Required Components: Camera.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AmbientLight {
    pub color: Color,
    pub brightness: f32,
    pub affects_lightmapped_meshes: bool,
}
```

Example 2 (unknown):
```unknown
fn setup_ambient_light(mut ambient_light: ResMut<AmbientLight>) {
   ambient_light.brightness = 100.0;
}
```

---

## Function any_component_removed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.any_component_removed.html

**Contents:**
- Function any_component_removed Copy item path

A SystemCondition-satisfying system that returns true if there are any entity with a component of the given type removed.

**Examples:**

Example 1 (unknown):
```unknown
pub fn any_component_removed<T>(removals: RemovedComponents<'_, '_, T>) -> boolwhere
    T: Component,
```

---

## Struct GilrsPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GilrsPlugin.html

**Contents:**
- Struct GilrsPlugin Copy item path
- Trait Implementations§
  - impl Default for GilrsPlugin
    - fn default() -> GilrsPlugin
  - impl Plugin for GilrsPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str

Plugin that provides gamepad handling to an App.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GilrsPlugin;
```

---

## Struct IsDefaultUiCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.IsDefaultUiCamera.html

**Contents:**
- Struct IsDefaultUiCamera Copy item path
- Trait Implementations§
  - impl Component for IsDefaultUiCamerawhere IsDefaultUiCamera: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior
    - fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_replace() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>

Marker used to identify default cameras, they will have priority over the PrimaryWindow camera.

This is useful if the PrimaryWindow has two cameras, one of them used just for debug purposes and the user wants a way to choose the default Camera without having to add a UiTargetCamera to the root node.

Another use is when the user wants the Ui to be in another window by default, all that is needed is to place this component on the camera

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct IsDefaultUiCamera;
```

Example 2 (javascript):
```javascript
fn spawn_camera(mut commands: Commands) {
    let another_window = commands.spawn(Window {
        title: String::from("Another window"),
        ..Default::default()
    }).id();
    commands.spawn((
        Camera2d,
        Camera {
            target: RenderTarget::Window(WindowRef::Entity(another_window)),
            ..Default::default()
        },
        // We add the Marker here so all Ui will spawn in
        // another window if no UiTargetCamera is specified
        IsDefaultUiCamera
    ));
}
```

---

## Struct AnimatedField Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimatedField.html

**Contents:**
- Struct AnimatedField Copy item path
- Implementations§
  - impl<C, P, F> AnimatedField<C, P, F>where C: Typed, F: Fn(&mut C) -> &mut P + 'static,
    - pub fn new_unchecked(field_name: &str, func: F) -> AnimatedField<C, P, F>
      - §Panics
- Trait Implementations§
  - impl<C, A, F> AnimatableProperty for AnimatedField<C, A, F>where C: Component<Mutability = Mutable>, A: Animatable + Clone + Sync + Debug, F: Fn(&mut C) -> &mut A + Send + Sync + 'static,
    - type Property = A
    - fn get_mut<'a>( &self, entity: &'a mut EntityMutExcept<'_, '_, (AnimationTarget, AnimationPlayer, AnimationGraphHandle)>, ) -> Result<&'a mut A, AnimationEvaluationError>
    - fn evaluator_id(&self) -> EvaluatorId<'_>

A Component field that can be animated, defined by a function that reads the component and returns the accessed field / property.

The best way to create an instance of this type is via the animated_field macro.

C is the component being animated, A is the type of the Animatable field on the component, and F is an accessor function that accepts a reference to C and retrieves the field A.

Creates a new instance of AnimatedField. This operates under the assumption that C is a reflect-able struct, and that field_name is a valid field on that struct.

If the type of C is not a struct or if the field_name does not exist.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimatedField<C, A, F>where
    F: Fn(&mut C) -> &mut A,{ /* private fields */ }
```

---

## Struct InMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.InMut.html

**Contents:**
- Struct InMut Copy item path
- §Examples
- Tuple Fields§
- Trait Implementations§
  - impl<'a, T> Debug for InMut<'a, T>where T: Debug + ?Sized,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'i, T> Deref for InMut<'i, T>where T: ?Sized,
    - type Target = T
    - fn deref(&self) -> &<InMut<'i, T> as Deref>::Target
  - impl<'i, T> DerefMut for InMut<'i, T>where T: ?Sized,

A SystemInput type which denotes that a System receives a mutable reference to a value of type T from its caller.

This is similar to In but takes a mutable reference to a value instead of the value itself. See InRef for the read-only version.

See SystemInput to learn more about system inputs in general.

Here is a simple example of a system that takes a &mut usize and squares it.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct InMut<'a, T>(pub &'a mut T)
where
    T: ?Sized;
```

Example 2 (javascript):
```javascript
fn square(InMut(input): InMut<usize>) {
    *input *= *input;
}

let mut world = World::new();
let mut square_system = IntoSystem::into_system(square);
square_system.initialize(&mut world);
     
let mut value = 12;
square_system.run(&mut value, &mut world);
assert_eq!(value, 144);
```

---

## Macro debug Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.debug.html

**Contents:**
- Macro debug Copy item path
- §Examples

Constructs an event at the debug level.

This functions similarly to the event! macro. See the top-level documentation for details on the syntax accepted by this macro.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! debug {
    (name: $name:expr, target: $target:expr, parent: $parent:expr, { $($field:tt)* }, $($arg:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, ?$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, %$($k:ident).+ $($field:tt)* ) => { ... };
    (name: $name:expr, target: $target:expr, parent: $parent:expr, $($arg:tt)+ ) => { ... };
    (name: $name:expr, target: $target:expr, 
...
```

Example 2 (javascript):
```javascript
use tracing::debug;

let pos = Position { x: 3.234, y: -1.223 };

debug!(?pos.x, ?pos.y);
debug!(target: "app_events", position = ?pos, "New position");
debug!(name: "completed", position = ?pos);
```

---

## Struct SpatialAudioSink Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpatialAudioSink.html

**Contents:**
- Struct SpatialAudioSink Copy item path
- Implementations§
  - impl SpatialAudioSink
    - pub fn new(sink: SpatialSink) -> SpatialAudioSink
  - impl SpatialAudioSink
    - pub fn set_ears_position(&self, left_position: Vec3, right_position: Vec3)
    - pub fn set_listener_position(&self, position: Transform, gap: f32)
    - pub fn set_emitter_position(&self, position: Vec3)
- Trait Implementations§
  - impl AudioSinkPlayback for SpatialAudioSink

Used to control spatial audio during playback.

Bevy inserts this component onto your entities when it begins playing an audio source that’s configured to use spatial audio.

You can use this component to modify the playback settings while the audio is playing.

If this component is removed from an entity, and a AudioSource is attached to that entity, that AudioSource will start playing. If that source is unchanged, that translates to the audio restarting.

Create a new spatial audio sink.

Set the two ears position.

Set the listener position, with an ear on each side separated by gap.

Set the emitter position.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpatialAudioSink { /* private fields */ }
```

---

## Struct Quat Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Quat.html

**Contents:**
- Struct Quat Copy item path
- Implementations§
  - impl Quat
    - pub const IDENTITY: Quat
    - pub const NAN: Quat
    - pub const fn from_xyzw(x: f32, y: f32, z: f32, w: f32) -> Quat
      - §Preconditions
      - Examples found in repository?
    - pub const fn from_array(a: [f32; 4]) -> Quat
      - §Preconditions

A quaternion representing an orientation.

This quaternion is intended to be of unit length but may denormalize due to floating point “error creep” which can occur when successive quaternion operations are applied.

SIMD vector types are used for storage on supported platforms.

This type is 16 byte aligned.

The identity quaternion. Corresponds to no rotation.

Creates a new rotation quaternion.

This should generally not be called manually unless you know what you are doing. Use one of the other constructors instead such as identity or from_axis_angle.

from_xyzw is mostly used by unit tests and serde deserialization.

This function does not check if the input is normalized, it is up to the user to provide normalized input or to normalized the resulting quaternion.

Creates a rotation quaternion from an array.

This function does not check if the input is normalized, it is up to the user to provide normalized input or to normalized the resulting quaternion.

Creates a new rotation quaternion from a 4D vector.

This function does not check if the input is normalized, it is up to the user to provide normalized input or to normalized the resulting quaternion.

Creates a rotation quaternion from a slice.

This function does not check if the input is normalized, it is up to the user to provide normalized input or to normalized the resulting quaternion.

Panics if slice length is less than 4.

Writes the quaternion to an unaligned slice.

Panics if slice length is less than 4.

Create a quaternion for a normalized rotation axis and angle (in radians).

The axis must be a unit vector.

Will panic if axis is not normalized when glam_assert is enabled.

Create a quaternion that rotates v.length() radians around v.normalize().

from_scaled_axis(Vec3::ZERO) results in the identity quaternion.

Creates a quaternion from the angle (in radians) around the x axis.

Creates a quaternion from the angle (in radians) around the y axis.

Creates a quaternion from the angle (in radians) around the z axis.

Creates a quaternion from the given Euler rotation sequence and the angles (in radians).

Creates a quaternion from a 3x3 rotation matrix.

Note if the input matrix contain scales, shears, or other non-rotation transformations then the resulting quaternion will be ill-defined.

Will panic if any input matrix column is not normalized when glam_assert is enabled.

Creates a quaternion from a 3x3 SIMD aligned rotation matrix.

Note if the input matrix contain scales, shears, 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Quat(/* private fields */);
```

Example 2 (javascript):
```javascript
50const TRANSFORM_3D: Transform = Transform {
51    translation: Vec3::ZERO,
52    // The camera is pointing at the 3D shape
53    rotation: Quat::from_xyzw(-0.14521316, -0.0, -0.0, 0.98940045),
54    scale: Vec3::ONE,
55};
```

Example 3 (javascript):
```javascript
164const CAMERA_POSITIONS: &[Transform] = &[
165    Transform {
166        translation: Vec3::new(1.5, 1.5, 1.5),
167        rotation: Quat::from_xyzw(-0.279, 0.364, 0.115, 0.880),
168        scale: Vec3::ONE,
169    },
170    Transform {
171        translation: Vec3::new(2.4, 0.0, 0.2),
172        rotation: Quat::from_xyzw(0.094, 0.676, 0.116, 0.721),
173        scale: Vec3::ONE,
174    },
175    Transform {
176        translation: Vec3::new(2.4, 2.6, -4.3),
177        rotation: Quat::from_xyzw(0.170, 0.908, 0.308, 0.225),
178        scale: Vec3::ONE,
179    },
180    Transform {
181        t
...
```

Example 4 (javascript):
```javascript
58fn setup(
59    mut commands: Commands,
60    asset_server: Res<AssetServer>,
61    args: Res<Args>,
62    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] dlss_rr_supported: Option<
63        Res<DlssRayReconstructionSupported>,
64    >,
65) {
66    commands
67        .spawn((
68            SceneRoot(
69                asset_server.load(
70                    GltfAssetLabel::Scene(0)
71                        .from_asset("https://github.com/bevyengine/bevy_asset_files/raw/2a5950295a8b6d9d051d59c0df69e87abcda58c3/pica_pica/mini_diorama_01.glb")
72                ),
73      
...
```

---

## Struct Rot2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Rot2.html

**Contents:**
- Struct Rot2 Copy item path
- §Example
- Fields§
- Implementations§
  - impl Rot2
    - pub const IDENTITY: Rot2
    - pub const PI: Rot2
    - pub const FRAC_PI_2: Rot2
    - pub const FRAC_PI_3: Rot2
    - pub const FRAC_PI_4: Rot2

The cosine of the rotation angle.

This is the real part of the unit complex number representing the rotation.

The sine of the rotation angle.

This is the imaginary part of the unit complex number representing the rotation.

No rotation. Also equals a full turn that returns back to its original position.

A rotation of π radians. Corresponds to a half-turn.

A counterclockwise rotation of π/2 radians. Corresponds to a counterclockwise quarter-turn.

A counterclockwise rotation of π/3 radians. Corresponds to a counterclockwise turn by 60°.

A counterclockwise rotation of π/4 radians. Corresponds to a counterclockwise turn by 45°.

A counterclockwise rotation of π/6 radians. Corresponds to a counterclockwise turn by 30°.

A counterclockwise rotation of π/8 radians. Corresponds to a counterclockwise turn by 22.5°.

Creates a Rot2 from a counterclockwise angle in radians. A negative argument corresponds to a clockwise rotation.

Angles larger than or equal to 2π (in either direction) loop around to smaller rotations, since a full rotation returns an object to its starting orientation.

Creates a Rot2 from a counterclockwise angle in degrees. A negative argument corresponds to a clockwise rotation.

Angles larger than or equal to 360° (in either direction) loop around to smaller rotations, since a full rotation returns an object to its starting orientation.

Creates a Rot2 from a counterclockwise fraction of a full turn of 360 degrees. A negative argument corresponds to a clockwise rotation.

Angles larger than or equal to 1 turn (in either direction) loop around to smaller rotations, since a full rotation returns an object to its starting orientation.

Creates a Rot2 from the sine and cosine of an angle.

The rotation is only valid if sin * sin + cos * cos == 1.0.

Panics if sin * sin + cos * cos != 1.0 when the glam_assert feature is enabled.

Returns a corresponding rotation angle in radians in the (-pi, pi] range.

Returns a corresponding rotation angle in degrees in the (-180, 180] range.

Returns a corresponding rotation angle as a fraction of a full 360 degree turn in the (-0.5, 0.5] range.

Returns the sine and cosine of the rotation angle.

Computes the length or norm of the complex number used to represent the rotation.

The length is typically expected to be 1.0. Unexpectedly denormalized rotations can be a result of incorrect construction or floating point error caused by successive operations.

Computes the squared length or norm of the complex n

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Rot2 {
    pub cos: f32,
    pub sin: f32,
}
```

Example 2 (javascript):
```javascript
use std::f32::consts::PI;

// Create rotations from counterclockwise angles in radians or degrees
let rotation1 = Rot2::radians(PI / 2.0);
let rotation2 = Rot2::degrees(45.0);

// Get the angle back as radians or degrees
assert_eq!(rotation1.as_degrees(), 90.0);
assert_eq!(rotation2.as_radians(), PI / 4.0);

// "Add" rotations together using `*`
#[cfg(feature = "approx")]
assert_relative_eq!(rotation1 * rotation2, Rot2::degrees(135.0));

// Rotate vectors
#[cfg(feature = "approx")]
assert_relative_eq!(rotation1 * Vec2::X, Vec2::Y);
```

Example 3 (unknown):
```unknown
#[cfg(feature = "approx")]
assert_relative_eq!(Rot2::IDENTITY, Rot2::degrees(360.0), epsilon = 2e-7);
```

Example 4 (javascript):
```javascript
let rot1 = Rot2::radians(3.0 * FRAC_PI_2);
let rot2 = Rot2::radians(-FRAC_PI_2);
#[cfg(feature = "approx")]
assert_relative_eq!(rot1, rot2);

let rot3 = Rot2::radians(PI);
#[cfg(feature = "approx")]
assert_relative_eq!(rot1 * rot1, rot3);

// A rotation by 3π and 1π are the same
#[cfg(feature = "approx")]
assert_relative_eq!(Rot2::radians(3.0 * PI), Rot2::radians(PI));
```

---

## Struct DragEntry Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragEntry.html

**Contents:**
- Struct DragEntry Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragEntry
    - fn clone(&self) -> DragEntry
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragEntry
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragEntry
    - type This<'from_arg> = DragEntry

The position of the pointer at drag start.

This is stored in screen pixels, not world coordinates. Screen pixels go from top-left to bottom-right, whereas (in 2D) world coordinates go from bottom-left to top-right. Consider using Camera::viewport_to_world or Camera::viewport_to_world_2d to convert from screen-space to world-space.

The latest position of the pointer during this drag, used to compute deltas.

This is stored in screen pixels, not world coordinates. Screen pixels go from top-left to bottom-right, whereas (in 2D) world coordinates go from bottom-left to top-right. Consider using Camera::viewport_to_world or Camera::viewport_to_world_2d to convert from screen-space to world-space.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragEntry {
    pub start_pos: Vec2,
    pub latest_pos: Vec2,
}
```

---

## Enum MinTrackSizingFunction Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.MinTrackSizingFunction.html

**Contents:**
- Enum MinTrackSizingFunction Copy item path
- Variants§
  - Px(f32)
  - Percent(f32)
  - MinContent
  - MaxContent
  - Auto
  - VMin(f32)
  - VMax(f32)
  - Vh(f32)

Track minimum size should be a fixed pixel value

Track minimum size should be a percentage value

Track minimum size should be content sized under a min-content constraint

Track minimum size should be content sized under a max-content constraint

Track minimum size should be automatically sized

Track minimum size should be a percent of the viewport’s smaller dimension.

Track minimum size should be a percent of the viewport’s larger dimension.

Track minimum size should be a percent of the viewport’s height dimension.

Track minimum size should be a percent of the viewport’s width dimension.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum MinTrackSizingFunction {
    Px(f32),
    Percent(f32),
    MinContent,
    MaxContent,
    Auto,
    VMin(f32),
    VMax(f32),
    Vh(f32),
    Vw(f32),
}
```

---

## Function bvec3a Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.bvec3a.html

**Contents:**
- Function bvec3a Copy item path

Creates a 3-dimensional bool vector mask.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn bvec3a(x: bool, y: bool, z: bool) -> BVec3A
```

---

## Struct Isometry3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Isometry3d.html

**Contents:**
- Struct Isometry3d Copy item path
- §Example
- Fields§
- Implementations§
  - impl Isometry3d
    - pub const IDENTITY: Isometry3d
    - pub fn new(translation: impl Into<Vec3A>, rotation: Quat) -> Isometry3d
      - Examples found in repository?
    - pub const fn from_rotation(rotation: Quat) -> Isometry3d
    - pub fn from_translation(translation: impl Into<Vec3A>) -> Isometry3d

An isometry in three dimensions, representing a rotation followed by a translation. This can often be useful for expressing relative positions and transformations from one position to another.

In particular, this type represents a distance-preserving transformation known as a rigid motion or a direct motion, and belongs to the special Euclidean group SE(3). This includes translation and rotation, but excludes reflection.

For the two-dimensional version, see Isometry2d.

Isometries can be created from a given translation and rotation:

Or from separate parts:

The isometries can be used to transform points:

Isometries can also be composed together:

One common operation is to compute an isometry representing the relative positions of two objects for things like intersection tests. This can be done with an inverse transformation:

The rotational part of a three-dimensional isometry.

The translational part of a three-dimensional isometry.

The identity isometry which represents the rigid motion of not doing anything.

Create a three-dimensional isometry from a rotation and a translation.

Create a three-dimensional isometry from a rotation.

Create a three-dimensional isometry from a translation.

Create a three-dimensional isometry from a translation with the given x, y, and z components.

The inverse isometry that undoes this one.

Compute iso1.inverse() * iso2 in a more efficient way for one-shot cases.

If the same isometry is used multiple times, it is more efficient to instead compute the inverse once and use that for each transformation.

Transform a point by rotating and translating it using this isometry.

Transform a point by rotating and translating it using the inverse of this isometry.

This is more efficient than iso.inverse().transform_point(point) for one-shot cases. If the same isometry is used multiple times, it is more efficient to instead compute the inverse once and use that for each transformation.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Isometry3d {
    pub rotation: Quat,
    pub translation: Vec3A,
}
```

Example 2 (javascript):
```javascript
let iso = Isometry3d::new(Vec3::new(2.0, 1.0, 3.0), Quat::from_rotation_z(FRAC_PI_2));
```

Example 3 (javascript):
```javascript
let iso1 = Isometry3d::from_translation(Vec3::new(2.0, 1.0, 3.0));
let iso2 = Isometry3d::from_rotation(Quat::from_rotation_z(FRAC_PI_2));
```

Example 4 (javascript):
```javascript
let iso = Isometry3d::new(Vec3::new(2.0, 1.0, 3.0), Quat::from_rotation_z(FRAC_PI_2));
let point = Vec3::new(4.0, 4.0, 4.0);

// These are equivalent
let result = iso.transform_point(point);
let result = iso * point;

assert_relative_eq!(result, Vec3::new(-2.0, 5.0, 7.0));
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/pbr/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§
- Traits§

This includes the most common types in this crate, re-exported for your convenience.

---

## Enum GridTrackRepetition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GridTrackRepetition.html

**Contents:**
- Enum GridTrackRepetition Copy item path
- Variants§
  - Count(u16)
  - AutoFill
  - AutoFit
- Trait Implementations§
  - impl Clone for GridTrackRepetition
    - fn clone(&self) -> GridTrackRepetition
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for GridTrackRepetition

How many times to repeat a repeated grid track

https://developer.mozilla.org/en-US/docs/Web/CSS/repeat

Repeat the track fixed number of times

Repeat the track to fill available space

https://developer.mozilla.org/en-US/docs/Web/CSS/repeat#auto-fill

Repeat the track to fill available space but collapse any tracks that do not end up with an item placed in them.

https://developer.mozilla.org/en-US/docs/Web/CSS/repeat#auto-fit

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GridTrackRepetition {
    Count(u16),
    AutoFill,
    AutoFit,
}
```

---

## Struct IVec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.IVec4.html

**Contents:**
- Struct IVec4 Copy item path
- Fields§
- Implementations§
  - impl IVec4
    - pub const ZERO: IVec4
    - pub const ONE: IVec4
    - pub const NEG_ONE: IVec4
    - pub const MIN: IVec4
    - pub const MAX: IVec4
    - pub const X: IVec4

A 4-dimensional vector.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the positive W axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

A unit vector pointing along the negative W axis.

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z, w]

Creates a vector from the first 4 values in slice.

Panics if slice is less than 4 elements long.

Writes the elements of self to the first 4 elements in slice.

Panics if slice is less than 4 elements long.

Creates a 3D vector from the x, y and z elements of self, discarding w.

Truncation to IVec3 may also be performed by using self.xyz().

Creates a 4D vector from self with the given value of x.

Creates a 4D vector from self with the given value of y.

Creates a 4D vector from self with the given value of z.

Creates a 4D vector from self with the given value of w.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

Component-wise clamping of values, similar to i32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

Returns the index of the first minimum element of self.

Returns the index of the first maximum element of self.

Returns the sum of all elements of self.

In other words, this computes self.x + self.y + ...

Returns the product of al

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct IVec4 {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub w: i32,
}
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/ecs/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Macros§
- Structs§
- Traits§
- Functions§
- Type Aliases§
- Derive Macros§

This includes the most common types in this crate, re-exported for your convenience.

---

## Enum LightGizmoColor Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.LightGizmoColor.html

**Contents:**
- Enum LightGizmoColor Copy item path
- Variants§
  - Manual(Color)
  - Varied
  - MatchLightColor
  - ByLightType
- Trait Implementations§
  - impl Clone for LightGizmoColor
    - fn clone(&self) -> LightGizmoColor
    - fn clone_from(&mut self, source: &Self)

Configures how a color is attributed to a light gizmo.

User-specified color.

Random color derived from the light’s Entity.

Take the color of the represented light.

Take the color provided by LightGizmoConfigGroup depending on the light kind.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum LightGizmoColor {
    Manual(Color),
    Varied,
    MatchLightColor,
    ByLightType,
}
```

---

## Struct ContinuationCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ContinuationCurve.html

**Contents:**
- Struct ContinuationCurve Copy item path
- §Domain
- Trait Implementations§
  - impl<T, C, D> Clone for ContinuationCurve<T, C, D>where T: Clone, C: Clone, D: Clone,
    - fn clone(&self) -> ContinuationCurve<T, C, D>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C, D> Curve<T> for ContinuationCurve<T, C, D>where T: VectorSpace, C: Curve<T>, D: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>

The curve that results from chaining two curves.

Additionally the transition of the samples is guaranteed to not make sudden jumps. This is useful if you really just know about the shapes of your curves and don’t want to deal with stitching them together properly when it would just introduce useless complexity. It is realized by translating the second curve so that its start sample point coincides with the first curves’ end sample point.

Curves of this type are produced by CurveExt::chain_continue.

The first curve’s domain must be right-finite and the second’s must be left-finite to get a valid ContinuationCurve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ContinuationCurve<T, C, D> { /* private fields */ }
```

---

## Type Alias Result Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.Result.html

**Contents:**
- Type Alias Result Copy item path
- Aliased Type§
- Variants§
  - Ok(T)
  - Err(E)

A result type for use in fallible systems, commands and observers.

The BevyError type is a type-erased error type with optional Bevy-specific diagnostics.

Contains the success value

Contains the error value

**Examples:**

Example 1 (unknown):
```unknown
pub type Result<T = (), E = BevyError> = Result<T, E>;
```

Example 2 (unknown):
```unknown
pub enum Result<T = (), E = BevyError> {
    Ok(T),
    Err(E),
}
```

---

## Struct QuinticInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuinticInCurve.html

**Contents:**
- Struct QuinticInCurve Copy item path
- Trait Implementations§
  - impl Clone for QuinticInCurve
    - fn clone(&self) -> QuinticInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuinticInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuinticInCurve;
```

---

## Struct App Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.App.html

**Contents:**
- Struct App Copy item path
- §Examples
- Implementations§
  - impl App
    - pub fn new() -> App
      - Examples found in repository?
    - pub fn empty() -> App
    - pub fn update(&mut self)
      - Examples found in repository?
    - pub fn run(&mut self) -> AppExit

App is the primary API for writing user applications. It automates the setup of a standard lifecycle and provides interface glue for plugins.

A single App can contain multiple SubApp instances, but App methods only affect the “main” one. To access a particular SubApp, use get_sub_app or get_sub_app_mut.

Here is a simple “Hello World” Bevy app:

Creates a new App with some default structure to enable core engine features. This is the preferred constructor for most use cases.

Creates a new empty App with minimal default configuration.

Use this constructor if you want to customize scheduling, exit handling, cleanup, etc.

Runs the default schedules of all sub-apps (starting with the “main” app) once.

Runs the App by calling its runner.

This will (re)build the App first. For general usage, see the example on the item level documentation.

Calls to App::run() will never return on iOS and Web.

Headless apps can generally expect this method to return control to the caller when it completes, but that is not the case for windowed apps. Windowed apps are typically driven by an event loop and some platforms expect the program to terminate when the event loop ends.

By default, Bevy uses the winit crate for window creation.

Panics if not all plugins have been built.

Sets the function that will be called when the app is run.

The runner function f is called only once by App::run. If the presence of a main loop in the app is desired, it is the responsibility of the runner function to provide it.

The runner function is usually not set manually, but by Bevy integrated plugins (e.g. WinitPlugin).

Returns the state of all plugins. This is usually called by the event loop, but can be useful for situations where you want to use App::update.

Runs Plugin::finish for each plugin. This is usually called by the event loop once all plugins are ready, but can be useful for situations where you want to use App::update.

Runs Plugin::cleanup for each plugin. This is usually called by the event loop after App::finish, but can be useful for situations where you want to use App::update.

Adds one or more systems to the given schedule in this app’s Schedules.

Registers a system and returns a SystemId so it can later be called by World::run_system.

It’s possible to register the same systems more than once, they’ll be stored separately.

This is different from adding systems to a Schedule with App::add_systems, because the SystemId that is returned can be used anywhere in the 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct App { /* private fields */ }
```

Example 2 (unknown):
```unknown
fn main() {
   App::new()
       .add_systems(Update, hello_world_system)
       .run();
}

fn hello_world_system() {
   println!("hello world");
}
```

Example 3 (unknown):
```unknown
5fn main() {
6    App::new().run();
7}
```

Example 4 (unknown):
```unknown
5fn main() {
6    App::new().add_plugins(DefaultPlugins).run();
7}
```

---

## Struct Cylinder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Cylinder.html

**Contents:**
- Struct Cylinder Copy item path
- Fields§
- Implementations§
  - impl Cylinder
    - pub const fn new(radius: f32, height: f32) -> Cylinder
      - Examples found in repository?
    - pub const fn base(&self) -> Circle
    - pub const fn lateral_area(&self) -> f32
    - pub fn base_area(&self) -> f32
- Trait Implementations§

A cylinder primitive centered on the origin

The radius of the cylinder

The half height of the cylinder

Create a new Cylinder from a radius and full height

Get the base of the cylinder as a Circle

Get the surface area of the side of the cylinder, also known as the lateral area

Get the surface area of one base of the cylinder

Returns the default Cylinder with a radius of 0.5 and a height of 1.0.

Get the total surface area of the cylinder

Get the volume of the cylinder

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Cylinder {
    pub radius: f32,
    pub half_height: f32,
}
```

Example 2 (javascript):
```javascript
60fn setup(
61    mut commands: Commands,
62    mut meshes: ResMut<Assets<Mesh>>,
63    mut materials: ResMut<Assets<StandardMaterial>>,
64    asset_server: Res<AssetServer>,
65) {
66    let icosphere_mesh = meshes.add(Sphere::new(0.9).mesh().ico(7).unwrap());
67    let cube_mesh = meshes.add(Cuboid::new(0.7, 0.7, 0.7));
68    let plane_mesh = meshes.add(Plane3d::default().mesh().size(2.0, 2.0));
69    let cylinder_mesh = meshes.add(Cylinder::new(0.5, 2.0).mesh().resolution(50));
70
71    // Cube #1
72    commands.spawn((
73        Mesh3d(cube_mesh.clone()),
74        MeshMaterial3d(materials.
...
```

---

## Struct VariableCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.VariableCurve.html

**Contents:**
- Struct VariableCurve Copy item path
- Tuple Fields§
- Implementations§
  - impl VariableCurve
    - pub fn new(animation_curve: impl AnimationCurve) -> VariableCurve
- Trait Implementations§
  - impl Clone for VariableCurve
    - fn clone(&self) -> VariableCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for VariableCurve

Contains an animation curve which is used to animate a property of an entity.

Create a new VariableCurve from an animation curve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct VariableCurve(pub Box<dyn AnimationCurve>);
```

---

## Trait Struct Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Struct.html

**Contents:**
- Trait Struct Copy item path
- §Example
- Required Methods§
    - fn field(&self, name: &str) -> Option<&(dyn PartialReflect + 'static)>
    - fn field_mut( &mut self, name: &str, ) -> Option<&mut (dyn PartialReflect + 'static)>
    - fn field_at(&self, index: usize) -> Option<&(dyn PartialReflect + 'static)>
    - fn field_at_mut( &mut self, index: usize, ) -> Option<&mut (dyn PartialReflect + 'static)>
    - fn name_at(&self, index: usize) -> Option<&str>
    - fn field_len(&self) -> usize
    - fn iter_fields(&self) -> FieldIter<'_> ⓘ

A trait used to power struct-like operations via reflection.

This trait uses the Reflect trait to allow implementors to have their fields be dynamically addressed by both name and index.

When using #[derive(Reflect)] on a standard struct, this trait will be automatically implemented. This goes for unit structs as well.

Returns a reference to the value of the field named name as a &dyn PartialReflect.

Returns a mutable reference to the value of the field named name as a &mut dyn PartialReflect.

Returns a reference to the value of the field with index index as a &dyn PartialReflect.

Returns a mutable reference to the value of the field with index index as a &mut dyn PartialReflect.

Returns the name of the field with index index.

Returns the number of fields in the struct.

Returns an iterator over the values of the reflectable fields for this struct.

Creates a new DynamicStruct from this struct.

Will return None if TypeInfo is not available.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Struct: PartialReflect {
    // Required methods
    fn field(&self, name: &str) -> Option<&(dyn PartialReflect + 'static)>;
    fn field_mut(
        &mut self,
        name: &str,
    ) -> Option<&mut (dyn PartialReflect + 'static)>;
    fn field_at(&self, index: usize) -> Option<&(dyn PartialReflect + 'static)>;
    fn field_at_mut(
        &mut self,
        index: usize,
    ) -> Option<&mut (dyn PartialReflect + 'static)>;
    fn name_at(&self, index: usize) -> Option<&str>;
    fn field_len(&self) -> usize;
    fn iter_fields(&self) -> FieldIter<'_> ⓘ;

    // Provided methods
...
```

Example 2 (javascript):
```javascript
use bevy_reflect::{PartialReflect, Reflect, Struct};

#[derive(Reflect)]
struct Foo {
    bar: u32,
}

let foo = Foo { bar: 123 };

assert_eq!(foo.field_len(), 1);
assert_eq!(foo.name_at(0), Some("bar"));

let field: &dyn PartialReflect = foo.field("bar").unwrap();
assert_eq!(field.try_downcast_ref::<u32>(), Some(&123));
```

---

## Struct PostStartup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PostStartup.html

**Contents:**
- Struct PostStartup Copy item path
- Trait Implementations§
  - impl Clone for PostStartup
    - fn clone(&self) -> PostStartup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for PostStartup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for PostStartup
    - fn default() -> PostStartup
  - impl Hash for PostStartup

The schedule that runs once after Startup.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PostStartup;
```

---

## Struct WeightsCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.WeightsCurve.html

**Contents:**
- Struct WeightsCurve Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<C> AnimationCurve for WeightsCurve<C>where C: IterableCurve<f32> + Debug + Clone + Reflectable,
    - fn clone_value(&self) -> Box<dyn AnimationCurve>
    - fn domain(&self) -> Interval
    - fn evaluator_id(&self) -> EvaluatorId<'_>
    - fn create_evaluator(&self) -> Box<dyn AnimationCurveEvaluator>
    - fn apply( &self, curve_evaluator: &mut (dyn AnimationCurveEvaluator + 'static), t: f32, weight: f32, graph_node: NodeIndex, ) -> Result<(), AnimationEvaluationError>
  - impl<C> Clone for WeightsCurve<C>where C: Clone,

This type allows an IterableCurve valued in f32 to be used as an AnimationCurve that animates morph weights.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WeightsCurve<C>(pub C);
```

---

## Struct ExponentialInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ExponentialInOutCurve.html

**Contents:**
- Struct ExponentialInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for ExponentialInOutCurve
    - fn clone(&self) -> ExponentialInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ExponentialInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as ExponentialIn for t < 0.5 and as ExponentialOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ExponentialInOutCurve;
```

---

## Struct DynamicSceneBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DynamicSceneBuilder.html

**Contents:**
- Struct DynamicSceneBuilder Copy item path
- §Component Extraction
- §Resource Extraction
- §Entity Order
- §Example
- Implementations§
  - impl<'w> DynamicSceneBuilder<'w>
    - pub fn from_world(world: &'w World) -> DynamicSceneBuilder<'w>
    - pub fn with_component_filter( self, filter: SceneFilter, ) -> DynamicSceneBuilder<'w>
    - pub fn with_resource_filter( self, filter: SceneFilter, ) -> DynamicSceneBuilder<'w>

A DynamicScene builder, used to build a scene from a World by extracting some entities and resources.

By default, all components registered with ReflectComponent type data in a world’s AppTypeRegistry will be extracted. (this type data is added automatically during registration if Reflect is derived with the #[reflect(Component)] attribute). This can be changed by specifying a filter or by explicitly allowing/denying certain components.

Extraction happens immediately and uses the filter as it exists during the time of extraction.

By default, all resources registered with ReflectResource type data in a world’s AppTypeRegistry will be extracted. (this type data is added automatically during registration if Reflect is derived with the #[reflect(Resource)] attribute). This can be changed by specifying a filter or by explicitly allowing/denying certain resources.

Extraction happens immediately and uses the filter as it exists during the time of extraction.

Extracted entities will always be stored in ascending order based on their index. This means that inserting Entity(1v0) then Entity(0v0) will always result in the entities being ordered as [Entity(0v0), Entity(1v0)].

Prepare a builder that will extract entities and their component from the given World.

Specify a custom component SceneFilter to be used with this builder.

Specify a custom resource SceneFilter to be used with this builder.

Updates the filter to allow all component and resource types.

This is useful for resetting the filter so that types may be selectively denied with deny_component and deny_resource.

Updates the filter to deny all component and resource types.

This is useful for resetting the filter so that types may be selectively allowed with allow_component and allow_resource.

Allows the given component type, T, to be included in the generated scene.

This method may be called multiple times for any number of components.

This is the inverse of deny_component. If T has already been denied, then it will be removed from the denylist.

Denies the given component type, T, from being included in the generated scene.

This method may be called multiple times for any number of components.

This is the inverse of allow_component. If T has already been allowed, then it will be removed from the allowlist.

Updates the filter to allow all component types.

This is useful for resetting the filter so that types may be selectively denied.

Updates the filter to deny all component types.

This 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct DynamicSceneBuilder<'w> { /* private fields */ }
```

Example 2 (javascript):
```javascript
let dynamic_scene = DynamicSceneBuilder::from_world(&world).extract_entity(entity).build();
```

Example 3 (javascript):
```javascript
#[derive(Component, Default, Reflect)]
#[reflect(Component)]
struct MyComponent;

let mut query = world.query_filtered::<Entity, With<MyComponent>>();

let scene = DynamicSceneBuilder::from_world(&world)
    .extract_entities(query.iter(&world))
    .build();
```

Example 4 (javascript):
```javascript
#[derive(Resource, Default, Reflect)]
#[reflect(Resource)]
struct MyResource;

world.insert_resource(MyResource);

let mut builder = DynamicSceneBuilder::from_world(&world).extract_resources();
let scene = builder.build();
```

---

## Struct MeshPickingSettings Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MeshPickingSettings.html

**Contents:**
- Struct MeshPickingSettings Copy item path
- Fields§
- Trait Implementations§
  - impl Default for MeshPickingSettings
    - fn default() -> MeshPickingSettings
  - impl FromArg for MeshPickingSettings
    - type This<'from_arg> = MeshPickingSettings
    - fn from_arg( arg: Arg<'_>, ) -> Result<<MeshPickingSettings as FromArg>::This<'_>, ArgError>
  - impl FromReflect for MeshPickingSettings
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<MeshPickingSettings>

Runtime settings for the MeshPickingPlugin.

When set to true ray casting will only consider cameras marked with MeshPickingCamera and entities marked with Pickable. false by default.

This setting is provided to give you fine-grained control over which cameras and entities should be used by the mesh picking backend at runtime.

Determines how mesh picking should consider Visibility. When set to RayCastVisibility::Any, ray casts can be performed against both visible and hidden entities.

Defaults to RayCastVisibility::VisibleInView, only performing picking against visible entities that are in the view of a camera.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MeshPickingSettings {
    pub require_markers: bool,
    pub ray_cast_visibility: RayCastVisibility,
}
```

---

## Enum RunFixedMainLoopSystems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.RunFixedMainLoopSystems.html

**Contents:**
- Enum RunFixedMainLoopSystems Copy item path
- Variants§
  - BeforeFixedMainLoop
    - §Example
  - FixedMainLoop
    - §Example
  - AfterFixedMainLoop
    - §Example
- Trait Implementations§
  - impl Clone for RunFixedMainLoopSystems

Set enum for the systems that want to run inside RunFixedMainLoop, but before or after the fixed update logic. Systems in this set will run exactly once per frame, regardless of the number of fixed updates. They will also run under a variable timestep.

This is useful for handling things that need to run every frame, but also need to be read by the fixed update logic. See the individual variants for examples of what kind of systems should be placed in each.

Note that in contrast to most other Bevy schedules, systems added directly to RunFixedMainLoop will not be parallelized between each other.

Runs before the fixed update logic.

A good example of a system that fits here is camera movement, which needs to be updated in a variable timestep, as you want the camera to move with as much precision and updates as the frame rate allows. A physics system that needs to read the camera position and orientation, however, should run in the fixed update logic, as it needs to be deterministic and run at a fixed rate for better stability. Note that we are not placing the camera movement system in Update, as that would mean that the physics system already ran at that point.

Contains the fixed update logic. Runs FixedMain zero or more times based on delta of Time<Virtual> and Time::overstep.

Don’t place systems here, use FixedUpdate and friends instead. Use this system instead to order your systems to run specifically inbetween the fixed update logic and all other systems that run in RunFixedMainLoopSystems::BeforeFixedMainLoop or RunFixedMainLoopSystems::AfterFixedMainLoop.

Runs after the fixed update logic.

A good example of a system that fits here is a system that interpolates the transform of an entity between the last and current fixed update. See the fixed timestep example for more details.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum RunFixedMainLoopSystems {
    BeforeFixedMainLoop,
    FixedMainLoop,
    AfterFixedMainLoop,
}
```

Example 2 (unknown):
```unknown
App::new()
  .add_systems(
    RunFixedMainLoop,
    update_camera_rotation.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop))
  .add_systems(FixedUpdate, update_physics);
```

Example 3 (unknown):
```unknown
App::new()
  .add_systems(FixedUpdate, update_physics)
  .add_systems(
    RunFixedMainLoop,
    (
      // This system will be called before all interpolation systems
      // that third-party plugins might add.
      prepare_for_interpolation
        .after(RunFixedMainLoopSystems::FixedMainLoop)
        .before(RunFixedMainLoopSystems::AfterFixedMainLoop),
    )
  );
```

Example 4 (unknown):
```unknown
App::new()
  .add_systems(FixedUpdate, update_physics)
  .add_systems(
    RunFixedMainLoop,
    interpolate_transforms.in_set(RunFixedMainLoopSystems::AfterFixedMainLoop));
```

---

## Function update_source Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/fn.update_source.html

**Contents:**
- Function update_source Copy item path

add/remove Inherited::<C> and C for entities with a direct Propagate::<C>

**Examples:**

Example 1 (unknown):
```unknown
pub fn update_source<C, F>(
    commands: Commands<'_, '_>,
    changed: Query<'_, '_, (Entity, &Propagate<C>), (Or<(Changed<Propagate<C>>, Without<Inherited<C>>)>, Without<PropagateStop<C>>)>,
    removed: RemovedComponents<'_, '_, Propagate<C>>,
)where
    C: Component + Clone + PartialEq,
    F: QueryFilter,
```

---

## Trait CubicGenerator Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.CubicGenerator.html

**Contents:**
- Trait CubicGenerator Copy item path
- Required Associated Types§
    - type Error
- Required Methods§
    - fn to_curve(&self) -> Result<CubicCurve<P>, Self::Error>
- Implementors§
  - impl<P> CubicGenerator<P> for LinearSpline<P>where P: VectorSpace,
    - type Error = InsufficientDataError
  - impl<P> CubicGenerator<P> for CubicBSpline<P>where P: VectorSpace<Scalar = f32>,
    - type Error = InsufficientDataError

Implement this on cubic splines that can generate a cubic curve from their spline parameters.

An error type indicating why construction might fail.

Build a CubicCurve by computing the interpolation coefficients for each curve segment.

**Examples:**

Example 1 (unknown):
```unknown
pub trait CubicGenerator<P>where
    P: VectorSpace,{
    type Error;

    // Required method
    fn to_curve(&self) -> Result<CubicCurve<P>, Self::Error>;
}
```

---

## Struct Assets Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Assets.html

**Contents:**
- Struct Assets Copy item path
- Implementations§
  - impl<A> Assets<A>where A: Asset,
    - pub fn get_handle_provider(&self) -> AssetHandleProvider
    - pub fn reserve_handle(&self) -> Handle<A>
    - pub fn insert( &mut self, id: impl Into<AssetId<A>>, asset: A, ) -> Result<(), InvalidGenerationError>
      - Examples found in repository?
    - pub fn get_or_insert_with( &mut self, id: impl Into<AssetId<A>>, insert_fn: impl FnOnce() -> A, ) -> Result<&mut A, InvalidGenerationError>
    - pub fn contains(&self, id: impl Into<AssetId<A>>) -> bool
    - pub fn add(&mut self, asset: impl Into<A>) -> Handle<A>

Stores Asset values identified by their AssetId.

Assets identified by AssetId::Index will be stored in a “dense” vec-like storage. This is more efficient, but it means that the assets can only be identified at runtime. This is the default behavior.

Assets identified by AssetId::Uuid will be stored in a hashmap. This is less efficient, but it means that the assets can be referenced at compile time.

This tracks (and queues) AssetEvent events whenever changes to the collection occur. To check whether the asset used by a given component has changed (due to a change in the handle or the underlying asset) use the AssetChanged query filter.

Retrieves an AssetHandleProvider capable of reserving new Handle values for assets that will be stored in this collection.

Reserves a new Handle for an asset that will be stored in this collection.

Inserts the given asset, identified by the given id. If an asset already exists for id, it will be replaced.

Note: This will never return an error for UUID asset IDs.

Retrieves an Asset stored for the given id if it exists. If it does not exist, it will be inserted using insert_fn.

Note: This will never return an error for UUID asset IDs.

Returns true if the id exists in this collection. Otherwise it returns false.

Adds the given asset and allocates a new strong Handle for it.

Upgrade an AssetId into a strong Handle that will prevent asset drop.

Returns None if the provided id is not part of this Assets collection. For example, it may have been dropped earlier.

Retrieves a reference to the Asset with the given id, if it exists. Note that this supports anything that implements Into<AssetId<A>>, which includes Handle and AssetId.

Retrieves a mutable reference to the Asset with the given id, if it exists. Note that this supports anything that implements Into<AssetId<A>>, which includes Handle and AssetId.

Retrieves a mutable reference to the Asset with the given id, if it exists.

This is the same as Assets::get_mut except it doesn’t emit AssetEvent::Modified.

Removes (and returns) the Asset with the given id, if it exists. Note that this supports anything that implements Into<AssetId<A>>, which includes Handle and AssetId.

Removes (and returns) the Asset with the given id, if it exists. This skips emitting AssetEvent::Removed. Note that this supports anything that implements Into<AssetId<A>>, which includes Handle and AssetId.

This is the same as Assets::remove except it doesn’t emit AssetEvent::Removed.

Returns tr

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Assets<A>where
    A: Asset,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
226fn resize_image(
227    image_mesh: Query<(&MeshMaterial3d<StandardMaterial>, &Mesh3d), With<HDRViewer>>,
228    materials: Res<Assets<StandardMaterial>>,
229    mut meshes: ResMut<Assets<Mesh>>,
230    images: Res<Assets<Image>>,
231    mut image_event_reader: MessageReader<AssetEvent<Image>>,
232) {
233    for event in image_event_reader.read() {
234        let (AssetEvent::Added { id } | AssetEvent::Modified { id }) = event else {
235            continue;
236        };
237
238        for (mat_h, mesh_h) in &image_mesh {
239            let Some(mat) = materials.get(mat_h) else {
240      
...
```

Example 3 (javascript):
```javascript
97fn setup(mut assets: ResMut<Assets<SineAudio>>, mut commands: Commands) {
98    // add a `SineAudio` to the asset server so that it can be played
99    let audio_handle = assets.add(SineAudio {
100        frequency: 440., // this is the frequency of A4
101    });
102    commands.spawn(AudioPlayer(audio_handle));
103}
```

Example 4 (unknown):
```unknown
12fn setup(
13    mut commands: Commands,
14    mut meshes: ResMut<Assets<Mesh>>,
15    mut materials: ResMut<Assets<ColorMaterial>>,
16) {
17    commands.spawn(Camera2d);
18
19    commands.spawn((
20        Mesh2d(meshes.add(Rectangle::default())),
21        MeshMaterial2d(materials.add(Color::from(PURPLE))),
22        Transform::default().with_scale(Vec3::splat(128.)),
23    ));
24}
```

---

## Struct PluginGroupBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PluginGroupBuilder.html

**Contents:**
- Struct PluginGroupBuilder Copy item path
- Implementations§
  - impl PluginGroupBuilder
    - pub fn start<PG>() -> PluginGroupBuilderwhere PG: PluginGroup,
      - Examples found in repository?
    - pub fn contains<T>(&self) -> boolwhere T: Plugin,
    - pub fn enabled<T>(&self) -> boolwhere T: Plugin,
    - pub fn set<T>(self, plugin: T) -> PluginGroupBuilderwhere T: Plugin,
      - §Panics
      - Examples found in repository?

Facilitates the creation and configuration of a PluginGroup.

Provides a build ordering to ensure that Plugins which produce/require a Resource are built before/after dependent/depending Plugins. Plugins inside the group can be disabled, enabled or reordered.

Start a new builder for the PluginGroup.

Checks if the PluginGroupBuilder contains the given Plugin.

Returns true if the PluginGroupBuilder contains the given Plugin and it’s enabled.

Sets the value of the given Plugin, if it exists.

Panics if the Plugin does not exist.

Tries to set the value of the given Plugin, if it exists.

If the given plugin doesn’t exist returns self and the passed in Plugin.

Adds the plugin Plugin at the end of this PluginGroupBuilder. If the plugin was already in the group, it is removed from its previous place.

Attempts to add the plugin Plugin at the end of this PluginGroupBuilder.

If the plugin was already in the group the addition fails.

Adds a PluginGroup at the end of this PluginGroupBuilder. If the plugin was already in the group, it is removed from its previous place.

Adds a Plugin in this PluginGroupBuilder before the plugin of type Target.

If the plugin was already the group, it is removed from its previous place.

Panics if Target is not already in this PluginGroupBuilder.

Adds a Plugin in this PluginGroupBuilder before the plugin of type Target.

If the plugin was already in the group the add fails. If there isn’t a plugin of type Target in the group the plugin we’re trying to insert is returned.

Adds a Plugin in this PluginGroupBuilder before the plugin of type Target.

If the plugin was already in the group, it is removed from its previous places. If there isn’t a plugin of type Target in the group the plugin we’re trying to insert is returned.

Adds a Plugin in this PluginGroupBuilder after the plugin of type Target.

If the plugin was already the group, it is removed from its previous place.

Panics if Target is not already in this PluginGroupBuilder.

Adds a Plugin in this PluginGroupBuilder after the plugin of type Target.

If the plugin was already in the group the add fails. If there isn’t a plugin of type Target in the group the plugin we’re trying to insert is returned.

Adds a Plugin in this PluginGroupBuilder after the plugin of type Target.

If the plugin was already in the group, it is removed from its previous places. If there isn’t a plugin of type Target in the group the plugin we’re trying to insert is returned.

Plugins within a Pl

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct PluginGroupBuilder { /* private fields */ }
```

Example 2 (unknown):
```unknown
30    fn build(self) -> PluginGroupBuilder {
31        PluginGroupBuilder::start::<Self>()
32            .add(PrintHelloPlugin)
33            .add(PrintWorldPlugin)
34    }
```

Example 3 (unknown):
```unknown
32fn main() {
33    App::new()
34        .insert_resource(ClearColor(Color::BLACK))
35        .add_plugins((
36            DefaultPlugins
37                .set(WindowPlugin {
38                    primary_window: Some(Window {
39                        resolution: (SIZE * DISPLAY_FACTOR).into(),
40                        // uncomment for unthrottled FPS
41                        // present_mode: bevy::window::PresentMode::AutoNoVsync,
42                        ..default()
43                    }),
44                    ..default()
45                })
46                .set(ImagePlugin::defau
...
```

Example 4 (javascript):
```javascript
182fn main() {
183    let render_debug_flags = RenderDebugFlags::ALLOW_COPIES_FROM_INDIRECT_PARAMETERS;
184
185    App::new()
186        .add_plugins(
187            DefaultPlugins
188                .set(WindowPlugin {
189                    primary_window: Some(Window {
190                        title: "Bevy Occlusion Culling Example".into(),
191                        ..default()
192                    }),
193                    ..default()
194                })
195                .set(RenderPlugin {
196                    debug_flags: render_debug_flags,
197                    ..default()
...
```

---

## Function vw Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vw.html

**Contents:**
- Function vw Copy item path
      - Examples found in repository?

Returns a Val::Vw representing a percentage of the viewport width.

**Examples:**

Example 1 (unknown):
```unknown
pub fn vw<T>(value: T) -> Valwhere
    T: ValNum,
```

Example 2 (unknown):
```unknown
127fn setup(mut commands: Commands) {
128    commands.spawn(Camera2d);
129
130    commands.spawn((
131        Node {
132            width: vw(100),
133            height: vh(100),
134            flex_direction: FlexDirection::Column,
135            padding: UiRect::all(px(12)),
136            ..default()
137        },
138        LogViewerRoot,
139    ));
140}
```

Example 3 (javascript):
```javascript
263fn spawn_button(
264    commands: &mut ChildSpawnerCommands,
265    background_color: Color,
266    buttons: f32,
267    column: usize,
268    row: usize,
269    spawn_text: bool,
270    border: UiRect,
271    border_color: BorderColor,
272    image: Option<Handle<Image>>,
273) {
274    let width = vw(90.0 / buttons);
275    let height = vh(90.0 / buttons);
276    let margin = UiRect::axes(width * 0.05, height * 0.05);
277    let mut builder = commands.spawn((
278        Button,
279        Node {
280            width,
281            height,
282            margin,
283            align_items:
...
```

Example 4 (unknown):
```unknown
68fn spawn_with_viewport_coords(commands: &mut Commands) {
69    commands
70        .spawn((
71            Node {
72                width: vw(100),
73                height: vh(100),
74                border: UiRect::axes(vw(5), vh(5)),
75                flex_wrap: FlexWrap::Wrap,
76                ..default()
77            },
78            BorderColor::all(PALETTE[0]),
79            Coords::Viewport,
80        ))
81        .with_children(|builder| {
82            builder.spawn((
83                Node {
84                    width: vw(30),
85                    height: vh(30),
86             
...
```

---

## Enum RunMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/enum.RunMode.html

**Contents:**
- Enum RunMode Copy item path
- Variants§
  - Loop
    - Fields
  - Once
- Trait Implementations§
  - impl Clone for RunMode
    - fn clone(&self) -> RunMode
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for RunMode

Determines the method used to run an App’s Schedule.

It is used in the ScheduleRunnerPlugin.

Indicates that the App’s schedule should run repeatedly.

The minimum Duration to wait after a Schedule has completed before repeating. A value of None will not wait.

Indicates that the App’s schedule should run only once.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum RunMode {
    Loop {
        wait: Option<Duration>,
    },
    Once,
}
```

---

## Struct TouchInput Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TouchInput.html

**Contents:**
- Struct TouchInput Copy item path
  - §Logic
  - §Note
- Fields§
- Trait Implementations§
  - impl Clone for TouchInput
    - fn clone(&self) -> TouchInput
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for TouchInput
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

Every time the user touches the screen, a new TouchPhase::Started event with an unique identifier for the finger is generated. When the finger is lifted, the TouchPhase::Ended event is generated with the same finger id.

After a TouchPhase::Started event has been emitted, there may be zero or more TouchPhase::Moved events when the finger is moved or the touch pressure changes.

The finger id may be reused by the system after an TouchPhase::Ended event. The user should assume that a new TouchPhase::Started event received with the same id has nothing to do with the old finger and is a new finger.

A TouchPhase::Canceled event is emitted when the system has canceled tracking this touch, such as when the window loses focus, or on iOS if the user moves the device against their face.

This event is the translated version of the WindowEvent::Touch from the winit crate. It is available to the end user and can be used for game logic.

The phase of the touch input.

The position of the finger on the touchscreen.

The window entity registering the touch.

Describes how hard the screen was pressed.

May be None if the platform does not support pressure sensitivity. This feature is only available on iOS 9.0+ and Windows 8+.

The unique identifier of the finger.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TouchInput {
    pub phase: TouchPhase,
    pub position: Vec2,
    pub window: Entity,
    pub force: Option<ForceTouch>,
    pub id: u64,
}
```

---

## Struct Camera2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Camera2d.html

**Contents:**
- Struct Camera2d Copy item path
- Trait Implementations§
  - impl Clone for Camera2d
    - fn clone(&self) -> Camera2d
    - fn clone_from(&mut self, source: &Self)
  - impl Component for Camera2dwhere Camera2d: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

A 2D camera component. Enables the 2D render graph for a Camera.

Required Components: Camera, Projection, Frustum.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Camera2d;
```

---

## Struct SubApp Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SubApp.html

**Contents:**
- Struct SubApp Copy item path
- §Example
- Fields§
- Implementations§
  - impl SubApp
    - pub fn new() -> SubApp
    - pub fn world(&self) -> &World
      - Examples found in repository?
    - pub fn world_mut(&mut self) -> &mut World
      - Examples found in repository?

A secondary application with its own World. These can run independently of each other.

These are useful for situations where certain processes (e.g. a render thread) need to be kept separate from the main application.

The schedule that will be run by update.

Returns a default, empty SubApp.

Returns a reference to the World.

Returns a mutable reference to the World.

Runs the default schedule.

Does not clear internal trackers used for change detection.

Runs the default schedule and updates internal component trackers.

Extracts data from world into the app’s world using the registered extract method.

Note: There is no default extract method. Calling extract does nothing if set_extract has not been called.

Sets the method that will be called by extract.

The first argument is the World to extract data from, the second argument is the app World.

Take the function that will be called by extract out of the app, if any was set, and replace it with None.

If you use Bevy, bevy_render will set a default extract function used to extract data from the main world into the render world as part of the Extract phase. In that case, you cannot replace it with your own function. Instead, take the Bevy default function with this, and install your own instead which calls the Bevy default.

See App::insert_resource.

See App::init_resource.

See App::add_systems.

See App::register_system.

See App::configure_sets.

See App::add_schedule.

See App::init_schedule.

See App::get_schedule.

See App::get_schedule_mut.

See App::edit_schedule.

See App::configure_schedules.

See App::allow_ambiguous_component.

See App::allow_ambiguous_resource.

See App::ignore_ambiguity.

See App::add_message.

See App::add_message.

See App::add_plugins.

See App::is_plugin_added.

See App::get_added_plugins.

Return the state of plugins.

Runs Plugin::finish for each plugin.

Runs Plugin::cleanup for each plugin.

See App::register_type.

See App::register_type_data.

See App::register_function.

See App::register_function_with_name.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SubApp {
    pub update_schedule: Option<Interned<dyn ScheduleLabel>>,
    /* private fields */
}
```

Example 2 (javascript):
```javascript
#[derive(Resource, Default)]
struct Val(pub i32);

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, AppLabel)]
struct ExampleApp;

// Create an app with a certain resource.
let mut app = App::new();
app.insert_resource(Val(10));

// Create a sub-app with the same resource and a single schedule.
let mut sub_app = SubApp::new();
sub_app.update_schedule = Some(Main.intern());
sub_app.insert_resource(Val(100));

// Setup an extract function to copy the resource's value in the main world.
sub_app.set_extract(|main_world, sub_world| {
    sub_world.resource_mut::<Val>().0 = main_world.resource::<Va
...
```

Example 3 (javascript):
```javascript
76fn count_ambiguities(sub_app: &SubApp) -> AmbiguitiesCount {
77    let schedules = sub_app.world().resource::<Schedules>();
78    let mut ambiguities = <HashMap<_, _>>::default();
79    for (_, schedule) in schedules.iter() {
80        let ambiguities_in_schedule = schedule.graph().conflicting_systems().len();
81        ambiguities.insert(schedule.label(), ambiguities_in_schedule);
82    }
83    AmbiguitiesCount(ambiguities)
84}
```

Example 4 (javascript):
```javascript
63fn configure_ambiguity_detection(sub_app: &mut SubApp) {
64    let mut schedules = sub_app.world_mut().resource_mut::<Schedules>();
65    for (_, schedule) in schedules.iter_mut() {
66        schedule.set_build_settings(ScheduleBuildSettings {
67            // NOTE: you can change this to `LogLevel::Ignore` to easily see the current number of ambiguities.
68            ambiguity_detection: LogLevel::Warn,
69            use_shortnames: false,
70            ..default()
71        });
72    }
73}
```

---

## Struct UnevenCore Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UnevenCore.html

**Contents:**
- Struct UnevenCore Copy item path
- §Example
- Fields§
  - §Invariants
  - §Invariants
- Implementations§
  - impl<T> UnevenCore<T>
    - pub fn new( timed_samples: impl IntoIterator<Item = (f32, T)>, ) -> Result<UnevenCore<T>, UnevenCoreError>
    - pub fn domain(&self) -> Interval
      - §Panics

The data core of a curve defined by unevenly-spaced samples or keyframes. The intention is to use this in concert with implicitly or explicitly-defined interpolation in user-space in order to implement the curve interface using domain and sample_with.

The internals are made transparent to give curve authors freedom, but the provided constructor enforces the required invariants, and the methods maintain those invariants.

The times for the samples of this curve.

This must always have a length of at least 2, be sorted, and have no duplicated or non-finite times.

The samples corresponding to the times for this curve.

This must always have the same length as times.

Create a new UnevenCore. The given samples are filtered to finite times and sorted internally; if there are not at least 2 valid timed samples, an error will be returned.

The domain of the curve derived from this core.

This method may panic if the type’s invariants aren’t satisfied.

Obtain a value from the held samples using the given interpolation to interpolate between adjacent samples.

The interpolation takes two values by reference together with a scalar parameter and produces an owned value. The expectation is that interpolation(&x, &y, 0.0) and interpolation(&x, &y, 1.0) are equivalent to x and y respectively.

Given a time t, obtain a InterpolationDatum which governs how interpolation might recover a sample at time t. For example, when a Between value is returned, its contents can be used to interpolate between the two contained values with the given parameter. The other variants give additional context about where the value is relative to the family of samples.

Like sample_interp, but the returned values include the sample times. This can be useful when sample interpolation is not scale-invariant.

This core, but with the sample times moved by the map f. In principle, when f is monotone, this is equivalent to CurveExt::reparametrize, but the function inputs to each are inverses of one another.

The samples are re-sorted by time after mapping and deduplicated by output time, so the function f should generally be injective over the set of sample times, otherwise data will be deleted.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UnevenCore<T> {
    pub times: Vec<f32>,
    pub samples: Vec<T>,
}
```

Example 2 (javascript):
```javascript
// Let's make a curve formed by interpolating rotations.
// We'll support two common modes of interpolation:
// - Normalized linear: First do linear interpolation, then normalize to get a valid rotation.
// - Spherical linear: Interpolate through valid rotations with constant angular velocity.
enum InterpolationMode {
    NormalizedLinear,
    SphericalLinear,
}

// Our interpolation modes will be driven by traits.
trait NormalizedLinearInterpolate {
    fn nlerp(&self, other: &Self, t: f32) -> Self;
}

trait SphericalLinearInterpolate {
    fn slerp(&self, other: &Self, t: f32) -> Self;
}

//
...
```

---

## Struct ChainCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ChainCurve.html

**Contents:**
- Struct ChainCurve Copy item path
- Trait Implementations§
  - impl<T, C, D> Clone for ChainCurve<T, C, D>where T: Clone, C: Clone, D: Clone,
    - fn clone(&self) -> ChainCurve<T, C, D>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C, D> Curve<T> for ChainCurve<T, C, D>where C: Curve<T>, D: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

The curve that results from chaining one curve with another. The second curve is effectively reparametrized so that its start is at the end of the first.

For this to be well-formed, the first curve’s domain must be right-finite and the second’s must be left-finite.

Curves of this type are produced by CurveExt::chain.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ChainCurve<T, C, D> { /* private fields */ }
```

---

## Struct OnTransition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.OnTransition.html

**Contents:**
- Struct OnTransition Copy item path
- Fields§
- Trait Implementations§
  - impl<S> Clone for OnTransition<S>where S: Clone + States,
    - fn clone(&self) -> OnTransition<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for OnTransition<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Default for OnTransition<S>where S: Default + States,
    - fn default() -> OnTransition<S>

The label of a Schedule that only runs whenever State<S> exits AND enters the provided exited and entered states.

Systems added to this schedule are always ran after OnExit, and before OnEnter.

This schedule will run on identity transitions.

The state being exited.

The state being entered.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct OnTransition<S>where
    S: States,{
    pub exited: S,
    pub entered: S,
}
```

---

## Enum JustifyItems Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.JustifyItems.html

**Contents:**
- Enum JustifyItems Copy item path
- Variants§
  - Default
  - Start
  - End
  - Center
  - Baseline
  - Stretch
- Implementations§
  - impl JustifyItems

Used to control how each individual item is aligned by default within the space they’re given.

https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items

The items are packed in their default position as if no alignment was applied.

The items are packed towards the start of the axis.

The items are packed towards the end of the axis.

The items are packed along the center of the axis

The items are packed such that their baselines align.

The items are stretched to fill the space they’re given.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum JustifyItems {
    Default,
    Start,
    End,
    Center,
    Baseline,
    Stretch,
}
```

---

## Struct AssetPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AssetPlugin.html

**Contents:**
- Struct AssetPlugin Copy item path
- Fields§
- Trait Implementations§
  - impl Default for AssetPlugin
    - fn default() -> AssetPlugin
  - impl Plugin for AssetPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

Provides “asset” loading and processing functionality. An Asset is a “runtime value” that is loaded from an AssetSource, which can be something like a filesystem, a network, etc.

Supports flexible “modes”, such as AssetMode::Processed and AssetMode::Unprocessed that enable using the asset workflow that best suits your project.

The default file path to use (relative to the project root) for unprocessed assets.

The default file path to use (relative to the project root) for processed assets.

If set, will override the default “watch for changes” setting. By default “watch for changes” will be false unless the watch cargo feature is set. watch can be enabled manually, or it will be automatically enabled if a specific watcher like file_watcher is enabled.

Most use cases should leave this set to None and enable a specific watcher feature such as file_watcher to enable watching for dev-scenarios.

The AssetMode to use for this server.

How/If asset meta files should be checked.

How to handle load requests of files that are outside the approved directories.

Approved folders are AssetPlugin::file_path and the folder of each AssetSource. Subfolders within these folders are also valid.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AssetPlugin {
    pub file_path: String,
    pub processed_file_path: String,
    pub watch_for_changes_override: Option<bool>,
    pub mode: AssetMode,
    pub meta_check: AssetMetaCheck,
    pub unapproved_path_mode: UnapprovedPathMode,
}
```

---

## Trait Curve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Curve.html

**Contents:**
- Trait Curve Copy item path
- Required Methods§
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
- Provided Methods§
    - fn sample(&self, t: f32) -> Option<T>
      - Examples found in repository?
    - fn sample_clamped(&self, t: f32) -> T
- Implementors§
  - impl Curve<f32> for EaseFunction

A trait for a type that can represent values of type T parametrized over a fixed interval.

Typical examples of this are actual geometric curves where T: VectorSpace, but other kinds of output data can be represented as well. See the module-level documentation for details.

The interval over which this curve is parametrized.

This is the range of values of t where we can sample the curve and receive valid output.

Sample a point on this curve at the parameter value t, extracting the associated value. This is the unchecked version of sampling, which should only be used if the sample time t is already known to lie within the curve’s domain.

Values sampled from outside of a curve’s domain are generally considered invalid; data which is nonsensical or otherwise useless may be returned in such a circumstance, and extrapolation beyond a curve’s domain should not be relied upon.

Sample a point on this curve at the parameter value t, returning None if the point is outside of the curve’s domain.

Sample a point on this curve at the parameter value t, clamping t to lie inside the domain of the curve.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Curve<T> {
    // Required methods
    fn domain(&self) -> Interval;
    fn sample_unchecked(&self, t: f32) -> T;

    // Provided methods
    fn sample(&self, t: f32) -> Option<T> { ... }
    fn sample_clamped(&self, t: f32) -> T { ... }
}
```

Example 2 (javascript):
```javascript
124fn display_curves(
125    mut gizmos: Gizmos,
126    ease_functions: Query<(&EaseFunctionPlot, &Transform, &Children)>,
127    mut transforms: Query<&mut Transform, Without<EaseFunctionPlot>>,
128    mut ui_text: Single<&mut Text>,
129    time: Res<Time>,
130) {
131    let samples = 100;
132    let duration = 2.5;
133    let time_margin = 0.5;
134
135    let now = ((time.elapsed_secs() % (duration + time_margin * 2.0) - time_margin) / duration)
136        .clamp(0.0, 1.0);
137
138    ui_text.0 = format!("Progress: {now:.2}");
139
140    for (EaseFunctionPlot(function, color), transform, chi
...
```

---

## Enum SpritePickingMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.SpritePickingMode.html

**Contents:**
- Enum SpritePickingMode Copy item path
- Variants§
  - BoundingBox
  - AlphaThreshold(f32)
- Trait Implementations§
  - impl Clone for SpritePickingMode
    - fn clone(&self) -> SpritePickingMode
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for SpritePickingMode
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

How should the SpritePickingPlugin handle picking and how should it handle transparent pixels

Even if a sprite is picked on a transparent pixel, it should still count within the backend. Only consider the rect of a given sprite.

Ignore any part of a sprite which has a lower alpha value than the threshold (inclusive) Threshold is given as an f32 representing the alpha value in a Bevy Color Value

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum SpritePickingMode {
    BoundingBox,
    AlphaThreshold(f32),
}
```

---

## Trait SystemParamFunction Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SystemParamFunction.html

**Contents:**
- Trait SystemParamFunction Copy item path
- §Example
- Required Associated Types§
    - type In: SystemInput
    - type Out
    - type Param: SystemParam
- Required Methods§
    - fn run( &mut self, input: <Self::In as SystemInput>::Inner<'_>, param_value: <Self::Param as SystemParam>::Item<'_, '_>, ) -> Self::Out
- Implementors§
  - impl<In, Out, Func> SystemParamFunction<(HasSystemInput, fn(In) -> Out)> for Funcwhere Func: Send + Sync + 'static, &'a mut Func: for<'a> FnMut(In) -> Out + for<'a> FnMut(<In as SystemInput>::Param<'_>), In: SystemInput + 'static, Out: 'static,

A trait implemented for all functions that can be used as Systems.

This trait can be useful for making your own systems which accept other systems, sometimes called higher order systems.

This should be used in combination with ParamSet when calling other systems within your system. Using ParamSet in this case avoids SystemParam collisions.

To create something like PipeSystem, but in entirely safe code.

The input type of this system. See System::In.

The return type of this system. See System::Out.

The SystemParam/s used by this system to access the World.

Executes this system once. See System::run or System::run_unsafe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait SystemParamFunction<Marker>:
    Send
    + Sync
    + 'static {
    type In: SystemInput;
    type Out;
    type Param: SystemParam;

    // Required method
    fn run(
        &mut self,
        input: <Self::In as SystemInput>::Inner<'_>,
        param_value: <Self::Param as SystemParam>::Item<'_, '_>,
    ) -> Self::Out;
}
```

Example 2 (javascript):
```javascript
use std::num::ParseIntError;

use bevy_ecs::prelude::*;
use bevy_ecs::system::StaticSystemInput;

/// Pipe creates a new system which calls `a`, then calls `b` with the output of `a`
pub fn pipe<A, B, AMarker, BMarker>(
    mut a: A,
    mut b: B,
) -> impl FnMut(StaticSystemInput<A::In>, ParamSet<(A::Param, B::Param)>) -> B::Out
where
    // We need A and B to be systems, add those bounds
    A: SystemParamFunction<AMarker>,
    B: SystemParamFunction<BMarker>,
    for<'a> B::In: SystemInput<Inner<'a> = A::Out>,
{
    // The type of `params` is inferred based on the return of this function ab
...
```

---

## Struct AnimationGraphAssetLoader Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationGraphAssetLoader.html

**Contents:**
- Struct AnimationGraphAssetLoader Copy item path
- Trait Implementations§
  - impl AssetLoader for AnimationGraphAssetLoader
    - type Asset = AnimationGraph
    - type Settings = ()
    - type Error = AnimationGraphLoadError
    - async fn load( &self, reader: &mut dyn Reader, _: &<AnimationGraphAssetLoader as AssetLoader>::Settings, load_context: &mut LoadContext<'_>, ) -> Result<<AnimationGraphAssetLoader as AssetLoader>::Asset, <AnimationGraphAssetLoader as AssetLoader>::Error>
    - fn extensions(&self) -> &[&str]
  - impl Default for AnimationGraphAssetLoader
    - fn default() -> AnimationGraphAssetLoader

An AssetLoader that can load AnimationGraphs as assets.

The canonical extension for AnimationGraphs is .animgraph.ron. Plain .animgraph is supported as well.

Processes the asset in an asynchronous closure.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationGraphAssetLoader;
```

---

## Enum SerializedAnimationNodeType Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.SerializedAnimationNodeType.html

**Contents:**
- Enum SerializedAnimationNodeType Copy item path
- Variants§
  - Clip(MigrationSerializedAnimationClip)
  - Blend
  - Add
- Trait Implementations§
  - impl<'de> Deserialize<'de> for SerializedAnimationNodeType
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<SerializedAnimationNodeType, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,
  - impl Serialize for SerializedAnimationNodeType
    - fn serialize<__S>( &self, __serializer: __S, ) -> Result<<__S as Serializer>::Ok, <__S as Serializer>::Error>where __S: Serializer,

A version of AnimationNodeType suitable for serializing as part of a SerializedAnimationGraphNode asset.

Corresponds to AnimationNodeType::Clip.

Corresponds to AnimationNodeType::Blend.

Corresponds to AnimationNodeType::Add.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum SerializedAnimationNodeType {
    Clip(MigrationSerializedAnimationClip),
    Blend,
    Add,
}
```

---

## Trait AppExtStates Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AppExtStates.html

**Contents:**
- Trait AppExtStates Copy item path
- Required Methods§
    - fn init_state<S>(&mut self) -> &mut Selfwhere S: FreelyMutableState + FromWorld,
    - fn insert_state<S>(&mut self, state: S) -> &mut Selfwhere S: FreelyMutableState,
    - fn add_computed_state<S>(&mut self) -> &mut Selfwhere S: ComputedStates,
    - fn add_sub_state<S>(&mut self) -> &mut Selfwhere S: SubStates,
    - fn register_type_state<S>(&mut self) -> &mut Selfwhere S: States + FromReflect + GetTypeRegistration + Typed,
    - fn register_type_mutable_state<S>(&mut self) -> &mut Selfwhere S: FreelyMutableState + FromReflect + GetTypeRegistration + Typed,
- Dyn Compatibility§
- Implementors§

State installation methods for App and SubApp.

Initializes a State with standard starting values.

This method is idempotent: it has no effect when called again using the same generic type.

Adds State<S> and NextState<S> resources, and enables use of the OnEnter, OnTransition and OnExit schedules. These schedules are triggered before Update and at startup.

If you would like to control how other systems run based on the current state, you can emulate this behavior using the in_state SystemCondition.

Note that you can also apply state transitions at other points in the schedule by triggering the StateTransition schedule manually.

The use of any states requires the presence of StatesPlugin (which is included in DefaultPlugins).

Inserts a specific State to the current App and overrides any State previously added of the same type.

Adds State<S> and NextState<S> resources, and enables use of the OnEnter, OnTransition and OnExit schedules. These schedules are triggered before Update and at startup.

If you would like to control how other systems run based on the current state, you can emulate this behavior using the in_state SystemCondition.

Note that you can also apply state transitions at other points in the schedule by triggering the StateTransition schedule manually.

Sets up a type implementing ComputedStates.

This method is idempotent: it has no effect when called again using the same generic type.

Sets up a type implementing SubStates.

This method is idempotent: it has no effect when called again using the same generic type.

Registers the state type T using App::register_type, and adds ReflectState type data to T in the type registry.

This enables reflection code to access the state. For detailed information, see the docs on crate::reflect::ReflectState .

Registers the state type T using App::register_type, and adds crate::reflect::ReflectState and crate::reflect::ReflectFreelyMutableState type data to T in the type registry.

This enables reflection code to access and modify the state. For detailed information, see the docs on crate::reflect::ReflectState and crate::reflect::ReflectFreelyMutableState.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AppExtStates {
    // Required methods
    fn init_state<S>(&mut self) -> &mut Self
       where S: FreelyMutableState + FromWorld;
    fn insert_state<S>(&mut self, state: S) -> &mut Self
       where S: FreelyMutableState;
    fn add_computed_state<S>(&mut self) -> &mut Self
       where S: ComputedStates;
    fn add_sub_state<S>(&mut self) -> &mut Self
       where S: SubStates;
    fn register_type_state<S>(&mut self) -> &mut Self
       where S: States + FromReflect + GetTypeRegistration + Typed;
    fn register_type_mutable_state<S>(&mut self) -> &mut Self
       where S: Freel
...
```

---

## Macro children Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.children.html

**Contents:**
- Macro children Copy item path

Returns a SpawnRelatedBundle that will insert the Children component, spawn a SpawnableList of entities with given bundles that relate to the Children entity via the ChildOf component, and reserve space in the Children for each spawned entity.

Any additional arguments will be interpreted as bundles to be spawned.

Also see related for a version of this that works with any RelationshipTarget type.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! children {
    [$($child:expr),*$(,)?] => { ... };
}
```

Example 2 (javascript):
```javascript
let mut world = World::new();
world.spawn((
    Name::new("Root"),
    children![
        Name::new("Child1"),
        (
            Name::new("Child2"),
            children![Name::new("Grandchild")]
        )
    ]
));
```

---

## Struct WithOneRelated Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.WithOneRelated.html

**Contents:**
- Struct WithOneRelated Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<R> SpawnableList<R> for WithOneRelatedwhere R: Relationship,
    - fn spawn(this: MovingPtr<'_, WithOneRelated>, world: &mut World, entity: Entity)
    - fn size_hint(&self) -> usize
- Auto Trait Implementations§
  - impl Freeze for WithOneRelated
  - impl RefUnwindSafe for WithOneRelated
  - impl Send for WithOneRelated

A wrapper over an Entity indicating that an entity should be added. This is intended to be used for hierarchical spawning via traits like SpawnableList and SpawnRelated.

Unlike WithRelated this only adds one entity.

Also see the children and related macros that abstract over the Spawn API.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WithOneRelated(pub Entity);
```

Example 2 (javascript):
```javascript
let mut world = World::new();

let child1 = world.spawn(Name::new("Child1")).id();

world.spawn((
    Name::new("Root"),
    Children::spawn((
        // This adds the already existing entity as a child of Root.
        WithOneRelated(child1),
    )),
));
```

---

## Enum ChainError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ChainError.html

**Contents:**
- Enum ChainError Copy item path
- Variants§
  - FirstEndInfinite
  - SecondStartInfinite
- Trait Implementations§
  - impl Debug for ChainError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for ChainError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for ChainError

An error indicating that an end-to-end composition couldn’t be performed because of malformed inputs.

The right endpoint of the first curve was infinite.

The left endpoint of the second curve was infinite.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ChainError {
    FirstEndInfinite,
    SecondStartInfinite,
}
```

---

## Enum Justify Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Justify.html

**Contents:**
- Enum Justify Copy item path
- Variants§
  - Left
  - Center
  - Right
  - Justified
- Trait Implementations§
  - impl Clone for Justify
    - fn clone(&self) -> Justify
    - fn clone_from(&mut self, source: &Self)

Describes the horizontal alignment of multiple lines of text relative to each other.

This only affects the internal positioning of the lines of text within a text entity and does not affect the text entity’s position.

Has no affect on a single line text entity, unless used together with a TextBounds component with an explicit width value.

Leftmost character is immediately to the right of the render position. Bounds start from the render position and advance rightwards.

Leftmost & rightmost characters are equidistant to the render position. Bounds start from the render position and advance equally left & right.

Rightmost character is immediately to the left of the render position. Bounds start from the render position and advance leftwards.

Words are spaced so that leftmost & rightmost characters align with their margins. Bounds start from the render position and advance equally left & right.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Justify {
    Left,
    Center,
    Right,
    Justified,
}
```

---

## Struct Real Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Real.html

**Contents:**
- Struct Real Copy item path
- Trait Implementations§
  - impl Clone for Real
    - fn clone(&self) -> Real
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Real
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Real
    - fn default() -> Real
  - impl FromArg for Real

Real time clock representing elapsed wall clock time.

A specialization of the Time structure. For method documentation, see Time<Real>.

It is automatically inserted as a resource by TimePlugin and updated with time instants according to TimeUpdateStrategy.1

Note: Using TimeUpdateStrategy::ManualDuration allows for mocking the wall clock for testing purposes. Besides this use case, it is not recommended to do this, as it will no longer represent “wall clock” time as intended.

The delta() and elapsed() values of this clock should be used for anything which deals specifically with real time (wall clock time). It will not be affected by relative game speed adjustments, pausing or other adjustments.1

The clock does not count time from startup() to first_update() into elapsed, but instead will start counting time from the first update call. delta() and elapsed() will report zero on the first update as there is no previous update instant. This means that a delta() of zero must be handled without errors in application logic, as it may theoretically also happen at other times.

Instants for startup(), first_update() and last_update() are recorded and accessible.

When using TimeUpdateStrategy::ManualDuration, Time<Real> is only a mock of wall clock time. ↩ 1 2

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Real { /* private fields */ }
```

---

## Trait Decodable Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Decodable.html

**Contents:**
- Trait Decodable Copy item path
- Required Associated Types§
    - type DecoderItem: Sample + Send + Sync
    - type Decoder: Source<Item = Self::DecoderItem> + Send + Iterator
- Required Methods§
    - fn decoder(&self) -> Self::Decoder
- Implementors§
  - impl Decodable for AudioSource
    - type DecoderItem = <Decoder<Cursor<AudioSource>> as Iterator>::Item
    - type Decoder = Decoder<Cursor<AudioSource>>

A type implementing this trait can be converted to a rodio::Source type.

It must be Send and Sync in order to be registered. Types that implement this trait usually contain raw sound data that can be converted into an iterator of samples. This trait is implemented for AudioSource. Check the example decodable for how to implement this trait on a custom type.

The type of the audio samples. Usually a u16, i16 or f32, as those implement rodio::Sample. Other types can implement the rodio::Sample trait as well.

The type of the iterator of the audio samples, which iterates over samples of type Self::DecoderItem. Must be a rodio::Source so that it can provide information on the audio it is iterating over.

Build and return a Self::Decoder of the implementing type

**Examples:**

Example 1 (unknown):
```unknown
pub trait Decodable:
    Send
    + Sync
    + 'static {
    type DecoderItem: Sample + Send + Sync;
    type Decoder: Source<Item = Self::DecoderItem> + Send + Iterator;

    // Required method
    fn decoder(&self) -> Self::Decoder;
}
```

---

## Struct AnimationTransition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimationTransition.html

**Contents:**
- Struct AnimationTransition Copy item path
- Trait Implementations§
  - impl Clone for AnimationTransition
    - fn clone(&self) -> AnimationTransition
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for AnimationTransition
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for AnimationTransition
    - type This<'from_arg> = AnimationTransition
    - fn from_arg( arg: Arg<'_>, ) -> Result<<AnimationTransition as FromArg>::This<'_>, ArgError>

An animation that is being faded out as part of a transition

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimationTransition { /* private fields */ }
```

---

## Struct URect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.URect.html

**Contents:**
- Struct URect Copy item path
- Fields§
- Implementations§
  - impl URect
    - pub const EMPTY: URect
    - pub fn new(x0: u32, y0: u32, x1: u32, y1: u32) -> URect
      - §Examples
    - pub fn from_corners(p0: UVec2, p1: UVec2) -> URect
      - §Examples
    - pub fn from_center_size(origin: UVec2, size: UVec2) -> URect

A rectangle defined by two opposite corners.

The rectangle is axis aligned, and defined by its minimum and maximum coordinates, stored in URect::min and URect::max, respectively. The minimum/maximum invariant must be upheld by the user when directly assigning the fields, otherwise some methods produce invalid results. It is generally recommended to use one of the constructor methods instead, which will ensure this invariant is met, unless you already have the minimum and maximum corners.

The minimum corner point of the rect.

The maximum corner point of the rect.

An empty URect, represented by maximum and minimum corner points with max == UVec2::MIN and min == UVec2::MAX, so the rect has an extremely large negative size. This is useful, because when taking a union B of a non-empty URect A and this empty URect, B will simply equal A.

Create a new rectangle from two corner points.

The two points do not need to be the minimum and/or maximum corners. They only need to be two opposite corners.

Create a new rectangle from two corner points.

The two points do not need to be the minimum and/or maximum corners. They only need to be two opposite corners.

Create a new rectangle from its center and size.

If the size contains odd numbers they will be rounded down to the nearest whole number.

This method panics if any of the components of the size is negative or if origin - (size / 2) results in any negatives.

Create a new rectangle from its center and half-size.

This method panics if any of the components of the half-size is negative or if origin - half_size results in any negatives.

Check if the rectangle is empty.

Rectangle width (max.x - min.x).

Rectangle height (max.y - min.y).

If the full size contains odd numbers they will be rounded down to the nearest whole number when calculating the half size.

The center point of the rectangle.

If the (min + max) contains odd numbers they will be rounded down to the nearest whole number when calculating the center.

Check if a point lies within this rectangle, inclusive of its edges.

Build a new rectangle formed of the union of this rectangle and another rectangle.

The union is the smallest rectangle enclosing both rectangles.

Build a new rectangle formed of the union of this rectangle and a point.

The union is the smallest rectangle enclosing both the rectangle and the point. If the point is already inside the rectangle, this method returns a copy of the rectangle.

Build a new rectangle formed of the i

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct URect {
    pub min: UVec2,
    pub max: UVec2,
}
```

Example 2 (javascript):
```javascript
let r = URect::new(0, 4, 10, 6); // w=10 h=2
let r = URect::new(2, 4, 5, 0); // w=3 h=4
```

Example 3 (javascript):
```javascript
// Unit rect from [0,0] to [1,1]
let r = URect::from_corners(UVec2::ZERO, UVec2::ONE); // w=1 h=1
// Same; the points do not need to be ordered
let r = URect::from_corners(UVec2::ONE, UVec2::ZERO); // w=1 h=1
```

Example 4 (javascript):
```javascript
let r = URect::from_center_size(UVec2::ONE, UVec2::splat(2)); // w=2 h=2
assert_eq!(r.min, UVec2::splat(0));
assert_eq!(r.max, UVec2::splat(2));
```

---

## Enum GltfAssetLabel Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GltfAssetLabel.html

**Contents:**
- Enum GltfAssetLabel Copy item path
- Variants§
  - Scene(usize)
  - Node(usize)
  - Mesh(usize)
  - Primitive
    - Fields
  - MorphTarget
    - Fields
  - Texture(usize)

Labels that can be used to load part of a glTF

You can use GltfAssetLabel::from_asset to add it to an asset path

Or when formatting a string for the path

Scene{}: glTF Scene as a Bevy Scene

Node{}: glTF Node as a GltfNode

Mesh{}: glTF Mesh as a GltfMesh

Mesh{}/Primitive{}: glTF Primitive as a Bevy Mesh

Index of the mesh for this primitive

Index of this primitive in its parent mesh

Mesh{}/Primitive{}/MorphTargets: Morph target animation data for a glTF Primitive as a Bevy Image

Index of the mesh for this primitive

Index of this primitive in its parent mesh

Texture{}: glTF Texture as a Bevy Image

Material{}: glTF Material as a Bevy StandardMaterial

Index of this material

Used to set the Face of the material, useful if it is used with negative scale

DefaultMaterial: glTF’s default Material as a Bevy StandardMaterial

Animation{}: glTF Animation as Bevy AnimationClip

Skin{}: glTF mesh skin as GltfSkin

Skin{}/InverseBindMatrices: glTF mesh skin matrices as Bevy SkinnedMeshInverseBindposes

Add this label to an asset path

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GltfAssetLabel {
    Scene(usize),
    Node(usize),
    Mesh(usize),
    Primitive {
        mesh: usize,
        primitive: usize,
    },
    MorphTarget {
        mesh: usize,
        primitive: usize,
    },
    Texture(usize),
    Material {
        index: usize,
        is_scale_inverted: bool,
    },
    DefaultMaterial,
    Animation(usize),
    Skin(usize),
    InverseBindMatrices(usize),
}
```

Example 2 (javascript):
```javascript
fn load_gltf_scene(asset_server: Res<AssetServer>) {
    let gltf_scene: Handle<Scene> = asset_server.load(GltfAssetLabel::Scene(0).from_asset("models/FlightHelmet/FlightHelmet.gltf"));
}
```

Example 3 (javascript):
```javascript
fn load_gltf_scene(asset_server: Res<AssetServer>) {
    let gltf_scene: Handle<Scene> = asset_server.load(format!("models/FlightHelmet/FlightHelmet.gltf#{}", GltfAssetLabel::Scene(0)));
}
```

Example 4 (javascript):
```javascript
fn load_gltf_scene(asset_server: Res<AssetServer>) {
    let gltf_scene: Handle<Scene> = asset_server.load(GltfAssetLabel::Scene(0).from_asset("models/FlightHelmet/FlightHelmet.gltf"));
}
```

---

## Struct SceneRoot Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SceneRoot.html

**Contents:**
- Struct SceneRoot Copy item path
- Tuple Fields§
- Methods from Deref<Target = Handle<Scene>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§
  - impl Clone for SceneRoot

Adding this component will spawn the scene as a child of that entity. Once it’s spawned, the entity will have a SceneInstance component.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Required Components: Transform, Visibility.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SceneRoot(pub Handle<Scene>);
```

Example 2 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 3 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

Example 4 (javascript):
```javascript
169fn print_counts(
170    time: Res<Time>,
171    mut timer: Local<PrintingTimer>,
172    texts: Query<&ViewVisibility, With<Text2d>>,
173    atlases: Res<FontAtlasSets>,
174    font: Res<FontHandle>,
175) {
176    timer.tick(time.delta());
177    if !timer.just_finished() {
178        return;
179    }
180
181    let num_atlases = atlases
182        .get(font.0.id())
183        .map(|set| set.iter().map(|atlas| atlas.1.len()).sum())
184        .unwrap_or(0);
185
186    let visible_texts = texts.iter().filter(|visibility| visibility.get()).count();
187
188    info!(
189        "Texts: {} Visib
...
```

---

## Enum AssetEvent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AssetEvent.html

**Contents:**
- Enum AssetEvent Copy item path
- Variants§
  - Added
    - Fields
  - Modified
    - Fields
  - Removed
    - Fields
  - Unused
    - Fields

Messages that occur for a specific loaded Asset, such as “value changed” events and “dependency” events.

Emitted whenever an Asset is added.

Emitted whenever an Asset value is modified.

Emitted whenever an Asset is removed.

Emitted when the last Handle::Strong of an Asset is dropped.

Emitted whenever an Asset has been fully loaded (including its dependencies and all “recursive dependencies”).

Returns true if this event is AssetEvent::LoadedWithDependencies and matches the given id.

Returns true if this event is AssetEvent::Added and matches the given id.

Returns true if this event is AssetEvent::Modified and matches the given id.

Returns true if this event is AssetEvent::Removed and matches the given id.

Returns true if this event is AssetEvent::Unused and matches the given id.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AssetEvent<A>where
    A: Asset,{
    Added {
        id: AssetId<A>,
    },
    Modified {
        id: AssetId<A>,
    },
    Removed {
        id: AssetId<A>,
    },
    Unused {
        id: AssetId<A>,
    },
    LoadedWithDependencies {
        id: AssetId<A>,
    },
}
```

Example 2 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

Example 3 (unknown):
```unknown
37fn check_textures(
38    mut next_state: ResMut<NextState<AppState>>,
39    rpg_sprite_folder: Res<RpgSpriteFolder>,
40    mut events: MessageReader<AssetEvent<LoadedFolder>>,
41) {
42    // Advance the `AppState` once all sprite handles have been loaded by the `AssetServer`
43    for event in events.read() {
44        if event.is_loaded_with_dependencies(&rpg_sprite_folder.0) {
45            next_state.set(AppState::Finished);
46        }
47    }
48}
```

---

## Struct RayCastBackfaces Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RayCastBackfaces.html

**Contents:**
- Struct RayCastBackfaces Copy item path
- Trait Implementations§
  - impl Clone for RayCastBackfaces
    - fn clone(&self) -> RayCastBackfaces
    - fn clone_from(&mut self, source: &Self)
  - impl Component for RayCastBackfaceswhere RayCastBackfaces: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

Disables backface culling for ray casts on this entity.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RayCastBackfaces;
```

---

## Struct ChildOf Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ChildOf.html

**Contents:**
- Struct ChildOf Copy item path
- Tuple Fields§
- Implementations§
  - impl ChildOf
    - pub fn parent(&self) -> Entity
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for ChildOf
    - fn clone(&self) -> ChildOf
    - fn clone_from(&mut self, source: &Self)

Stores the parent entity of this child entity with this component.

This is a Relationship component, and creates the canonical “parent / child” hierarchy. This is the “source of truth” component, and it pairs with the Children RelationshipTarget.

This relationship should be used for things like:

ChildOf contains a single “target” Entity. When ChildOf is inserted on a “source” entity, the “target” entity will automatically (and immediately, via a component hook) have a Children component inserted, and the “source” entity will be added to that Children instance.

If the ChildOf component is replaced with a different “target” entity, the old target’s Children will be automatically (and immediately, via a component hook) be updated to reflect that change.

Likewise, when the ChildOf component is removed, the “source” entity will be removed from the old target’s Children. If this results in Children being empty, Children will be automatically removed.

When a parent is despawned, all children (and their descendants) will also be despawned.

You can create parent-child relationships in a variety of ways. The most direct way is to insert a ChildOf component:

However if you are spawning many children, you might want to use the EntityWorldMut::with_children helper instead:

The parent entity of this child entity.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ChildOf(pub Entity);
```

Example 2 (javascript):
```javascript
let root = world.spawn_empty().id();
let child1 = world.spawn(ChildOf(root)).id();
let child2 = world.spawn(ChildOf(root)).id();
let grandchild = world.spawn(ChildOf(child1)).id();

assert_eq!(&**world.entity(root).get::<Children>().unwrap(), &[child1, child2]);
assert_eq!(&**world.entity(child1).get::<Children>().unwrap(), &[grandchild]);

world.entity_mut(child2).remove::<ChildOf>();
assert_eq!(&**world.entity(root).get::<Children>().unwrap(), &[child1]);

world.entity_mut(root).despawn();
assert!(world.get_entity(root).is_err());
assert!(world.get_entity(child1).is_err());
assert!(world.get
...
```

Example 3 (javascript):
```javascript
let mut child1 = Entity::PLACEHOLDER;
let mut child2 = Entity::PLACEHOLDER;
let mut grandchild = Entity::PLACEHOLDER;
let root = world.spawn_empty().with_children(|p| {
    child1 = p.spawn_empty().with_children(|p| {
        grandchild = p.spawn_empty().id();
    }).id();
    child2 = p.spawn_empty().id();
}).id();

assert_eq!(&**world.entity(root).get::<Children>().unwrap(), &[child1, child2]);
assert_eq!(&**world.entity(child1).get::<Children>().unwrap(), &[grandchild]);
```

Example 4 (javascript):
```javascript
103fn button_system(
104    mut interaction_query: Query<(&Interaction, &ChildOf), (Changed<Interaction>, With<Button>)>,
105    labels_query: Query<(&Children, &ChildOf), With<Button>>,
106    mut text_query: Query<&mut Text>,
107    mut counter_query: Query<&mut Counter>,
108) {
109    // Update parent counter on click
110    for (interaction, child_of) in &mut interaction_query {
111        if matches!(interaction, Interaction::Pressed) {
112            let mut counter = counter_query.get_mut(child_of.parent()).unwrap();
113            counter.0 += 1;
114        }
115    }
116
117    // Upd
...
```

---

## Trait RationalGenerator Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.RationalGenerator.html

**Contents:**
- Trait RationalGenerator Copy item path
- Required Associated Types§
    - type Error
- Required Methods§
    - fn to_curve(&self) -> Result<RationalCurve<P>, Self::Error>
- Implementors§
  - impl<P> RationalGenerator<P> for CubicNurbs<P>where P: VectorSpace<Scalar = f32>,
    - type Error = InsufficientDataError

Implement this on cubic splines that can generate a rational cubic curve from their spline parameters.

An error type indicating why construction might fail.

Build a RationalCurve by computing the interpolation coefficients for each curve segment.

**Examples:**

Example 1 (unknown):
```unknown
pub trait RationalGenerator<P>where
    P: VectorSpace,{
    type Error;

    // Required method
    fn to_curve(&self) -> Result<RationalCurve<P>, Self::Error>;
}
```

---

## Struct TextureSlicer Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextureSlicer.html

**Contents:**
- Struct TextureSlicer Copy item path
- Fields§
- Implementations§
  - impl TextureSlicer
    - pub fn compute_slices( &self, rect: Rect, render_size: Option<Vec2>, ) -> Vec<TextureSlice>
      - §Arguments
- Trait Implementations§
  - impl Clone for TextureSlicer
    - fn clone(&self) -> TextureSlicer
    - fn clone_from(&mut self, source: &Self)

Slices a texture using the 9-slicing technique. This allows to reuse an image at various sizes without needing to prepare multiple assets. The associated texture will be split into nine portions, so that on resize the different portions scale or tile in different ways to keep the texture in proportion.

For example, when resizing a 9-sliced texture the corners will remain unscaled while the other sections will be scaled or tiled.

See 9-sliced textures.

Inset values in pixels that define the four slicing lines dividing the texture into nine sections.

Defines how the center part of the 9 slices will scale

Defines how the 4 side parts of the 9 slices will scale

Defines the maximum scale of the 4 corner slices (default to 1.0)

Slices the given rect into at least 9 sections. If the center and/or side parts are set to tile, a bigger number of sections will be computed.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureSlicer {
    pub border: BorderRect,
    pub center_scale_mode: SliceScaleMode,
    pub sides_scale_mode: SliceScaleMode,
    pub max_corner_scale: f32,
}
```

---

## Struct Startup Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.Startup.html

**Contents:**
- Struct Startup Copy item path
- Trait Implementations§
  - impl Clone for Startup
    - fn clone(&self) -> Startup
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Startup
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Startup
    - fn default() -> Startup
  - impl Hash for Startup

The schedule that runs once when the app starts.

See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Startup;
```

---

## Struct Isometry2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Isometry2d.html

**Contents:**
- Struct Isometry2d Copy item path
- §Example
- Fields§
- Implementations§
  - impl Isometry2d
    - pub const IDENTITY: Isometry2d
    - pub const fn new(translation: Vec2, rotation: Rot2) -> Isometry2d
      - Examples found in repository?
    - pub const fn from_rotation(rotation: Rot2) -> Isometry2d
    - pub const fn from_translation(translation: Vec2) -> Isometry2d

An isometry in two dimensions, representing a rotation followed by a translation. This can often be useful for expressing relative positions and transformations from one position to another.

In particular, this type represents a distance-preserving transformation known as a rigid motion or a direct motion, and belongs to the special Euclidean group SE(2). This includes translation and rotation, but excludes reflection.

For the three-dimensional version, see Isometry3d.

Isometries can be created from a given translation and rotation:

Or from separate parts:

The isometries can be used to transform points:

Isometries can also be composed together:

One common operation is to compute an isometry representing the relative positions of two objects for things like intersection tests. This can be done with an inverse transformation:

The rotational part of a two-dimensional isometry.

The translational part of a two-dimensional isometry.

The identity isometry which represents the rigid motion of not doing anything.

Create a two-dimensional isometry from a rotation and a translation.

Create a two-dimensional isometry from a rotation.

Create a two-dimensional isometry from a translation.

Create a two-dimensional isometry from a translation with the given x and y components.

The inverse isometry that undoes this one.

Compute iso1.inverse() * iso2 in a more efficient way for one-shot cases.

If the same isometry is used multiple times, it is more efficient to instead compute the inverse once and use that for each transformation.

Transform a point by rotating and translating it using this isometry.

Transform a point by rotating and translating it using the inverse of this isometry.

This is more efficient than iso.inverse().transform_point(point) for one-shot cases. If the same isometry is used multiple times, it is more efficient to instead compute the inverse once and use that for each transformation.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Isometry2d {
    pub rotation: Rot2,
    pub translation: Vec2,
}
```

Example 2 (javascript):
```javascript
let iso = Isometry2d::new(Vec2::new(2.0, 1.0), Rot2::degrees(90.0));
```

Example 3 (javascript):
```javascript
let iso1 = Isometry2d::from_translation(Vec2::new(2.0, 1.0));
let iso2 = Isometry2d::from_rotation(Rot2::degrees(90.0));
```

Example 4 (javascript):
```javascript
let iso = Isometry2d::new(Vec2::new(2.0, 1.0), Rot2::degrees(90.0));
let point = Vec2::new(4.0, 4.0);

// These are equivalent
let result = iso.transform_point(point);
let result = iso * point;

assert_eq!(result, Vec2::new(-2.0, 5.0));
```

---

## Module adaptors Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/adaptors/index.html

**Contents:**
- Module adaptors Copy item path
- Structs§

Adaptors used by the Curve API for transforming and combining curves together.

---

## Struct TextureAtlasBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextureAtlasBuilder.html

**Contents:**
- Struct TextureAtlasBuilder Copy item path
- Implementations§
  - impl<'a> TextureAtlasBuilder<'a>
    - pub fn initial_size(&mut self, size: UVec2) -> &mut TextureAtlasBuilder<'a>
    - pub fn max_size(&mut self, size: UVec2) -> &mut TextureAtlasBuilder<'a>
    - pub fn format(&mut self, format: TextureFormat) -> &mut TextureAtlasBuilder<'a>
    - pub fn auto_format_conversion( &mut self, auto_format_conversion: bool, ) -> &mut TextureAtlasBuilder<'a>
    - pub fn add_texture( &mut self, image_id: Option<AssetId<Image>>, texture: &'a Image, ) -> &mut TextureAtlasBuilder<'a>
      - Examples found in repository?
    - pub fn padding(&mut self, padding: UVec2) -> &mut TextureAtlasBuilder<'a>

A builder which is used to create a texture atlas from many individual sprites.

Sets the initial size of the atlas in pixels.

Sets the max size of the atlas in pixels.

Sets the texture format for textures in the atlas.

Control whether the added texture should be converted to the atlas format, if different.

Adds a texture to be copied to the texture atlas.

Optionally an asset id can be passed that can later be used with the texture layout to retrieve the index of this texture. The insertion order will reflect the index of the added texture in the finished texture atlas.

Sets the amount of padding in pixels to add between the textures in the texture atlas.

The x value provide will be added to the right edge, while the y value will be added to the bottom edge.

Consumes the builder, and returns the newly created texture atlas and the associated atlas layout.

Assigns indices to the textures based on the insertion order. Internally it copies all rectangles from the textures and copies them into a new texture.

If there is not enough space in the atlas texture, an error will be returned. It is then recommended to make a larger sprite sheet.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureAtlasBuilder<'a> { /* private fields */ }
```

Example 2 (javascript):
```javascript
217fn create_texture_atlas(
218    folder: &LoadedFolder,
219    padding: Option<UVec2>,
220    sampling: Option<ImageSampler>,
221    textures: &mut ResMut<Assets<Image>>,
222) -> (TextureAtlasLayout, TextureAtlasSources, Handle<Image>) {
223    // Build a texture atlas using the individual sprites
224    let mut texture_atlas_builder = TextureAtlasBuilder::default();
225    texture_atlas_builder.padding(padding.unwrap_or_default());
226    for handle in folder.handles.iter() {
227        let id = handle.id().typed_unchecked::<Image>();
228        let Some(texture) = textures.get(id) else {
2
...
```

Example 3 (javascript):
```javascript
217fn create_texture_atlas(
218    folder: &LoadedFolder,
219    padding: Option<UVec2>,
220    sampling: Option<ImageSampler>,
221    textures: &mut ResMut<Assets<Image>>,
222) -> (TextureAtlasLayout, TextureAtlasSources, Handle<Image>) {
223    // Build a texture atlas using the individual sprites
224    let mut texture_atlas_builder = TextureAtlasBuilder::default();
225    texture_atlas_builder.padding(padding.unwrap_or_default());
226    for handle in folder.handles.iter() {
227        let id = handle.id().typed_unchecked::<Image>();
228        let Some(texture) = textures.get(id) else {
2
...
```

Example 4 (javascript):
```javascript
fn my_system(mut textures: ResMut<Assets<Image>>, mut layouts: ResMut<Assets<TextureAtlasLayout>>) {
    // Declare your builder
    let mut builder = TextureAtlasBuilder::default();
    // Customize it
    // ...
    // Build your texture and the atlas layout
    let (atlas_layout, atlas_sources, texture) = builder.build().unwrap();
    let texture = textures.add(texture);
    let layout = layouts.add(atlas_layout);
}
```

---

## Struct MaterialNode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MaterialNode.html

**Contents:**
- Struct MaterialNode Copy item path
- Tuple Fields§
- Methods from Deref<Target = Handle<M>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§
  - impl<M> Clone for MaterialNode<M>where M: Clone + UiMaterial,

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Required Components: Node.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MaterialNode<M>(pub Handle<M>)
where
    M: UiMaterial;
```

Example 2 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 3 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

Example 4 (javascript):
```javascript
169fn print_counts(
170    time: Res<Time>,
171    mut timer: Local<PrintingTimer>,
172    texts: Query<&ViewVisibility, With<Text2d>>,
173    atlases: Res<FontAtlasSets>,
174    font: Res<FontHandle>,
175) {
176    timer.tick(time.delta());
177    if !timer.just_finished() {
178        return;
179    }
180
181    let num_atlases = atlases
182        .get(font.0.id())
183        .map(|set| set.iter().map(|atlas| atlas.1.len()).sum())
184        .unwrap_or(0);
185
186    let visible_texts = texts.iter().filter(|visibility| visibility.get()).count();
187
188    info!(
189        "Texts: {} Visib
...
```

---

## Struct Ref Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Ref.html

**Contents:**
- Struct Ref Copy item path
- §Examples
- Implementations§
  - impl<'w, T> Ref<'w, T>where T: ?Sized,
    - pub fn into_inner(self) -> &'w T
    - pub fn map<U>(self, f: impl FnOnce(&T) -> &U) -> Ref<'w, U>where U: ?Sized,
    - pub fn new( value: &'w T, added: &'w Tick, changed: &'w Tick, last_run: Tick, this_run: Tick, caller: MaybeLocation<&'w &'static Location<'static>>, ) -> Ref<'w, T>
    - pub fn set_ticks(&mut self, last_run: Tick, this_run: Tick)
- Trait Implementations§
  - impl<'w, T> AsRef<T> for Ref<'w, T>

Shared borrow of an entity’s component with access to change detection. Similar to Mut but is immutable and so doesn’t require unique access.

These two systems produce the same output.

Returns the reference wrapped by this type. The reference is allowed to outlive self, which makes this method more flexible than simply borrowing self.

Map Ref to a different type using f.

This doesn’t do anything else than call f on the wrapped value. This is equivalent to Mut::map_unchanged.

Create a new Ref using provided values.

This is an advanced feature, Refs are designed to be created by engine-internal code and consumed by end-user code.

Overwrite the last_run and this_run tick that are used for change detection.

This is an advanced feature. Refs are usually created by engine-internal code and consumed by end-user code.

Convert a Res into a Ref. This allows keeping the change-detection feature of Ref while losing the specificity of Res for resources.

SAFETY: Self is the same as Self::ReadOnly

SAFETY: fetch accesses a single component in a readonly way. This is sound because update_component_access adds read access for that component and panic when appropriate. update_component_access adds a With filter for a component. This is sound because matches_component_set returns whether the set contains that component.

SAFETY: access is read only

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Ref<'w, T>where
    T: ?Sized,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
fn how_many_changed_1(query: Query<(), Changed<MyComponent>>) {
    println!("{} changed", query.iter().count());
}

fn how_many_changed_2(query: Query<Ref<MyComponent>>) {
    println!("{} changed", query.iter().filter(|c| c.is_changed()).count());
}
```

---

## Struct PointerState Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PointerState.html

**Contents:**
- Struct PointerState Copy item path
- Fields§
- Implementations§
  - impl PointerState
    - pub fn get( &self, pointer_id: PointerId, button: PointerButton, ) -> Option<&PointerButtonState>
    - pub fn get_mut( &mut self, pointer_id: PointerId, button: PointerButton, ) -> &mut PointerButtonState
    - pub fn clear(&mut self, pointer_id: PointerId)
- Trait Implementations§
  - impl Clone for PointerState
    - fn clone(&self) -> PointerState

State for all pointers.

Pressing and dragging state, organized by pointer and button.

Retrieves the current state for a specific pointer and button, if it has been created.

Provides write access to the state of a pointer and button, creating it if it does not yet exist.

Clears all the data associated with all of the buttons on a pointer. Does not free the underlying memory.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PointerState {
    pub pointer_buttons: HashMap<(PointerId, PointerButton), PointerButtonState>,
}
```

---

## Struct ReflectResource Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ReflectResource.html

**Contents:**
- Struct ReflectResource Copy item path
- Implementations§
  - impl ReflectResource
    - pub fn insert( &self, world: &mut World, resource: &(dyn PartialReflect + 'static), registry: &TypeRegistry, )
    - pub fn apply( &self, world: &mut World, resource: &(dyn PartialReflect + 'static), )
      - §Panics
    - pub fn apply_or_insert( &self, world: &mut World, resource: &(dyn PartialReflect + 'static), registry: &TypeRegistry, )
    - pub fn remove(&self, world: &mut World)
    - pub fn reflect<'w, 's>( &self, resources: impl Into<FilteredResources<'w, 's>>, ) -> Result<&'w (dyn Reflect + 'static), ResourceFetchError>
    - pub fn reflect_mut<'w, 's>( &self, resources: impl Into<FilteredResourcesMut<'w, 's>>, ) -> Result<Mut<'w, dyn Reflect>, ResourceFetchError>

A struct used to operate on reflected Resource of a type.

A ReflectResource for type T can be obtained via bevy_reflect::TypeRegistration::data.

Insert a reflected Resource into the world like insert().

Uses reflection to set the value of this Resource type in the world to the given value.

Panics if there is no Resource of the given type.

Uses reflection to set the value of this Resource type in the world to the given value or insert a new one if it does not exist.

Removes this Resource type from the world. Does nothing if it doesn’t exist.

Gets the value of this Resource type from the world as a reflected reference.

Note that &World is a valid type for resources.

Gets the value of this Resource type from the world as a mutable reflected reference.

Note that &mut World is a valid type for resources.

This method does not prevent you from having two mutable pointers to the same data, violating Rust’s aliasing rules. To avoid this:

Gets the value of this Resource type from source_world and applies it to the value of this Resource type in destination_world.

Panics if there is no Resource of the given type.

Register the type of this Resource in World, returning the ComponentId

Create a custom implementation of ReflectResource.

This is an advanced feature, useful for scripting implementations, that should not be used by most users unless you know what you are doing.

Usually you should derive Reflect and add the #[reflect(Resource)] component to generate a ReflectResource implementation automatically.

See ReflectResourceFns for more information.

The underlying function pointers implementing methods on ReflectResource.

This is useful when you want to keep track locally of an individual function pointer.

Calling TypeRegistry::get followed by TypeRegistration::data::<ReflectResource> can be costly if done several times per frame. Consider cloning ReflectResource and keeping it between frames, cloning a ReflectResource is very cheap.

If you only need a subset of the methods on ReflectResource, use fn_pointers to get the underlying ReflectResourceFns and copy the subset of function pointers you care about.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ReflectResource(/* private fields */);
```

---

## Struct ElasticOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ElasticOutCurve.html

**Contents:**
- Struct ElasticOutCurve Copy item path
- Trait Implementations§
  - impl Clone for ElasticOutCurve
    - fn clone(&self) -> ElasticOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ElasticOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = 2.0^(-10.0 * t) * sin((t * 10.0 - 0.75) * 2.0 * π / 3.0) + 1.0

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ElasticOutCurve;
```

---

## Struct BackgroundColor Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BackgroundColor.html

**Contents:**
- Struct BackgroundColor Copy item path
- Tuple Fields§
- Implementations§
  - impl BackgroundColor
    - pub const DEFAULT: BackgroundColor
- Trait Implementations§
  - impl Clone for BackgroundColor
    - fn clone(&self) -> BackgroundColor
    - fn clone_from(&mut self, source: &Self)
  - impl Component for BackgroundColorwhere BackgroundColor: Send + Sync + 'static,

The background color of the node

This serves as the “fill” color.

Background color is transparent by default.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BackgroundColor(pub Color);
```

---

## Enum TextureError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.TextureError.html

**Contents:**
- Enum TextureError Copy item path
- Variants§
  - InvalidImageMimeType(String)
  - InvalidImageExtension(String)
  - ImageError(ImageError)
  - UnsupportedTextureFormat(String)
  - SuperCompressionNotSupported(String)
  - SuperDecompressionError(String)
  - InvalidData(String)
  - TranscodeError(String)

An error that occurs when loading a texture.

Image MIME type is invalid.

Image extension is invalid.

Failed to load an image.

Texture format isn’t supported.

Supercompression isn’t supported.

Failed to decompress an image.

Format requires transcoding.

Only cubemaps with six faces are supported.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum TextureError {
    InvalidImageMimeType(String),
    InvalidImageExtension(String),
    ImageError(ImageError),
    UnsupportedTextureFormat(String),
    SuperCompressionNotSupported(String),
    SuperDecompressionError(String),
    InvalidData(String),
    TranscodeError(String),
    FormatRequiresTranscodingError(TranscodeFormat),
    IncompleteCubemap,
}
```

---

## Struct TaskPoolThreadAssignmentPolicy Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.TaskPoolThreadAssignmentPolicy.html

**Contents:**
- Struct TaskPoolThreadAssignmentPolicy Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for TaskPoolThreadAssignmentPolicy
    - fn clone(&self) -> TaskPoolThreadAssignmentPolicy
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for TaskPoolThreadAssignmentPolicy
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
- Auto Trait Implementations§
  - impl Freeze for TaskPoolThreadAssignmentPolicy

Defines a simple way to determine how many threads to use given the number of remaining cores and number of total cores

Force using at least this many threads

Under no circumstance use more than this many threads for this pool

Target using this percentage of total cores, clamped by min_threads and max_threads. It is permitted to use 1.0 to try to use all remaining threads

Callback that is invoked once for every created thread as it starts. This configuration will be ignored under wasm platform.

Callback that is invoked once for every created thread as it terminates This configuration will be ignored under wasm platform.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TaskPoolThreadAssignmentPolicy {
    pub min_threads: usize,
    pub max_threads: usize,
    pub percent: f32,
    pub on_thread_spawn: Option<Arc<dyn Fn() + Sync + Send>>,
    pub on_thread_destroy: Option<Arc<dyn Fn() + Sync + Send>>,
}
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/mesh/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Traits§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct Torus Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Torus.html

**Contents:**
- Struct Torus Copy item path
- Fields§
- Implementations§
  - impl Torus
    - pub const fn new(inner_radius: f32, outer_radius: f32) -> Torus
    - pub const fn inner_radius(&self) -> f32
    - pub const fn outer_radius(&self) -> f32
    - pub fn kind(&self) -> TorusKind
- Trait Implementations§
  - impl Bounded3d for Torus

A torus primitive, often representing a ring or donut shape The set of points some distance from a circle centered at the origin

The radius of the tube of the torus

The distance from the center of the torus to the center of the tube

Create a new Torus from an inner and outer radius.

The inner radius is the radius of the hole, and the outer radius is the radius of the entire object

Get the inner radius of the torus. For a ring torus, this corresponds to the radius of the hole, or major_radius - minor_radius

Get the outer radius of the torus. This corresponds to the overall radius of the entire object, or major_radius + minor_radius

Get the TorusKind determined by the minor and major radii.

The torus can either be a ring torus that has a hole, a horn torus that doesn’t have a hole but also isn’t self-intersecting, or a spindle torus that is self-intersecting.

If the minor or major radius is non-positive, infinite, or NaN, TorusKind::Invalid is returned

Returns the default Torus with a minor radius of 0.25 and a major radius of 0.75.

Get the surface area of the torus. Note that this only produces the expected result when the torus has a ring and isn’t self-intersecting

Get the volume of the torus. Note that this only produces the expected result when the torus has a ring and isn’t self-intersecting

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Torus {
    pub minor_radius: f32,
    pub major_radius: f32,
}
```

---

## Enum GizmoLineJoint Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GizmoLineJoint.html

**Contents:**
- Enum GizmoLineJoint Copy item path
- Variants§
  - None
  - Miter
  - Round(u32)
  - Bevel
- Trait Implementations§
  - impl Clone for GizmoLineJoint
    - fn clone(&self) -> GizmoLineJoint
    - fn clone_from(&mut self, source: &Self)

An enum configuring how line joints will be drawn.

Does not draw any line joints.

Extends both lines at the joining point until they meet in a sharp point.

Draws a round corner with the specified resolution between the two lines.

The resolution determines the amount of triangles drawn per joint, e.g. GizmoLineJoint::Round(4) will draw 4 triangles at each line joint.

Draws a bevel, a straight line in this case, to connect the ends of both lines.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum GizmoLineJoint {
    None,
    Miter,
    Round(u32),
    Bevel,
}
```

---

## Trait TransformPoint Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.TransformPoint.html

**Contents:**
- Trait TransformPoint Copy item path
- Required Methods§
    - fn transform_point(&self, point: impl Into<Vec3>) -> Vec3
- Dyn Compatibility§
- Implementors§
  - impl TransformPoint for Affine3A
  - impl TransformPoint for GlobalTransform
  - impl TransformPoint for Isometry3d
  - impl TransformPoint for Mat4
  - impl TransformPoint for Transform

A trait for point transformation methods.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait TransformPoint {
    // Required method
    fn transform_point(&self, point: impl Into<Vec3>) -> Vec3;
}
```

---

## Enum AnimationGraphSaveError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AnimationGraphSaveError.html

**Contents:**
- Enum AnimationGraphSaveError Copy item path
- Variants§
  - Io(Error)
  - Ron(Error)
  - ConvertToSerialized(NonPathHandleError)
- Trait Implementations§
  - impl Debug for AnimationGraphSaveError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for AnimationGraphSaveError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>

Errors that can occur when serializing animation graphs to RON.

An I/O error occurred.

An error occurred in RON serialization.

An error occurred converting the graph to its serialization form.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AnimationGraphSaveError {
    Io(Error),
    Ron(Error),
    ConvertToSerialized(NonPathHandleError),
}
```

---

## Trait StateSet Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.StateSet.html

**Contents:**
- Trait StateSet Copy item path
- Required Associated Constants§
    - const SET_DEPENDENCY_DEPTH: usize
- Required Methods§
    - fn register_computed_state_systems_in_schedule<T>(schedule: &mut Schedule)where T: ComputedStates<SourceStates = Self>,
    - fn register_sub_state_systems_in_schedule<T>(schedule: &mut Schedule)where T: SubStates<SourceStates = Self>,
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl<S> StateSet for (S₁, S₂, …, Sₙ)where S: InnerStateSet,
    - const SET_DEPENDENCY_DEPTH: usize

A States type or tuple of types which implement States.

This trait is used to allow implementors of States, as well as tuples containing exclusively implementors of States, to be used as ComputedStates::SourceStates.

It is sealed, and auto implemented for all States types and tuples containing them.

The total DEPENDENCY_DEPTH of all the states that are part of this StateSet, added together.

Used to de-duplicate computed state executions and prevent cyclic computed states.

Sets up the systems needed to compute T whenever any State in this StateSet is changed.

Sets up the systems needed to compute whether T exists whenever any State in this StateSet is changed.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

This trait is implemented for tuples up to 15 items long.

**Examples:**

Example 1 (javascript):
```javascript
pub trait StateSet: StateSetSealed {
    const SET_DEPENDENCY_DEPTH: usize;

    // Required methods
    fn register_computed_state_systems_in_schedule<T>(schedule: &mut Schedule)
       where T: ComputedStates<SourceStates = Self>;
    fn register_sub_state_systems_in_schedule<T>(schedule: &mut Schedule)
       where T: SubStates<SourceStates = Self>;
}
```

---

## Struct UiRect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiRect.html

**Contents:**
- Struct UiRect Copy item path
- §Examples
  - §Margin
  - §Padding
  - §Borders
- Fields§
- Implementations§
  - impl UiRect
    - pub const DEFAULT: UiRect
    - pub const ZERO: UiRect

A type which is commonly used to define margins, paddings and borders.

A margin is used to create space around UI elements, outside of any defined borders.

A padding is used to create space around UI elements, inside of any defined borders.

A border is used to define the width of the border of a UI element.

The value corresponding to the left side of the UI rect.

The value corresponding to the right side of the UI rect.

The value corresponding to the top side of the UI rect.

The value corresponding to the bottom side of the UI rect.

Creates a new UiRect from the values specified.

Creates a new UiRect where all sides have the same value.

Creates a new UiRect from the values specified in logical pixels.

This is a shortcut for UiRect::new(), applying Val::Px to all arguments.

Creates a new UiRect from the values specified in percentages.

This is a shortcut for UiRect::new(), applying Val::Percent to all arguments.

Creates a new UiRect where left and right take the given value, and top and bottom set to zero Val::ZERO.

Creates a new UiRect where top and bottom take the given value, and left and right are set to Val::ZERO.

Creates a new UiRect where both left and right take the value of horizontal, and both top and bottom take the value of vertical.

Creates a new UiRect where left takes the given value, and the other fields are set to Val::ZERO.

Creates a new UiRect where right takes the given value, and the other fields are set to Val::ZERO.

Creates a new UiRect where top takes the given value, and the other fields are set to Val::ZERO.

Creates a new UiRect where bottom takes the given value, and the other fields are set to Val::ZERO.

Returns the UiRect with its left field set to the given value.

Returns the UiRect with its right field set to the given value.

Returns the UiRect with its top field set to the given value.

Returns the UiRect with its bottom field set to the given value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiRect {
    pub left: Val,
    pub right: Val,
    pub top: Val,
    pub bottom: Val,
}
```

Example 2 (javascript):
```javascript
let margin = UiRect::all(Val::Auto); // Centers the UI element
```

Example 3 (javascript):
```javascript
let padding = UiRect {
    left: Val::Px(10.0),
    right: Val::Px(20.0),
    top: Val::Px(30.0),
    bottom: Val::Px(40.0),
};
```

Example 4 (javascript):
```javascript
let border = UiRect {
    left: Val::Px(10.0),
    right: Val::Px(20.0),
    top: Val::Px(30.0),
    bottom: Val::Px(40.0),
};
```

---

## Struct ThreadedAnimationGraph Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ThreadedAnimationGraph.html

**Contents:**
- Struct ThreadedAnimationGraph Copy item path
- Fields§
- Trait Implementations§
  - impl Default for ThreadedAnimationGraph
    - fn default() -> ThreadedAnimationGraph
  - impl FromArg for ThreadedAnimationGraph
    - type This<'from_arg> = ThreadedAnimationGraph
    - fn from_arg( arg: Arg<'_>, ) -> Result<<ThreadedAnimationGraph as FromArg>::This<'_>, ArgError>
  - impl FromReflect for ThreadedAnimationGraph
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<ThreadedAnimationGraph>

An acceleration structure for an animation graph that allows Bevy to evaluate it quickly.

This is kept up to date as the associated AnimationGraph instance is added, modified, or removed.

A cached postorder traversal of the graph.

The node indices here are stored in postorder. Siblings are stored in descending order. This is because the AnimationCurveEvaluator uses a stack for evaluation. Consider this graph:

The postorder traversal in this case will be (4, 3, 6, 5, 2, 1).

The fact that the children of each node are sorted in reverse ensures that, at each level, the order of blending proceeds in ascending order by node index, as we guarantee. To illustrate this, consider the way the graph above is evaluated. (Interpolation is represented with the ⊕ symbol.)

A mapping from each parent node index to the range within Self::sorted_edges.

This allows for quick lookup of the children of each node, sorted in ascending order of node index, without having to sort the result of the petgraph traversal functions every frame.

A list of the children of each node, sorted in ascending order.

A mapping from node index to a bitfield specifying the mask groups that this node masks out (i.e. doesn’t animate).

A 1 in bit position N indicates that this node doesn’t animate any targets of mask group N.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ThreadedAnimationGraph {
    pub threaded_graph: Vec<NodeIndex>,
    pub sorted_edge_ranges: Vec<Range<u32>>,
    pub sorted_edges: Vec<NodeIndex>,
    pub computed_masks: Vec<u64>,
}
```

Example 2 (text):
```text
┌─────┐
            │     │
            │  1  │
            │     │
            └──┬──┘
               │
       ┌───────┼───────┐
       │       │       │
       ▼       ▼       ▼
    ┌─────┐ ┌─────┐ ┌─────┐
    │     │ │     │ │     │
    │  2  │ │  3  │ │  4  │
    │     │ │     │ │     │
    └──┬──┘ └─────┘ └─────┘
       │
   ┌───┴───┐
   │       │
   ▼       ▼
┌─────┐ ┌─────┐
│     │ │     │
│  5  │ │  6  │
│     │ │     │
└─────┘ └─────┘
```

---

## Trait States Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.States.html

**Contents:**
- Trait States Copy item path
- §Example
- Provided Associated Constants§
    - const DEPENDENCY_DEPTH: usize = 1usize
- Dyn Compatibility§
- Implementors§
  - impl<S> States for Swhere S: ComputedStates,
    - const DEPENDENCY_DEPTH: usize

Types that can define world-wide states in a finite-state machine.

The Default trait defines the starting state. Multiple states can be defined for the same world, allowing you to classify the state of the world across orthogonal dimensions. You can access the current state of type T with the State<T> resource, and the queued state with the NextState<T> resource.

State transitions typically occur in the OnEnter<T::Variant> and OnExit<T::Variant> schedules, which can be run by triggering the StateTransition schedule.

Types used as ComputedStates do not need to and should not derive States. ComputedStates should not be manually mutated: functionality provided by the States derive and the associated FreelyMutableState trait.

How many other states this state depends on. Used to help order transitions and de-duplicate ComputedStates, as well as prevent cyclical ComputedState dependencies.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (javascript):
```javascript
pub trait States:
    'static
    + Send
    + Sync
    + Clone
    + PartialEq
    + Eq
    + Hash
    + Debug {
    const DEPENDENCY_DEPTH: usize = 1usize;
}
```

Example 2 (unknown):
```unknown
use bevy_state::prelude::*;
use bevy_ecs::prelude::IntoScheduleConfigs;
use bevy_ecs::system::{ResMut, ScheduleSystem};


#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Default, States)]
enum GameState {
    #[default]
    MainMenu,
    SettingsMenu,
    InGame,
}

fn handle_escape_pressed(mut next_state: ResMut<NextState<GameState>>) {
    if escape_pressed {
        next_state.set(GameState::SettingsMenu);
    }
}

fn open_settings_menu() {
    // Show the settings menu...
}


app.init_state::<GameState>();
app.add_systems(Update, handle_escape_pressed.run_if(in_state(GameState::MainMenu)
...
```

---

## Trait IntoSystem Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.IntoSystem.html

**Contents:**
- Trait IntoSystem Copy item path
- §Usage notes
- §Examples
- Required Associated Types§
    - type System: System<In = In, Out = Out>
- Required Methods§
    - fn into_system(this: Self) -> Self::System
- Provided Methods§
    - fn pipe<B, BIn, BOut, MarkerB>(self, system: B) -> IntoPipeSystem<Self, B>where Out: 'static, B: IntoSystem<BIn, BOut, MarkerB>, BIn: for<'a> SystemInput<Inner<'a> = Out>,
      - Examples found in repository?

Conversion trait to turn something into a System.

Use this to get a system from a function. Also note that every system implements this trait as well.

This trait should only be used as a bound for trait implementations or as an argument to a function. If a system needs to be returned from a function or stored somewhere, use System instead of this trait.

The type of System that this instance converts into.

Turns this value into its corresponding System.

Pass the output of this system A into a second system B, creating a new compound system.

The second system must have In<T> as its first parameter, where T is the return type of the first system.

Pass the output of this system into the passed function f, creating a new system that outputs the value returned from the function.

Passes a mutable reference to value as input to the system each run, turning it into a system that takes no input.

Self can have any SystemInput type that takes a mutable reference to T, such as InMut.

Passes a mutable reference to a value of type T created via FromWorld as input to the system each run, turning it into a system that takes no input.

Self can have any SystemInput type that takes a mutable reference to T, such as InMut.

Get the TypeId of the System produced after calling into_system.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait IntoSystem<In, Out, Marker>: Sizedwhere
    In: SystemInput,{
    type System: System<In = In, Out = Out>;

    // Required method
    fn into_system(this: Self) -> Self::System;

    // Provided methods
    fn pipe<B, BIn, BOut, MarkerB>(self, system: B) -> IntoPipeSystem<Self, B>
       where Out: 'static,
             B: IntoSystem<BIn, BOut, MarkerB>,
             BIn: for<'a> SystemInput<Inner<'a> = Out> { ... }
    fn map<T, F>(self, f: F) -> IntoAdapterSystem<F, Self>
       where F: Send + Sync + 'static + FnMut(Out) -> T { ... }
    fn with_input<T>(self, value: T) -> WithIn
...
```

Example 2 (javascript):
```javascript
use bevy_ecs::prelude::*;

fn my_system_function(a_usize_local: Local<usize>) {}

let system = IntoSystem::into_system(my_system_function);
```

Example 3 (javascript):
```javascript
9fn main() {
10    App::new()
11        .insert_resource(Message("42".to_string()))
12        .insert_resource(OptionalWarning(Err("Got to rusty?".to_string())))
13        .add_plugins(LogPlugin {
14            level: Level::TRACE,
15            filter: "".to_string(),
16            ..default()
17        })
18        .add_systems(
19            Update,
20            (
21                parse_message_system.pipe(handler_system),
22                data_pipe_system.map(|out| info!("{out}")),
23                parse_message_system.map(|out| debug!("{out:?}")),
24                warning_pipe_system
...
```

Example 4 (unknown):
```unknown
64        fn build(&self, app: &mut App) {
65            app.add_systems(
66                StateTransition,
67                // The internals can generate at most one transition event of specific type per frame.
68                // We take the latest one and clear the queue.
69                last_transition::<S>
70                    // We insert the optional event into our schedule runner.
71                    .pipe(run_reenter::<S>)
72                    // State transitions are handled in three ordered steps, exposed as system sets.
73                    // We can add our systems to th
...
```

---

## Enum AnimationGraphLoadError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AnimationGraphLoadError.html

**Contents:**
- Enum AnimationGraphLoadError Copy item path
- Variants§
  - Io(Error)
  - Ron(Error)
  - SpannedRon(SpannedError)
  - GraphContainsLegacyAssetId
- Trait Implementations§
  - impl Debug for AnimationGraphLoadError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for AnimationGraphLoadError

Errors that can occur when deserializing animation graphs from RON.

An I/O error occurred.

An error occurred in RON deserialization.

An error occurred in RON deserialization, and the location of the error is supplied.

The deserialized graph contained legacy data that we no longer support.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AnimationGraphLoadError {
    Io(Error),
    Ron(Error),
    SpannedRon(SpannedError),
    GraphContainsLegacyAssetId,
}
```

---

## Trait IntoFunctionMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.IntoFunctionMut.html

**Contents:**
- Trait IntoFunctionMut Copy item path
- §Trait Parameters
- Required Methods§
    - fn into_function_mut(self) -> DynamicFunctionMut<'env>
- Implementors§
  - impl<'env> IntoFunctionMut<'env, ()> for DynamicFunction<'env>
  - impl<'env> IntoFunctionMut<'env, ()> for DynamicFunctionMut<'env>
  - impl<'env, F, Marker1, Marker2> IntoFunctionMut<'env, (Marker1, Marker2)> for Fwhere F: ReflectFnMut<'env, Marker1> + TypedFunction<Marker2> + 'env,

A trait for types that can be converted into a DynamicFunctionMut.

This trait is automatically implemented for any type that implements ReflectFnMut and TypedFunction.

This trait can be seen as a superset of IntoFunction.

See the module-level documentation for more information.

This trait has a Marker type parameter that is used to get around issues with unconstrained type parameters when defining impls with generic arguments or return types. This Marker can be any type, provided it doesn’t conflict with other implementations.

Additionally, it has a lifetime parameter, 'env, that is used to bound the lifetime of the function. For named functions and some closures, this will end up just being 'static, however, closures that borrow from their environment will have a lifetime bound to that environment.

Converts Self into a DynamicFunctionMut.

**Examples:**

Example 1 (unknown):
```unknown
pub trait IntoFunctionMut<'env, Marker> {
    // Required method
    fn into_function_mut(self) -> DynamicFunctionMut<'env>;
}
```

---

## Struct Vec4 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Vec4.html

**Contents:**
- Struct Vec4 Copy item path
- Implementations§
  - impl Vec4
    - pub const ZERO: Vec4
    - pub const ONE: Vec4
    - pub const NEG_ONE: Vec4
    - pub const MIN: Vec4
    - pub const MAX: Vec4
    - pub const NAN: Vec4
    - pub const INFINITY: Vec4

A 4-dimensional vector.

SIMD vector types are used for storage on supported platforms.

This type is 16 byte aligned.

All f32::NEG_INFINITY.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the positive W axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

A unit vector pointing along the negative W axis.

Vec4 uses Rust Portable SIMD

Vec4 uses scalar math

Vec4 uses WebAssembly 128-bit SIMD

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z, w]

Creates a vector from the first 4 values in slice.

Panics if slice is less than 4 elements long.

Writes the elements of self to the first 4 elements in slice.

Panics if slice is less than 4 elements long.

Creates a 3D vector from the x, y and z elements of self, discarding w.

Truncation to Vec3 may also be performed by using self.xyz().

To truncate to Vec3A use Vec3A::from_vec4().

Creates a 4D vector from self with the given value of x.

Creates a 4D vector from self with the given value of y.

Creates a 4D vector from self with the given value of z.

Creates a 4D vector from self with the given value of w.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for minNum and may differ on different SIMD architectures.

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

NaN propogation does not follow IEEE 754-2008 semantics for maxNum and may differ on different SIMD architectures.

Component-wise clamping of values, similar to f32::clamp.

Each element in min must be less-or-equal to the corresponding elemen

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Vec4(/* private fields */);
```

Example 2 (javascript):
```javascript
20fn setup(
21    mut commands: Commands,
22    mut ui_materials: ResMut<Assets<CustomUiMaterial>>,
23    asset_server: Res<AssetServer>,
24) {
25    // Camera so we can see UI
26    commands.spawn(Camera2d);
27
28    commands
29        .spawn(Node {
30            width: percent(100),
31            height: percent(100),
32            align_items: AlignItems::Center,
33            justify_content: JustifyContent::Center,
34            ..default()
35        })
36        .with_children(|parent| {
37            let banner_scale_factor = 0.5;
38            parent.spawn((
39                Node {
40
...
```

---

## Enum MigrationSerializedAnimationClip Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.MigrationSerializedAnimationClip.html

**Contents:**
- Enum MigrationSerializedAnimationClip Copy item path
- Variants§
  - Modern(AssetPath<'static>)
  - Legacy(SerializedAnimationClip)
- Trait Implementations§
  - impl<'de> Deserialize<'de> for MigrationSerializedAnimationClip
    - fn deserialize<__D>( __deserializer: __D, ) -> Result<MigrationSerializedAnimationClip, <__D as Deserializer<'de>>::Error>where __D: Deserializer<'de>,
  - impl Serialize for MigrationSerializedAnimationClip
    - fn serialize<__S>( &self, __serializer: __S, ) -> Result<<__S as Serializer>::Ok, <__S as Serializer>::Error>where __S: Serializer,
- Auto Trait Implementations§

A type to facilitate migration from the legacy format of SerializedAnimationGraph to the new format.

By using untagged serde deserialization, we can try to deserialize the modern form, then fallback to the legacy form. Users must migrate to the modern form by Bevy 0.18.

This is the new type of this field.

This is the legacy type of this field. Users must migrate away from this.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum MigrationSerializedAnimationClip {
    Modern(AssetPath<'static>),
    Legacy(SerializedAnimationClip),
}
```

---

## Struct Cuboid Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Cuboid.html

**Contents:**
- Struct Cuboid Copy item path
- Fields§
- Implementations§
  - impl Cuboid
    - pub const fn new(x_length: f32, y_length: f32, z_length: f32) -> Cuboid
      - Examples found in repository?
    - pub const fn from_size(size: Vec3) -> Cuboid
      - Examples found in repository?
    - pub fn from_corners(point1: Vec3, point2: Vec3) -> Cuboid
    - pub const fn from_length(length: f32) -> Cuboid

A cuboid primitive, which is like a cube, except that the x, y, and z dimensions are not required to be the same.

Half of the width, height and depth of the cuboid

Create a new Cuboid from a full x, y, and z length

Create a new Cuboid from a given full size

Create a new Cuboid from two corner points

Create a Cuboid from a single length. The resulting Cuboid will be the same size in every direction.

Get the size of the cuboid

Finds the point on the cuboid that is closest to the given point.

If the point is outside the cuboid, the returned point will be on the surface of the cuboid. Otherwise, it will be inside the cuboid and returned as is.

Returns the default Cuboid with a width, height, and depth of 1.0.

Get the surface area of the cuboid

Get the volume of the cuboid

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Cuboid {
    pub half_size: Vec3,
}
```

Example 2 (javascript):
```javascript
34fn add_assets(
35    mut commands: Commands,
36    mut meshes: ResMut<Assets<Mesh>>,
37    mut materials: ResMut<Assets<StandardMaterial>>,
38) {
39    let box_mesh_handle = meshes.add(Cuboid::new(0.25, 0.25, 0.25));
40    commands.insert_resource(BoxMeshHandle(box_mesh_handle));
41
42    let box_material_handle = materials.add(Color::srgb(1.0, 0.2, 0.3));
43    commands.insert_resource(BoxMaterialHandle(box_material_handle));
44}
```

Example 3 (javascript):
```javascript
176fn spawn_rotating_cube(
177    commands: &mut Commands,
178    meshes: &mut Assets<Mesh>,
179    standard_materials: &mut Assets<StandardMaterial>,
180) {
181    let cube_handle = meshes.add(Cuboid::new(3.0, 3.0, 3.0));
182    let rotating_cube_material_handle = standard_materials.add(StandardMaterial {
183        base_color: Color::WHITE,
184        unlit: false,
185        ..default()
186    });
187    commands.spawn((
188        Mesh3d(cube_handle.clone()),
189        MeshMaterial3d(rotating_cube_material_handle),
190        Transform::IDENTITY,
191        RotatingCube,
192    ));
193}
```

Example 4 (unknown):
```unknown
147fn spawn_cube(
148    commands: &mut Commands,
149    asset_server: &AssetServer,
150    meshes: &mut Assets<Mesh>,
151    standard_materials: &mut Assets<StandardMaterial>,
152) {
153    commands
154        .spawn((
155            Mesh3d(meshes.add(Cuboid::new(1.0, 1.0, 1.0))),
156            MeshMaterial3d(standard_materials.add(StandardMaterial {
157                base_color: Color::from(WHITE),
158                base_color_texture: Some(asset_server.load("branding/icon.png")),
159                ..default()
160            })),
161            Transform::from_xyz(0.0, 0.5, 0.0),
162    
...
```

---

## Function any_match_filter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.any_match_filter.html

**Contents:**
- Function any_match_filter Copy item path

A SystemCondition-satisfying system that returns true if there are any entities that match the given QueryFilter.

**Examples:**

Example 1 (unknown):
```unknown
pub fn any_match_filter<F>(query: Query<'_, '_, (), F>) -> boolwhere
    F: QueryFilter,
```

---

## Struct Mesh Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mesh.html

**Contents:**
- Struct Mesh Copy item path
  - §Manual creation
  - §Other examples
  - §Common points of confusion
  - §Use with StandardMaterial
  - §Remote Inspection
- Fields§
- Implementations§
  - impl Mesh
    - pub const ATTRIBUTE_POSITION: MeshVertexAttribute

A 3D object made out of vertices representing triangles, lines, or points, with “attribute” values for each vertex.

Meshes can be automatically generated by a bevy AssetLoader (generally by loading a Gltf file), or by converting a primitive using into. It is also possible to create one manually. They can be edited after creation.

Meshes can be rendered with a Mesh2d and MeshMaterial2d or Mesh3d and MeshMaterial3d for 2D and 3D respectively.

A Mesh in Bevy is equivalent to a “primitive” in the glTF format, for a glTF Mesh representation, see GltfMesh.

The following function will construct a flat mesh, to be rendered with a StandardMaterial or ColorMaterial:

You can see how it looks like here, used in a Mesh3d with a square bevy logo texture, with added axis, points, lines and text for clarity.

For further visualization, explanation, and examples, see the built-in Bevy examples, and the implementation of the built-in shapes. In particular, generate_custom_mesh teaches you to access and modify the attributes of a Mesh after creating it.

To render correctly with StandardMaterial, a mesh needs to have properly defined:

To transmit a Mesh between two running Bevy apps, e.g. through BRP, use SerializedMesh. This type is only meant for short-term transmission between same versions and should not be stored anywhere.

Whether or not to build a BLAS for use with bevy_solari raytracing.

Note that this is not whether the mesh is compatible with bevy_solari raytracing. This field just controls whether or not a BLAS gets built for this mesh, assuming that the mesh is compatible.

The use case for this field is using lower-resolution proxy meshes for raytracing (to save on BLAS memory usage), while using higher-resolution meshes for raster. You can set this field to true for the lower-resolution proxy mesh, and to false for the high-resolution raster mesh.

Alternatively, you can use the same mesh for both raster and raytracing, with this field set to true.

Does nothing if not used with bevy_solari, or if the mesh is not compatible with bevy_solari (see bevy_solari’s docs).

Where the vertex is located in space. Use in conjunction with Mesh::insert_attribute or Mesh::with_inserted_attribute.

The format of this attribute is VertexFormat::Float32x3.

The direction the vertex normal is facing in. Use in conjunction with Mesh::insert_attribute or Mesh::with_inserted_attribute.

The format of this attribute is VertexFormat::Float32x3.

Texture coordinates for the ve

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Mesh {
    pub asset_usage: RenderAssetUsages,
    pub enable_raytracing: bool,
    /* private fields */
}
```

Example 2 (unknown):
```unknown
fn create_simple_parallelogram() -> Mesh {
    // Create a new mesh using a triangle list topology, where each set of 3 vertices composes a triangle.
    Mesh::new(PrimitiveTopology::TriangleList, RenderAssetUsages::default())
        // Add 4 vertices, each with its own position attribute (coordinate in
        // 3D space), for each of the corners of the parallelogram.
        .with_inserted_attribute(
            Mesh::ATTRIBUTE_POSITION,
            vec![[0.0, 0.0, 0.0], [1.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 0.0, 0.0]]
        )
        // Assign a UV coordinate to each vertex.
        .
...
```

Example 3 (javascript):
```javascript
96    fn from(line: LineList) -> Self {
97        let vertices: Vec<_> = line.lines.into_iter().flat_map(|(a, b)| [a, b]).collect();
98
99        Mesh::new(
100            // This tells wgpu that the positions are list of lines
101            // where every pair is a start and end point
102            PrimitiveTopology::LineList,
103            RenderAssetUsages::RENDER_WORLD,
104        )
105        // Add the vertices positions as an attribute
106        .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, vertices)
107    }
108}
109
110/// A list of points that will have a line drawn between 
...
```

Example 4 (javascript):
```javascript
52fn setup(mut commands: Commands, mut meshes: ResMut<Assets<Mesh>>) {
53    // Build a custom triangle mesh with colors
54    // We define a custom mesh because the examples only uses a limited
55    // set of vertex attributes for simplicity
56    let mesh = Mesh::new(
57        PrimitiveTopology::TriangleList,
58        RenderAssetUsages::default(),
59    )
60    .with_inserted_indices(Indices::U32(vec![0, 1, 2]))
61    .with_inserted_attribute(
62        Mesh::ATTRIBUTE_POSITION,
63        vec![
64            vec3(-0.5, -0.5, 0.0),
65            vec3(0.5, -0.5, 0.0),
66            vec3(0.0
...
```

---

## Struct WithRelated Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.WithRelated.html

**Contents:**
- Struct WithRelated Copy item path
- Tuple Fields§
- Implementations§
  - impl<I> WithRelated<I>
    - pub fn new(iter: impl IntoIterator<IntoIter = I>) -> WithRelated<I>
- Trait Implementations§
  - impl<R, I> SpawnableList<R> for WithRelated<I>where R: Relationship, I: Iterator<Item = Entity>,
    - fn spawn(this: MovingPtr<'_, WithRelated<I>>, world: &mut World, entity: Entity)
    - fn size_hint(&self) -> usize
- Auto Trait Implementations§

A SpawnableList that links already spawned entities to the root entity via relations of type I.

This is useful if the entity has already been spawned earlier or if you spawn multiple relationships link to the same entity at the same time. If you only need to do this for a single entity, consider using WithOneRelated.

Creates a new WithRelated from a collection of entities.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WithRelated<I>(pub I);
```

Example 2 (javascript):
```javascript
let mut world = World::new();

let child2 = world.spawn(Name::new("Child2")).id();
let child3 = world.spawn(Name::new("Child3")).id();

world.spawn((
    Name::new("Root"),
    Children::spawn((
        Spawn(Name::new("Child1")),
        // This adds the already existing entities as children of Root.
        WithRelated::new([child2, child3]),
    )),
));
```

---

## Enum WindowPosition Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.WindowPosition.html

**Contents:**
- Enum WindowPosition Copy item path
- Variants§
  - Automatic
  - Centered(MonitorSelection)
  - At(IVec2)
- Implementations§
  - impl WindowPosition
    - pub fn new(position: IVec2) -> WindowPosition
    - pub fn set(&mut self, position: IVec2)
    - pub fn center(&mut self, monitor: MonitorSelection)

Defines where a Window should be placed on the screen.

Position will be set by the window manager. Bevy will delegate this decision to the window manager and no guarantees can be made about where the window will be placed.

Used at creation but will be changed to At.

Window will be centered on the selected monitor.

Note that this does not account for window decorations.

Used at creation or for update but will be changed to At

The window’s top-left corner should be placed at the specified position (in physical pixels).

(0,0) represents top-left corner of screen space.

Creates a new WindowPosition at a position.

Set the position to a specific point.

Set the window to a specific monitor.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum WindowPosition {
    Automatic,
    Centered(MonitorSelection),
    At(IVec2),
}
```

---

## Trait SystemInput Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.SystemInput.html

**Contents:**
- Trait SystemInput Copy item path
- §Examples
  - §Tuples of SystemInputs
- Required Associated Types§
    - type Param<'i>: SystemInput
    - type Inner<'i>
- Required Methods§
    - fn wrap(this: Self::Inner<'_>) -> Self::Param<'_>
- Dyn Compatibility§
- Implementations on Foreign Types§

Trait for types that can be used as input to Systems.

Provided implementations are:

For advanced usecases, you can implement this trait for your own types.

The wrapper input type that is defined as the first argument to FunctionSystems.

The inner input type that is passed to functions that run systems, such as System::run.

Converts a SystemInput::Inner into a SystemInput::Param.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

This trait is implemented for tuples up to 9 items long.

Used for ObserverSystems.

**Examples:**

Example 1 (unknown):
```unknown
pub trait SystemInput: Sized {
    type Param<'i>: SystemInput;
    type Inner<'i>;

    // Required method
    fn wrap(this: Self::Inner<'_>) -> Self::Param<'_>;
}
```

Example 2 (unknown):
```unknown
use bevy_ecs::prelude::*;

fn add((InMut(a), In(b)): (InMut<usize>, In<usize>)) {
    *a += b;
}
```

---

## Function vec2 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vec2.html

**Contents:**
- Function vec2 Copy item path
      - Examples found in repository?

Creates a 2-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn vec2(x: f32, y: f32) -> Vec2
```

Example 2 (javascript):
```javascript
86static LIGHTMAPS: [(&str, Rect); 5] = [
87    (
88        "Plane",
89        uv_rect_opengl(Vec2::splat(0.026), Vec2::splat(0.710)),
90    ),
91    (
92        "SheenChair_fabric",
93        uv_rect_opengl(vec2(0.7864, 0.02377), vec2(0.1910, 0.1912)),
94    ),
95    (
96        "SheenChair_label",
97        uv_rect_opengl(vec2(0.275, -0.016), vec2(0.858, 0.486)),
98    ),
99    (
100        "SheenChair_metal",
101        uv_rect_opengl(vec2(0.998, 0.506), vec2(-0.029, -0.067)),
102    ),
103    (
104        "SheenChair_wood",
105        uv_rect_opengl(vec2(0.787, 0.257), vec2(0.179, 0.177)),
...
```

Example 3 (javascript):
```javascript
35fn setup(mut commands: Commands) {
36    // Initialize the modes with their defaults:
37    let spline_mode = SplineMode::default();
38    commands.insert_resource(spline_mode);
39    let cycling_mode = CyclingMode::default();
40    commands.insert_resource(cycling_mode);
41
42    // Starting data for [`ControlPoints`]:
43    let default_points = vec![
44        vec2(-500., -200.),
45        vec2(-250., 250.),
46        vec2(250., 250.),
47        vec2(500., -200.),
48    ];
49
50    let default_tangents = vec![
51        vec2(0., 200.),
52        vec2(200., 0.),
53        vec2(0., -200.),
5
...
```

Example 4 (javascript):
```javascript
32fn setup(
33    mut commands: Commands,
34    mut meshes: ResMut<Assets<Mesh>>,
35    mut materials: ResMut<Assets<StandardMaterial>>,
36    mut compensation_curves: ResMut<Assets<AutoExposureCompensationCurve>>,
37    asset_server: Res<AssetServer>,
38) {
39    let metering_mask = asset_server.load("textures/basic_metering_mask.png");
40
41    commands.spawn((
42        Camera3d::default(),
43        Transform::from_xyz(1.0, 0.0, 0.0).looking_at(Vec3::ZERO, Vec3::Y),
44        AutoExposure {
45            metering_mask: metering_mask.clone(),
46            ..default()
47        },
48       
...
```

---

## Struct LinearReparamCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LinearReparamCurve.html

**Contents:**
- Struct LinearReparamCurve Copy item path
- Trait Implementations§
  - impl<T, C> Clone for LinearReparamCurve<T, C>where T: Clone, C: Clone,
    - fn clone(&self) -> LinearReparamCurve<T, C>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C> Curve<T> for LinearReparamCurve<T, C>where C: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

A curve that has had its domain changed by a linear reparameterization (stretching and scaling). Curves of this type are produced by CurveExt::reparametrize_linear.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LinearReparamCurve<T, C> { /* private fields */ }
```

---

## Struct TaskPoolPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.TaskPoolPlugin.html

**Contents:**
- Struct TaskPoolPlugin Copy item path
- Fields§
- Trait Implementations§
  - impl Default for TaskPoolPlugin
    - fn default() -> TaskPoolPlugin
  - impl Plugin for TaskPoolPlugin
    - fn build(&self, _app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

Setup of default task pools: AsyncComputeTaskPool, ComputeTaskPool, IoTaskPool.

Options for the TaskPool created at application start.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TaskPoolPlugin {
    pub task_pool_options: TaskPoolOptions,
}
```

---

## Struct Click Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Click.html

**Contents:**
- Struct Click Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Click
    - fn clone(&self) -> Click
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Click
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Click
    - type This<'from_arg> = Click

Fires when a pointer sends a pointer pressed event followed by a pointer released event, with the same target entity for both events.

Pointer button pressed and lifted to trigger this event.

Information about the picking intersection.

Duration between the pointer pressed and lifted for this click

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Click {
    pub button: PointerButton,
    pub hit: HitData,
    pub duration: Duration,
}
```

---

## Struct Gizmos Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Gizmos.html

**Contents:**
- Struct Gizmos Copy item path
- Fields§
- Methods from Deref<Target = GizmoBuffer<Config, Clear>>§
    - pub fn arc_2d( &mut self, isometry: impl Into<Isometry2d>, arc_angle: f32, radius: f32, color: impl Into<Color>, ) -> Arc2dBuilder<'_, Config, Clear>
      - §Arguments
      - §Example
      - Examples found in repository?
    - pub fn arc_3d( &mut self, angle: f32, radius: f32, isometry: impl Into<Isometry3d>, color: impl Into<Color>, ) -> Arc3dBuilder<'_, Config, Clear>
      - §Arguments
      - §Builder methods

A SystemParam for drawing gizmos.

They are drawn in immediate mode, which means they will be rendered only for the frames, or ticks when in FixedMain, in which they are spawned.

A system in Main will be cleared each rendering frame, while a system in FixedMain will be cleared each time the RunFixedMainLoop schedule is run.

Gizmos should be spawned before the Last schedule to ensure they are drawn.

To set up your own clearing context (useful for custom scheduling similar to FixedMain):

The currently used GizmoConfig

The currently used GizmoConfigGroup

Draw an arc, which is a part of the circumference of a circle, in 2D.

This should be called for each frame the arc needs to be rendered.

Draw an arc, which is a part of the circumference of a circle, in 3D. For default values this is drawing a standard arc. A standard arc is defined as

This should be called for each frame the arc needs to be rendered.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the shortest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the longest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the shortest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draws the longest arc between two points (from and to) relative to a specified center point.

The resolution of the arc (i.e. the level of detail) can be adjusted with the .resolution(...) method.

Draw an arrow in 3D, from start to end. Has four tips for convenient viewing from any direction.

This should be called for each frame the arrow needs to be rendered.

Draw an arrow in 2D (on the xy plane), from start to end.

This should be called for each frame the arrow needs to be rendered.

Draw a set of axes local to the given transform (transform), with length scaled by a factor of base_length.

This should be called for each frame the axes need to be rendered.

Draw a set of axes local to the given transform (transform), with length scaled by a factor of base_length.

This should be called for each frame the axes need to be rendered.

Draw an ellipse in 3D with th

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Gizmos<'w, 's, Config = DefaultGizmoConfigGroup, Clear = ()>where
    Config: GizmoConfigGroup,
    Clear: 'static + Send + Sync,{
    pub config: &'w GizmoConfig,
    pub config_ext: &'w Config,
    /* private fields */
}
```

Example 2 (unknown):
```unknown
use bevy_gizmos::{prelude::*, *, gizmos::GizmoStorage};
struct ClearContextSetup;
impl Plugin for ClearContextSetup {
    fn build(&self, app: &mut App) {
        app.init_resource::<GizmoStorage<DefaultGizmoConfigGroup, MyContext>>()
           // Make sure this context starts/ends cleanly if inside another context. E.g. it
           // should start after the parent context starts and end after the parent context ends.
           .add_systems(StartOfMyContext, start_gizmo_context::<DefaultGizmoConfigGroup, MyContext>)
           // If not running multiple times, put this with [`start_gizmo_c
...
```

Example 3 (unknown):
```unknown
fn system(mut gizmos: Gizmos) {
    gizmos.arc_2d(Isometry2d::IDENTITY, FRAC_PI_4, 1., GREEN);

    // Arcs have 32 line-segments by default.
    // You may want to increase this for larger arcs.
    gizmos
        .arc_2d(Isometry2d::IDENTITY, FRAC_PI_4, 5., RED)
        .resolution(64);
}
```

Example 4 (javascript):
```javascript
40fn draw_example_collection(
41    mut gizmos: Gizmos,
42    mut my_gizmos: Gizmos<MyRoundGizmos>,
43    time: Res<Time>,
44) {
45    let sin_t_scaled = ops::sin(time.elapsed_secs()) * 50.;
46    gizmos.line_2d(Vec2::Y * -sin_t_scaled, Vec2::splat(-80.), RED);
47    gizmos.ray_2d(Vec2::Y * sin_t_scaled, Vec2::splat(80.), LIME);
48
49    gizmos
50        .grid_2d(
51            Isometry2d::IDENTITY,
52            UVec2::new(16, 9),
53            Vec2::new(80., 80.),
54            // Dark gray
55            LinearRgba::gray(0.05),
56        )
57        .outer_edges();
58
59    // Triangle
60   
...
```

---

## Function vec3a Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.vec3a.html

**Contents:**
- Function vec3a Copy item path

Creates a 3-dimensional vector.

**Examples:**

Example 1 (javascript):
```javascript
pub const fn vec3a(x: f32, y: f32, z: f32) -> Vec3A
```

---

## Derive Macro Asset Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Asset.html

**Contents:**
- Derive Macro Asset Copy item path

Implement the Asset trait.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Asset)]
{
    // Attributes available to this derive:
    #[dependency]
}
```

---

## Struct DragEnter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragEnter.html

**Contents:**
- Struct DragEnter Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragEnter
    - fn clone(&self) -> DragEnter
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragEnter
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragEnter
    - type This<'from_arg> = DragEnter

Fires when a pointer dragging the dragged entity enters the target entity.

Pointer button pressed to enter drag.

The entity that was being dragged when the pointer entered the target entity.

Information about the picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragEnter {
    pub button: PointerButton,
    pub dragged: Entity,
    pub hit: HitData,
}
```

---

## Struct PingPongCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PingPongCurve.html

**Contents:**
- Struct PingPongCurve Copy item path
- §Domain
- Trait Implementations§
  - impl<T, C> Clone for PingPongCurve<T, C>where T: Clone, C: Clone,
    - fn clone(&self) -> PingPongCurve<T, C>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C> Curve<T> for PingPongCurve<T, C>where C: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> T
    - fn sample(&self, t: f32) -> Option<T>

The curve that results from chaining a curve with its reversed version. The transition point is guaranteed to make no jump.

Curves of this type are produced by CurveExt::ping_pong.

The original curve’s domain must be right-finite to get a valid PingPongCurve.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PingPongCurve<T, C> { /* private fields */ }
```

---

## Trait Gray Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Gray.html

**Contents:**
- Trait Gray Copy item path
- Required Associated Constants§
    - const BLACK: Self
    - const WHITE: Self
- Provided Methods§
    - fn gray(lightness: f32) -> Self
      - Examples found in repository?
- Dyn Compatibility§
- Implementors§
  - impl Gray for Hsla

Trait for returning a grayscale color of a provided lightness.

Returns a grey color with the provided lightness from (0.0 - 1.0). 0 is black, 1 is white.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (javascript):
```javascript
pub trait Gray: Sized + Mix {
    const BLACK: Self;
    const WHITE: Self;

    // Provided method
    fn gray(lightness: f32) -> Self { ... }
}
```

Example 2 (javascript):
```javascript
40fn draw_example_collection(
41    mut gizmos: Gizmos,
42    mut my_gizmos: Gizmos<MyRoundGizmos>,
43    time: Res<Time>,
44) {
45    let sin_t_scaled = ops::sin(time.elapsed_secs()) * 50.;
46    gizmos.line_2d(Vec2::Y * -sin_t_scaled, Vec2::splat(-80.), RED);
47    gizmos.ray_2d(Vec2::Y * sin_t_scaled, Vec2::splat(80.), LIME);
48
49    gizmos
50        .grid_2d(
51            Isometry2d::IDENTITY,
52            UVec2::new(16, 9),
53            Vec2::new(80., 80.),
54            // Dark gray
55            LinearRgba::gray(0.05),
56        )
57        .outer_edges();
58
59    // Triangle
60   
...
```

Example 3 (javascript):
```javascript
98fn draw_example_collection(
99    mut gizmos: Gizmos,
100    mut my_gizmos: Gizmos<MyRoundGizmos>,
101    time: Res<Time>,
102) {
103    gizmos.grid(
104        Quat::from_rotation_x(PI / 2.),
105        UVec2::splat(20),
106        Vec2::new(2., 2.),
107        // Light gray
108        LinearRgba::gray(0.65),
109    );
110    gizmos.grid(
111        Isometry3d::new(Vec3::splat(10.0), Quat::from_rotation_x(PI / 3. * 2.)),
112        UVec2::splat(20),
113        Vec2::new(2., 2.),
114        PURPLE,
115    );
116    gizmos.sphere(Vec3::splat(10.0), 1.0, PURPLE);
117
118    gizmos
119        .
...
```

---

## Type Alias ChildSpawnerCommands Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.ChildSpawnerCommands.html

**Contents:**
- Type Alias ChildSpawnerCommands Copy item path
- Aliased Type§

A type alias over RelatedSpawnerCommands used to spawn child entities containing a ChildOf relationship.

**Examples:**

Example 1 (unknown):
```unknown
pub type ChildSpawnerCommands<'w> = RelatedSpawnerCommands<'w, ChildOf>;
```

Example 2 (unknown):
```unknown
pub struct ChildSpawnerCommands<'w> { /* private fields */ }
```

---

## Struct FixedLast Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.FixedLast.html

**Contents:**
- Struct FixedLast Copy item path
- Trait Implementations§
  - impl Clone for FixedLast
    - fn clone(&self) -> FixedLast
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedLast
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedLast
    - fn default() -> FixedLast
  - impl Hash for FixedLast

The schedule that runs last in FixedMain

See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedLast;
```

---

## Module easing Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/easing/index.html

**Contents:**
- Module easing Copy item path
- Structs§
- Enums§
- Traits§

Module containing different easing functions.

An easing function is a Curve that’s used to transition between two values. It takes a time parameter, where a time of zero means the start of the transition and a time of one means the end.

Easing functions come in a variety of shapes - one might transition smoothly, while another might have a bouncing motion.

There are several ways to use easing functions. The simplest option is a struct thats represents a single easing function, like SmoothStepCurve and StepsCurve. These structs can only transition from a value of zero to a value of one.

Another option is EaseFunction. Unlike the single function structs, which require you to choose a function at compile time, EaseFunction lets you choose at runtime. It can also be serialized.

The final option is EasingCurve. This lets you transition between any two values - not just zero to one. EasingCurve can use any value that implements the Ease trait, including vectors and directions.

Like EaseFunction, the values and easing function of EasingCurve can be chosen at runtime and serialized.

**Examples:**

Example 1 (javascript):
```javascript
let smoothed_value = SmoothStepCurve.sample(time);
```

Example 2 (javascript):
```javascript
let stepped_value = StepsCurve(5, JumpAt::Start).sample(time);
```

Example 3 (javascript):
```javascript
let mut curve = EaseFunction::Linear;

if make_it_smooth {
    curve = EaseFunction::SmoothStep;
}

let value = curve.sample(time);
```

Example 4 (javascript):
```javascript
// Make a curve that smoothly transitions between two positions.
let start_position = vec2(1.0, 2.0);
let end_position = vec2(5.0, 10.0);
let curve = EasingCurve::new(start_position, end_position, EaseFunction::SmoothStep);

let smoothed_position = curve.sample(time);
```

---

## Enum ValArithmeticError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ValArithmeticError.html

**Contents:**
- Enum ValArithmeticError Copy item path
- Variants§
  - NonEvaluable
- Trait Implementations§
  - impl Clone for ValArithmeticError
    - fn clone(&self) -> ValArithmeticError
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ValArithmeticError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for ValArithmeticError

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ValArithmeticError {
    NonEvaluable,
}
```

---

## Struct WindowWrapper Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/window/struct.WindowWrapper.html

**Contents:**
- Struct WindowWrapper Copy item path
- Implementations§
  - impl<W> WindowWrapper<W>where W: Send + Sync + 'static,
    - pub fn new(window: W) -> WindowWrapper<W>
- Trait Implementations§
  - impl<W> Debug for WindowWrapper<W>where W: Debug,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<W> Deref for WindowWrapper<W>where W: 'static,
    - type Target = W
    - fn deref(&self) -> &<WindowWrapper<W> as Deref>::Target

A wrapper over a window.

This allows us to extend the lifetime of the window, so it doesn’t get eagerly dropped while a pipelined renderer still has frames in flight that need to draw to it.

This is achieved by storing a shared reference to the window in the RawHandleWrapper, which gets picked up by the renderer during extraction.

Creates a WindowWrapper from a window.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct WindowWrapper<W> { /* private fields */ }
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/input/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Enums§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct EnterSchedules Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EnterSchedules.html

**Contents:**
- Struct EnterSchedules Copy item path
- Trait Implementations§
  - impl<S> Clone for EnterSchedules<S>where S: Clone + States,
    - fn clone(&self) -> EnterSchedules<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for EnterSchedules<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Default for EnterSchedules<S>where S: States,
    - fn default() -> EnterSchedules<S>
  - impl<S> Hash for EnterSchedules<S>where S: Hash + States,

System set that runs enter schedule(s) for state S.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct EnterSchedules<S>(/* private fields */)
where
    S: States;
```

---

## Struct TextureSlice Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TextureSlice.html

**Contents:**
- Struct TextureSlice Copy item path
- Fields§
- Implementations§
  - impl TextureSlice
    - pub fn tiled(self, stretch_value: f32, _: (bool, bool)) -> Vec<TextureSlice>
      - §Arguments
- Trait Implementations§
  - impl Clone for TextureSlice
    - fn clone(&self) -> TextureSlice
    - fn clone_from(&mut self, source: &Self)

Single texture slice, representing a texture rect to draw in a given area

Transforms the given slice in a collection of tiled subdivisions.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TextureSlice {
    pub texture_rect: Rect,
    pub draw_size: Vec2,
    pub offset: Vec2,
}
```

---

## Attribute Macro reflect_trait Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/attr.reflect_trait.html

**Contents:**
- Attribute Macro reflect_trait Copy item path
- §Example

A macro that automatically generates type data for traits, which their implementors can then register.

The output of this macro is a struct that takes reflected instances of the implementor’s type and returns the value as a trait object. Because of this, it can only be used on object-safe traits.

For a trait named MyTrait, this will generate the struct ReflectMyTrait. The generated struct can be created using FromType with any type that implements the trait. The creation and registration of this generated struct as type data can be automatically handled by #[derive(Reflect)].

**Examples:**

Example 1 (unknown):
```unknown
#[reflect_trait]
```

Example 2 (javascript):
```javascript
#[reflect_trait] // Generates `ReflectMyTrait`
trait MyTrait {
  fn print(&self) -> &str;
}

#[derive(Reflect)]
#[reflect(MyTrait)] // Automatically registers `ReflectMyTrait`
struct SomeStruct;

impl MyTrait for SomeStruct {
  fn print(&self) -> &str {
    "Hello, World!"
  }
}

// We can create the type data manually if we wanted:
let my_trait: ReflectMyTrait = FromType::<SomeStruct>::from_type();

// Or we can simply get it from the registry:
let mut registry = TypeRegistry::default();
registry.register::<SomeStruct>();
let my_trait = registry
  .get_type_data::<ReflectMyTrait>(TypeId::of::
...
```

---

## Struct BackgroundGradient Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BackgroundGradient.html

**Contents:**
- Struct BackgroundGradient Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for BackgroundGradient
    - fn clone(&self) -> BackgroundGradient
    - fn clone_from(&mut self, source: &Self)
  - impl Component for BackgroundGradientwhere BackgroundGradient: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

A UI node that displays a gradient

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BackgroundGradient(pub Vec<Gradient>);
```

---

## Struct GlobalZIndex Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GlobalZIndex.html

**Contents:**
- Struct GlobalZIndex Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for GlobalZIndex
    - fn clone(&self) -> GlobalZIndex
    - fn clone_from(&mut self, source: &Self)
  - impl Component for GlobalZIndexwhere GlobalZIndex: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

GlobalZIndex allows a Node entity anywhere in the UI hierarchy to escape the implicit draw ordering of the UI’s layout tree and be rendered above or below other UI nodes. Nodes with a GlobalZIndex of greater than 0 will be drawn on top of nodes without a GlobalZIndex or nodes with a lower GlobalZIndex. Nodes with a GlobalZIndex of less than 0 will be drawn below nodes without a GlobalZIndex or nodes with a greater GlobalZIndex.

If two Nodes have the same GlobalZIndex, the node with the greater ZIndex will be drawn on top.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GlobalZIndex(pub i32);
```

---

## Struct Srgba Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Srgba.html

**Contents:**
- Struct Srgba Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Srgba
    - pub const BLACK: Srgba
    - pub const NONE: Srgba
    - pub const WHITE: Srgba
    - pub const RED: Srgba
    - pub const GREEN: Srgba

Non-linear standard RGB with alpha.

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The red channel. [0.0, 1.0]

The green channel. [0.0, 1.0]

The blue channel. [0.0, 1.0]

The alpha channel. [0.0, 1.0]

A fully red color with full alpha.

A fully green color with full alpha.

A fully blue color with full alpha.

Construct a new Srgba color from components.

Construct a new Srgba color from (r, g, b) components, with the default alpha (1.0).

Return a copy of this color with the red channel set to the given value.

Return a copy of this color with the green channel set to the given value.

Return a copy of this color with the blue channel set to the given value.

New Srgba from a CSS-style hexadecimal string.

Convert this color to CSS-style hexadecimal notation.

New Srgba from sRGB colorspace.

See also Srgba::new, Srgba::rgba_u8, Srgba::hex.

New Srgba from sRGB colorspace.

See also Srgba::new, Srgba::rgb_u8, Srgba::hex.

Converts a non-linear sRGB value to a linear one via gamma correction.

Converts a linear sRGB value to a non-linear one via gamma correction.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Srgba {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

Example 3 (javascript):
```javascript
201    pub const GRAY1: Srgba = Srgba::new(0.224, 0.224, 0.243, 1.0);
202    pub const GRAY2: Srgba = Srgba::new(0.486, 0.486, 0.529, 1.0);
203    pub const GRAY3: Srgba = Srgba::new(1.0, 1.0, 1.0, 1.0);
```

Example 4 (javascript):
```javascript
let color = Srgba::hex("FF00FF").unwrap(); // fuchsia
let color = Srgba::hex("FF00FF7F").unwrap(); // partially transparent fuchsia

// A standard hex color notation is also available
assert_eq!(Srgba::hex("#FFFFFF").unwrap(), Srgba::new(1.0, 1.0, 1.0, 1.0));
```

---

## Struct Mat3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mat3.html

**Contents:**
- Struct Mat3 Copy item path
- Fields§
- Implementations§
  - impl Mat3
    - pub const ZERO: Mat3
    - pub const IDENTITY: Mat3
    - pub const NAN: Mat3
    - pub const fn from_cols(x_axis: Vec3, y_axis: Vec3, z_axis: Vec3) -> Mat3
      - Examples found in repository?
    - pub const fn from_cols_array(m: &[f32; 9]) -> Mat3

A 3x3 column major matrix.

This 3x3 matrix type features convenience methods for creating and using linear and affine transformations. If you are primarily dealing with 2D affine transformations the Affine2 type is much faster and more space efficient than using a 3x3 matrix.

Linear transformations including 3D rotation and scale can be created using methods such as Self::from_diagonal(), Self::from_quat(), Self::from_axis_angle(), Self::from_rotation_x(), Self::from_rotation_y(), or Self::from_rotation_z().

The resulting matrices can be use to transform 3D vectors using regular vector multiplication.

Affine transformations including 2D translation, rotation and scale can be created using methods such as Self::from_translation(), Self::from_angle(), Self::from_scale() and Self::from_scale_angle_translation().

The Self::transform_point2() and Self::transform_vector2() convenience methods are provided for performing affine transforms on 2D vectors and points. These multiply 2D inputs as 3D vectors with an implicit z value of 1 for points and 0 for vectors respectively. These methods assume that Self contains a valid affine transform.

A 3x3 matrix with all elements set to 0.0.

A 3x3 identity matrix, where all diagonal elements are 1, and all off-diagonal elements are 0.

Creates a 3x3 matrix from three column vectors.

Creates a 3x3 matrix from a [f32; 9] array stored in column major order. If your data is stored in row major you will need to transpose the returned matrix.

Creates a [f32; 9] array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 3x3 matrix from a [[f32; 3]; 3] 3D array stored in column major order. If your data is in row major order you will need to transpose the returned matrix.

Creates a [[f32; 3]; 3] 3D array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 3x3 matrix with its diagonal set to diagonal and all other entries set to 0.

Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.

Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the ith column and jth row.

Panics if i or j is greater than 3.

Creates a 3D rotation matrix from the given quaternion.

Will panic if rotation is not normalized when glam_assert is enabled.

Creates a 3D rotation matrix from a normalized rotation axis and angle (in radians).

Will panic if axis is not normalized when glam_ass

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct Mat3 {
    pub x_axis: Vec3,
    pub y_axis: Vec3,
    pub z_axis: Vec3,
}
```

Example 2 (javascript):
```javascript
136fn track_targets(
137    // `Single` ensures the system runs ONLY when exactly one matching entity exists.
138    mut player: Single<(&mut Transform, &Player)>,
139    // `Option<Single>` never prevents the system from running, but will be `None` if there is not exactly one matching entity.
140    enemy: Option<Single<&Transform, (With<Enemy>, Without<Player>)>>,
141    time: Res<Time>,
142) {
143    let (player_transform, player) = &mut *player;
144    if let Some(enemy_transform) = enemy {
145        // Enemy found, rotate and move towards it.
146        let delta = enemy_transform.transl
...
```

Example 3 (javascript):
```javascript
215fn move_camera(
216    keyboard_input: Res<ButtonInput<KeyCode>>,
217    mut mouse_wheel_reader: MessageReader<MouseWheel>,
218    mut cameras: Query<&mut Transform, With<Camera3d>>,
219) {
220    let (mut zoom_delta, mut theta_delta) = (0.0, 0.0);
221
222    // Process zoom in and out via the keyboard.
223    if keyboard_input.pressed(KeyCode::KeyW) || keyboard_input.pressed(KeyCode::ArrowUp) {
224        zoom_delta -= CAMERA_KEYBOARD_ZOOM_SPEED;
225    } else if keyboard_input.pressed(KeyCode::KeyS) || keyboard_input.pressed(KeyCode::ArrowDown) {
226        zoom_delta += CAMERA_KEYBOARD_Z
...
```

Example 4 (javascript):
```javascript
591fn rotate_primitive_2d_meshes(
592    mut primitives_2d: Query<
593        (&mut Transform, &ViewVisibility),
594        (With<PrimitiveData>, With<MeshDim2>),
595    >,
596    time: Res<Time>,
597) {
598    let rotation_2d = Quat::from_mat3(&Mat3::from_angle(time.elapsed_secs()));
599    primitives_2d
600        .iter_mut()
601        .filter(|(_, vis)| vis.get())
602        .for_each(|(mut transform, _)| {
603            transform.rotation = rotation_2d;
604        });
605}
```

---

## Struct Sphere Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Sphere.html

**Contents:**
- Struct Sphere Copy item path
- Fields§
- Implementations§
  - impl Sphere
    - pub const fn new(radius: f32) -> Sphere
      - Examples found in repository?
    - pub const fn diameter(&self) -> f32
    - pub fn closest_point(&self, point: Vec3) -> Vec3
- Trait Implementations§
  - impl Bounded3d for Sphere

A sphere primitive, representing the set of all points some distance from the origin

The radius of the sphere

Create a new Sphere from a radius

Get the diameter of the sphere

Finds the point on the sphere that is closest to the given point.

If the point is outside the sphere, the returned point will be on the surface of the sphere. Otherwise, it will be inside the sphere and returned as is.

Returns the default Sphere with a radius of 0.5.

Get the surface area of the sphere

Get the volume of the sphere

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Sphere {
    pub radius: f32,
}
```

Example 2 (unknown):
```unknown
229    fn from_world(world: &mut World) -> Self {
230        Self {
231            mesh: world.add_asset::<Mesh>(Sphere::new(10.0)),
232            material: world.add_asset::<StandardMaterial>(StandardMaterial {
233                base_color: WHITE.into(),
234                ..Default::default()
235            }),
236        }
237    }
```

Example 3 (javascript):
```javascript
81fn create_sphere_mesh(meshes: &mut Assets<Mesh>) -> Handle<Mesh> {
82    // We're going to use normal maps, so make sure we've generated tangents, or
83    // else the normal maps won't show up.
84
85    let mut sphere_mesh = Sphere::new(1.0).mesh().build();
86    sphere_mesh
87        .generate_tangents()
88        .expect("Failed to generate tangents");
89    meshes.add(sphere_mesh)
90}
```

Example 4 (javascript):
```javascript
49fn create_sphere_mesh(meshes: &mut Assets<Mesh>) -> Handle<Mesh> {
50    // We're going to use normal maps, so make sure we've generated tangents, or
51    // else the normal maps won't show up.
52
53    let mut sphere_mesh = Sphere::new(1.0).mesh().build();
54    sphere_mesh
55        .generate_tangents()
56        .expect("Failed to generate tangents");
57    meshes.add(sphere_mesh)
58}
```

---

## Trait TypePath Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.TypePath.html

**Contents:**
- Trait TypePath Copy item path
- §Stability
- §Anonymity
- §Example
- Required Methods§
    - fn type_path() -> &'static str
    - fn short_type_path() -> &'static str
- Provided Methods§
    - fn type_ident() -> Option<&'static str>
    - fn crate_name() -> Option<&'static str>

A static accessor to type paths and names.

The engine uses this trait over core::any::type_name for stability and flexibility.

This trait is automatically implemented by the #[derive(Reflect)] macro and allows type path information to be processed without an instance of that type.

Implementors may have difficulty in generating references with static lifetimes. Luckily, this crate comes with some utility structs, to make generating these statics much simpler.

Certain parts of the engine, e.g. (de)serialization, rely on type paths as identifiers for matching dynamic values to concrete types.

Using core::any::type_name, a scene containing my_crate::foo::MyComponent would break, failing to deserialize if the component was moved from the foo module to the bar module, becoming my_crate::bar::MyComponent. This trait, through attributes when deriving itself or Reflect, can ensure breaking changes are avoidable.

The only external factor we rely on for stability when deriving is the module_path! macro, only if the derive does not provide a #[type_path = "..."] attribute.

Some methods on this trait return Option<&'static str> over &'static str because not all types define all parts of a type path, for example the array type [T; N].

Such types are ‘anonymous’ in that they have only a defined type_path and short_type_path and the methods crate_name, module_path and type_ident all return None.

Primitives are treated like anonymous types, except they also have a defined type_ident.

Returns the fully qualified path of the underlying type.

Generic parameter types are also fully expanded.

For Option<Vec<usize>>, this is "std::option::Option<std::vec::Vec<usize>>".

Returns a short, pretty-print enabled path to the type.

Generic parameter types are also shortened.

For Option<Vec<usize>>, this is "Option<Vec<usize>>".

Returns the name of the type, or None if it is anonymous.

Primitive types will return Some.

For Option<Vec<usize>>, this is "Option".

Returns the name of the crate the type is in, or None if it is anonymous.

For Option<Vec<usize>>, this is "core".

Returns the path to the module the type is in, or None if it is anonymous.

For Option<Vec<usize>>, this is "std::option".

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

This trait is implemented for tuples up to 13 items long.

Note: This is not a fully stable implementation of TypePath due to usage of 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait TypePath: 'static {
    // Required methods
    fn type_path() -> &'static str;
    fn short_type_path() -> &'static str;

    // Provided methods
    fn type_ident() -> Option<&'static str> { ... }
    fn crate_name() -> Option<&'static str> { ... }
    fn module_path() -> Option<&'static str> { ... }
}
```

Example 2 (javascript):
```javascript
use bevy_reflect::TypePath;

// This type path will not change with compiler versions or recompiles,
// although it will not be the same if the definition is moved.
#[derive(TypePath)]
struct NonStableTypePath;

// This type path will never change, even if the definition is moved.
#[derive(TypePath)]
#[type_path = "my_crate::foo"]
struct StableTypePath;

// Type paths can have any number of path segments.
#[derive(TypePath)]
#[type_path = "my_crate::foo::bar::baz"]
struct DeeplyNestedStableTypePath;

// Including just a crate name!
#[derive(TypePath)]
#[type_path = "my_crate"]
struct ShallowSt
...
```

---

## Struct UiPickingSettings Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UiPickingSettings.html

**Contents:**
- Struct UiPickingSettings Copy item path
- Fields§
- Trait Implementations§
  - impl Default for UiPickingSettings
    - fn default() -> UiPickingSettings
  - impl FromArg for UiPickingSettings
    - type This<'from_arg> = UiPickingSettings
    - fn from_arg( arg: Arg<'_>, ) -> Result<<UiPickingSettings as FromArg>::This<'_>, ArgError>
  - impl FromReflect for UiPickingSettings
    - fn from_reflect( reflect: &(dyn PartialReflect + 'static), ) -> Option<UiPickingSettings>

Runtime settings for the UiPickingPlugin.

When set to true UI picking will only consider cameras marked with UiPickingCamera and entities marked with Pickable. false by default.

This setting is provided to give you fine-grained control over which cameras and entities should be used by the UI picking backend at runtime.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UiPickingSettings {
    pub require_markers: bool,
}
```

---

## Enum TimerMode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.TimerMode.html

**Contents:**
- Enum TimerMode Copy item path
- Variants§
  - Once
  - Repeating
- Trait Implementations§
  - impl Clone for TimerMode
    - fn clone(&self) -> TimerMode
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for TimerMode
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>

Specifies Timer behavior.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum TimerMode {
    Once,
    Repeating,
}
```

---

## Module cores Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/cores/index.html

**Contents:**
- Module cores Copy item path
- Structs§
- Enums§
- Functions§

Core data structures to be used internally in Curve implementations, encapsulating storage and access patterns for reuse.

The Core types here expose their fields publicly so that it is easier to manipulate and extend them, but in doing so, you must maintain the invariants of those fields yourself. The provided methods all maintain the invariants, so this is only a concern if you manually mutate the fields.

---

## Derive Macro States Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.States.html

**Contents:**
- Derive Macro States Copy item path

Implements the States trait for a type - see the trait docs for an example usage.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(States)]
{
    // Attributes available to this derive:
    #[states]
}
```

---

## Struct ApplyDeferred Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ApplyDeferred.html

**Contents:**
- Struct ApplyDeferred Copy item path
  - §Scheduling
  - §Notes
- Trait Implementations§
  - impl IntoSystemSet<()> for ApplyDeferred
    - type Set = SystemTypeSet<ApplyDeferred>
    - fn into_system_set(self) -> <ApplyDeferred as IntoSystemSet<()>>::Set
  - impl System for ApplyDeferred
    - type In = ()
    - type Out = ()

A special System that instructs the executor to call System::apply_deferred on the systems that have run but not applied their Deferred system parameters (like Commands) or other system buffers.

ApplyDeferred systems are scheduled by default

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ApplyDeferred;
```

---

## Struct GraphCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GraphCurve.html

**Contents:**
- Struct GraphCurve Copy item path
- Trait Implementations§
  - impl<T, C> Clone for GraphCurve<T, C>where T: Clone, C: Clone,
    - fn clone(&self) -> GraphCurve<T, C>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, C> Curve<(f32, T)> for GraphCurve<T, C>where C: Curve<T>,
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> (f32, T)
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

A curve that is the graph of another curve over its parameter space. Curves of this type are produced by CurveExt::graph.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GraphCurve<T, C> { /* private fields */ }
```

---

## Struct GlobalTransform Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GlobalTransform.html

**Contents:**
- Struct GlobalTransform Copy item path
  - §Transform and GlobalTransform
- §Examples
- Implementations§
  - impl GlobalTransform
    - pub const IDENTITY: GlobalTransform
    - pub fn to_matrix(&self) -> Mat4
    - pub fn affine(&self) -> Affine3A
      - Examples found in repository?
    - pub fn compute_transform(&self) -> Transform

GlobalTransform is an affine transformation from entity-local coordinates to worldspace coordinates.

You cannot directly mutate GlobalTransform; instead, you change an entity’s transform by manipulating its Transform, which indirectly causes Bevy to update its GlobalTransform.

Transform transforms an entity relative to its parent’s reference frame, or relative to world space coordinates, if it doesn’t have a ChildOf component.

GlobalTransform is managed by Bevy; it is computed by successively applying the Transform of each ancestor entity which has a Transform. This is done automatically by Bevy-internal systems in the TransformSystems::Propagate system set.

This system runs during PostUpdate. If you update the Transform of an entity in this schedule or after, you will notice a 1 frame lag before the GlobalTransform is updated.

An identity GlobalTransform that maps all points in space to themselves.

Returns the 3d affine transformation matrix as a Mat4.

Returns the 3d affine transformation matrix as an Affine3A.

Returns the transformation as a Transform.

The transform is expected to be non-degenerate and without shearing, or the output will be invalid.

Computes a Scale-Rotation-Translation decomposition of the transformation and returns the isometric part as an isometry. Any scaling done by the transformation will be ignored. Note: this is a somewhat costly and lossy conversion.

The transform is expected to be non-degenerate and without shearing, or the output will be invalid.

Returns the Transform self would have if it was a child of an entity with the parent GlobalTransform.

This is useful if you want to “reparent” an Entity. Say you have an entity e1 that you want to turn into a child of e2, but you want e1 to keep the same global transform, even after re-parenting. You would use:

The transform is expected to be non-degenerate and without shearing, or the output will be invalid.

Extracts scale, rotation and translation from self.

The transform is expected to be non-degenerate and without shearing, or the output will be invalid.

Return the local right vector (X).

Return the local left vector (-X).

Return the local up vector (Y).

Return the local down vector (-Y).

Return the local back vector (Z).

Return the local forward vector (-Z).

Get the translation as a Vec3.

Get the translation as a Vec3A.

Get the rotation as a Quat.

The transform is expected to be non-degenerate and without shearing, or the output will be invalid.

This i

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct GlobalTransform(/* private fields */);
```

Example 2 (javascript):
```javascript
330pub fn extract_colored_mesh2d(
331    mut commands: Commands,
332    mut previous_len: Local<usize>,
333    // When extracting, you must use `Extract` to mark the `SystemParam`s
334    // which should be taken from the main world.
335    query: Extract<
336        Query<
337            (
338                Entity,
339                RenderEntity,
340                &ViewVisibility,
341                &GlobalTransform,
342                &Mesh2d,
343            ),
344            With<ColoredMesh2d>,
345        >,
346    >,
347    mut render_mesh_instances: ResMut<RenderColoredMesh2dInstances
...
```

Example 3 (javascript):
```javascript
#[derive(Component)]
struct ToReparent {
    new_parent: Entity,
}
fn reparent_system(
    mut commands: Commands,
    mut targets: Query<(&mut Transform, Entity, &GlobalTransform, &ToReparent)>,
    transforms: Query<&GlobalTransform>,
) {
    for (mut transform, entity, initial, to_reparent) in targets.iter_mut() {
        if let Ok(parent_transform) = transforms.get(to_reparent.new_parent) {
            *transform = initial.reparented_to(parent_transform);
            commands.entity(entity)
                .remove::<ToReparent>()
                .insert(ChildOf(to_reparent.new_parent));
  
...
```

Example 4 (javascript):
```javascript
104fn draw_bounds<Shape: Bounded2d + Send + Sync + 'static>(
105    q: Query<(&DrawBounds<Shape>, &GlobalTransform)>,
106    mut gizmos: Gizmos,
107) {
108    for (shape, transform) in &q {
109        let (_, rotation, translation) = transform.to_scale_rotation_translation();
110        let translation = translation.truncate();
111        let rotation = rotation.to_euler(EulerRot::XYZ).2;
112        let isometry = Isometry2d::new(translation, Rot2::radians(rotation));
113
114        let aabb = shape.0.aabb_2d(isometry);
115        gizmos.rect_2d(aabb.center(), aabb.half_size() * 2.0, RED);
116
...
```

---

## Macro related Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.related.html

**Contents:**
- Macro related Copy item path

Returns a SpawnRelatedBundle that will insert the given RelationshipTarget, spawn a SpawnableList of entities with given bundles that relate to the RelationshipTarget entity via the RelationshipTarget::Relationship component, and reserve space in the RelationshipTarget for each spawned entity.

The first argument is the RelationshipTarget type. Any additional arguments will be interpreted as bundles to be spawned.

Also see children for a Children-specific equivalent.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! related {
    ($relationship_target:ty [$($child:expr),*$(,)?]) => { ... };
}
```

Example 2 (javascript):
```javascript
let mut world = World::new();
world.spawn((
    Name::new("Root"),
    related!(Children[
        Name::new("Child1"),
        (
            Name::new("Child2"),
            related!(Children[
                Name::new("Grandchild"),
            ])
        )
    ])
));
```

---

## Enum Visibility Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Visibility.html

**Contents:**
- Enum Visibility Copy item path
- Variants§
  - Inherited
  - Hidden
  - Visible
- Implementations§
  - impl Visibility
    - pub fn toggle_inherited_visible(&mut self)
    - pub fn toggle_inherited_hidden(&mut self)
      - Examples found in repository?

User indication of whether an entity is visible. Propagates down the entity hierarchy.

If an entity is hidden in this way, all Children (and all of their children and so on) who are set to Inherited will also be hidden.

This is done by the visibility_propagate_system which uses the entity hierarchy and Visibility to set the values of each entity’s InheritedVisibility component.

An entity with Visibility::Inherited will inherit the Visibility of its ChildOf target.

A root-level entity that is set to Inherited will be visible.

An entity with Visibility::Hidden will be unconditionally hidden.

An entity with Visibility::Visible will be unconditionally visible.

Note that an entity with Visibility::Visible will be visible regardless of whether the ChildOf target entity is hidden.

Toggles between Visibility::Inherited and Visibility::Visible. If the value is Visibility::Hidden, it remains unaffected.

Toggles between Visibility::Inherited and Visibility::Hidden. If the value is Visibility::Visible, it remains unaffected.

Toggles between Visibility::Visible and Visibility::Hidden. If the value is Visibility::Inherited, it remains unaffected.

Required Components: InheritedVisibility, ViewVisibility.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Visibility {
    Inherited,
    Hidden,
    Visible,
}
```

Example 2 (unknown):
```unknown
408fn toggle_debug_overlay(
409    input: Res<ButtonInput<KeyCode>>,
410    mut debug_options: ResMut<UiDebugOptions>,
411    mut root_node_query: Query<&mut Visibility, (With<Node>, Without<ChildOf>)>,
412) {
413    info_once!("The debug outlines are enabled, press Space to turn them on/off");
414    if input.just_pressed(KeyCode::Space) {
415        // The toggle method will enable the debug overlay if disabled and disable if enabled
416        debug_options.toggle();
417    }
418
419    if input.just_pressed(KeyCode::KeyS) {
420        // Toggle debug outlines for nodes with `ViewVisibility
...
```

---

## Struct EntityWorldMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EntityWorldMut.html

**Contents:**
- Struct EntityWorldMut Copy item path
- Implementations§
  - impl<'w> EntityWorldMut<'w>
    - pub fn with_children( &mut self, func: impl FnOnce(&mut RelatedSpawner<'_, ChildOf>), ) -> &mut EntityWorldMut<'w>
    - pub fn add_children(&mut self, children: &[Entity]) -> &mut EntityWorldMut<'w>
    - pub fn clear_children(&mut self) -> &mut EntityWorldMut<'w>
    - pub fn insert_children( &mut self, index: usize, children: &[Entity], ) -> &mut EntityWorldMut<'w>
    - pub fn insert_child( &mut self, index: usize, child: Entity, ) -> &mut EntityWorldMut<'w>
    - pub fn add_child(&mut self, child: Entity) -> &mut EntityWorldMut<'w>
    - pub fn remove_children( &mut self, children: &[Entity], ) -> &mut EntityWorldMut<'w>

A mutable reference to a particular Entity, and the entire world.

This is essentially a performance-optimized (Entity, &mut World) tuple, which caches the EntityLocation to reduce duplicate lookups.

Since this type provides mutable access to the entire world, only one EntityWorldMut can exist at a time for a given world.

See also EntityMut, which allows disjoint mutable access to multiple entities at once. Unlike EntityMut, this type allows adding and removing components, and despawning the entity.

Spawns children of this entity (with a ChildOf relationship) by taking a function that operates on a ChildSpawner. See also with_related.

Adds the given children to this entity See also add_related.

Removes all the children from this entity. See also clear_related

Insert children at specific index. See also insert_related.

Insert child at specific index. See also insert_related.

Adds the given child to this entity See also add_related.

Removes the relationship between this entity and the given entities.

Removes the relationship between this entity and the given entity.

Replaces all the related children with a new set of children.

Replaces all the related children with a new set of children.

Failing to maintain the functions invariants may lead to erratic engine behavior including random crashes. Refer to Self::replace_related_with_difference for a list of these invariants.

Panics when debug assertions are enabled if an invariant is broken and the command is executed.

Spawns the passed bundle and adds it to this entity as a child.

For efficient spawning of multiple children, use with_children.

Adds the given boxed reflect component or bundle to the entity using the reflection data in AppTypeRegistry.

This will overwrite any previous component(s) of the same type.

Prefer to use the typed EntityWorldMut::insert if possible. Adding a reflected component is much slower.

Same as insert_reflect, but using the T resource as type registry instead of AppTypeRegistry.

This will overwrite any previous component(s) of the same type.

Removes from the entity the component or bundle with the given type path registered in AppTypeRegistry.

If the type is a bundle, it will remove any components in that bundle regardless if the entity contains all the components.

Does nothing if the type is a component and the entity does not have a component of the same type, if the type is a bundle and the entity does not contain any of the components in the bundle, or if

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct EntityWorldMut<'w> { /* private fields */ }
```

Example 2 (javascript):
```javascript
use bevy_ecs::prelude::*;

let mut world = World::new();
let e0 = world.spawn_empty().id();
let e1 = world.spawn_empty().id();
let e2 = world.spawn_empty().id();
let e3 = world.spawn_empty().id();
let e4 = world.spawn_empty().id();

let mut main_entity = world.spawn_empty();
main_entity.add_related::<ChildOf>(&[e0, e1, e2, e2]);
main_entity.insert_related::<ChildOf>(1, &[e0, e3, e4, e4]);
let main_id = main_entity.id();

let relationship_source = main_entity.get::<Children>().unwrap().collection();
assert_eq!(relationship_source, &[e1, e0, e3, e2, e4]);
```

Example 3 (javascript):
```javascript
103fn demo_2(world: &mut World) {
104    // Setup our name index
105    world.init_resource::<NameIndex>();
106
107    // Spawn some entities!
108    let alyssa = world.spawn(Name("Alyssa")).id();
109    let javier = world.spawn(Name("Javier")).id();
110
111    // Check our index
112    let index = world.resource::<NameIndex>();
113
114    assert_eq!(index.get_entity("Alyssa"), Some(alyssa));
115    assert_eq!(index.get_entity("Javier"), Some(javier));
116
117    // Changing the name of an entity is also fully capture by our index
118    world.entity_mut(javier).insert(Name("Steven"));
119
120
...
```

Example 4 (javascript):
```javascript
61fn scroll_area_demo() -> impl Bundle {
62    (
63        // Frame element which contains the scroll area and scrollbars.
64        Node {
65            display: Display::Grid,
66            width: px(200),
67            height: px(150),
68            grid_template_columns: vec![RepeatedGridTrack::flex(1, 1.), RepeatedGridTrack::auto(1)],
69            grid_template_rows: vec![RepeatedGridTrack::flex(1, 1.), RepeatedGridTrack::auto(1)],
70            row_gap: px(2),
71            column_gap: px(2),
72            ..default()
73        },
74        Children::spawn((SpawnWith(|parent: &mut Relat
...
```

---

## Struct Mat3A Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Mat3A.html

**Contents:**
- Struct Mat3A Copy item path
- Fields§
- Implementations§
  - impl Mat3A
    - pub const ZERO: Mat3A
    - pub const IDENTITY: Mat3A
    - pub const NAN: Mat3A
    - pub const fn from_cols(x_axis: Vec3A, y_axis: Vec3A, z_axis: Vec3A) -> Mat3A
    - pub const fn from_cols_array(m: &[f32; 9]) -> Mat3A
    - pub const fn to_cols_array(&self) -> [f32; 9]

A 3x3 column major matrix.

This 3x3 matrix type features convenience methods for creating and using linear and affine transformations. If you are primarily dealing with 2D affine transformations the Affine2 type is much faster and more space efficient than using a 3x3 matrix.

Linear transformations including 3D rotation and scale can be created using methods such as Self::from_diagonal(), Self::from_quat(), Self::from_axis_angle(), Self::from_rotation_x(), Self::from_rotation_y(), or Self::from_rotation_z().

The resulting matrices can be use to transform 3D vectors using regular vector multiplication.

Affine transformations including 2D translation, rotation and scale can be created using methods such as Self::from_translation(), Self::from_angle(), Self::from_scale() and Self::from_scale_angle_translation().

The Self::transform_point2() and Self::transform_vector2() convenience methods are provided for performing affine transforms on 2D vectors and points. These multiply 2D inputs as 3D vectors with an implicit z value of 1 for points and 0 for vectors respectively. These methods assume that Self contains a valid affine transform.

A 3x3 matrix with all elements set to 0.0.

A 3x3 identity matrix, where all diagonal elements are 1, and all off-diagonal elements are 0.

Creates a 3x3 matrix from three column vectors.

Creates a 3x3 matrix from a [f32; 9] array stored in column major order. If your data is stored in row major you will need to transpose the returned matrix.

Creates a [f32; 9] array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 3x3 matrix from a [[f32; 3]; 3] 3D array stored in column major order. If your data is in row major order you will need to transpose the returned matrix.

Creates a [[f32; 3]; 3] 3D array storing data in column major order. If you require data in row major order transpose the matrix first.

Creates a 3x3 matrix with its diagonal set to diagonal and all other entries set to 0.

Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.

Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the ith column and jth row.

Panics if i or j is greater than 3.

Creates a 3D rotation matrix from the given quaternion.

Will panic if rotation is not normalized when glam_assert is enabled.

Creates a 3D rotation matrix from a normalized rotation axis and angle (in radians).

Will panic if axis is not normalized when glam_ass

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct Mat3A {
    pub x_axis: Vec3A,
    pub y_axis: Vec3A,
    pub z_axis: Vec3A,
}
```

---

## Struct DynamicSceneRoot Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DynamicSceneRoot.html

**Contents:**
- Struct DynamicSceneRoot Copy item path
- Tuple Fields§
- Methods from Deref<Target = Handle<DynamicScene>>§
    - pub fn id(&self) -> AssetId<A>
      - Examples found in repository?
    - pub fn path(&self) -> Option<&AssetPath<'static>>
    - pub fn is_uuid(&self) -> bool
    - pub fn is_strong(&self) -> bool
- Trait Implementations§
  - impl Clone for DynamicSceneRoot

Adding this component will spawn the scene as a child of that entity. Once it’s spawned, the entity will have a SceneInstance component.

Returns the AssetId of this Asset.

Returns the path if this is (1) a strong handle and (2) the asset has a path

Returns true if this is a uuid handle.

Returns true if this is a strong handle.

Required Components: Transform, Visibility.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DynamicSceneRoot(pub Handle<DynamicScene>);
```

Example 2 (javascript):
```javascript
112    fn as_asset_id(&self) -> AssetId<Self::Asset> {
113        self.0.id()
114    }
115}
116
117#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
118struct ImageMaterial {
119    image: Handle<Image>,
120}
121
122impl ErasedRenderAsset for ImageMaterial {
123    type SourceAsset = ImageMaterial;
124    type ErasedAsset = PreparedMaterial;
125    type Param = (
126        SRes<DrawFunctions<Opaque3d>>,
127        SRes<ImageMaterialBindGroupLayout>,
128        SRes<AssetServer>,
129        SResMut<MaterialBindGroupAllocators>,
130        SResMut<RenderMaterialBindings>,
131        SRes<Re
...
```

Example 3 (javascript):
```javascript
111fn update_tileset_image(
112    chunk_query: Single<&TilemapChunk>,
113    mut events: MessageReader<AssetEvent<Image>>,
114    mut images: ResMut<Assets<Image>>,
115) {
116    let chunk = *chunk_query;
117    for event in events.read() {
118        if event.is_loaded_with_dependencies(chunk.tileset.id()) {
119            let image = images.get_mut(&chunk.tileset).unwrap();
120            image.reinterpret_stacked_2d_as_array(4);
121        }
122    }
123}
```

Example 4 (javascript):
```javascript
169fn print_counts(
170    time: Res<Time>,
171    mut timer: Local<PrintingTimer>,
172    texts: Query<&ViewVisibility, With<Text2d>>,
173    atlases: Res<FontAtlasSets>,
174    font: Res<FontHandle>,
175) {
176    timer.tick(time.delta());
177    if !timer.just_finished() {
178        return;
179    }
180
181    let num_atlases = atlases
182        .get(font.0.id())
183        .map(|set| set.iter().map(|atlas| atlas.1.len()).sum())
184        .unwrap_or(0);
185
186    let visible_texts = texts.iter().filter(|visibility| visibility.get()).count();
187
188    info!(
189        "Texts: {} Visib
...
```

---

## Enum AlignContent Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.AlignContent.html

**Contents:**
- Enum AlignContent Copy item path
- Variants§
  - Default
  - Start
  - End
  - FlexStart
  - FlexEnd
  - Center
  - Stretch
  - SpaceBetween

Used to control how items are distributed.

https://developer.mozilla.org/en-US/docs/Web/CSS/align-content

The items are packed in their default position as if no alignment was applied.

The items are packed towards the start of the axis.

The items are packed towards the end of the axis.

The items are packed towards the start of the axis, unless the flex direction is reversed; then the items are packed towards the end of the axis.

The items are packed towards the end of the axis, unless the flex direction is reversed; then the items are packed towards the start of the axis.

The items are packed along the center of the axis.

The items are stretched to fill the container along the axis.

The items are distributed such that the gap between any two items is equal.

The items are distributed such that the gap between and around any two items is equal.

The items are distributed such that the gap between and around any two items is equal, with half-size gaps on either end.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum AlignContent {
    Default,
    Start,
    End,
    FlexStart,
    FlexEnd,
    Center,
    Stretch,
    SpaceBetween,
    SpaceEvenly,
    SpaceAround,
}
```

---

## Enum RepeatError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.RepeatError.html

**Contents:**
- Enum RepeatError Copy item path
- Variants§
  - SourceDomainUnbounded
- Trait Implementations§
  - impl Debug for RepeatError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for RepeatError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for RepeatError
    - fn source(&self) -> Option<&(dyn Error + 'static)>

An error indicating that a repetition of a curve couldn’t be performed because of malformed inputs.

The source curve that was to be repeated had unbounded domain.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum RepeatError {
    SourceDomainUnbounded,
}
```

---

## Struct SampleCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SampleCurve.html

**Contents:**
- Struct SampleCurve Copy item path
- Implementations§
  - impl<T, I> SampleCurve<T, I>
    - pub fn new( domain: Interval, samples: impl IntoIterator<Item = T>, interpolation: I, ) -> Result<SampleCurve<T, I>, EvenCoreError>where I: Fn(&T, &T, f32) -> T,
- Trait Implementations§
  - impl<T, I> Clone for SampleCurve<T, I>where T: Clone, I: Clone,
    - fn clone(&self) -> SampleCurve<T, I>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, I> Curve<T> for SampleCurve<T, I>where T: Clone, I: Fn(&T, &T, f32) -> T,
    - fn domain(&self) -> Interval

A curve that is defined by explicit neighbor interpolation over a set of evenly-spaced samples.

Create a new SampleCurve using the specified interpolation to interpolate between the given samples. An error is returned if there are not at least 2 samples or if the given domain is unbounded.

The interpolation takes two values by reference together with a scalar parameter and produces an owned value. The expectation is that interpolation(&x, &y, 0.0) and interpolation(&x, &y, 1.0) are equivalent to x and y respectively.

Note: This is not a fully stable implementation of TypePath due to usage of type_name for function members.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SampleCurve<T, I> { /* private fields */ }
```

---

## Enum Gradient Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.Gradient.html

**Contents:**
- Enum Gradient Copy item path
- Variants§
  - Linear(LinearGradient)
  - Radial(RadialGradient)
  - Conic(ConicGradient)
- Implementations§
  - impl Gradient
    - pub const fn is_empty(&self) -> bool
    - pub fn get_single(&self) -> Option<Color>
- Trait Implementations§

https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient

https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient

https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient

Returns true if the gradient has no stops.

If the gradient has only a single color stop, get_single returns its color.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum Gradient {
    Linear(LinearGradient),
    Radial(RadialGradient),
    Conic(ConicGradient),
}
```

---

## Struct ComputedUiTargetCamera Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ComputedUiTargetCamera.html

**Contents:**
- Struct ComputedUiTargetCamera Copy item path
- Implementations§
  - impl ComputedUiTargetCamera
    - pub fn get(&self) -> Option<Entity>
      - Examples found in repository?
- Trait Implementations§
  - impl Clone for ComputedUiTargetCamera
    - fn clone(&self) -> ComputedUiTargetCamera
    - fn clone_from(&mut self, source: &Self)
  - impl Component for ComputedUiTargetCamerawhere ComputedUiTargetCamera: Send + Sync + 'static,

Derived information about the camera target for this UI node.

Updated in UiSystems::Prepare by propagate_ui_target_cameras

Returns the id of the target camera for this UI node.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ComputedUiTargetCamera { /* private fields */ }
```

Example 2 (javascript):
```javascript
181fn button_system(
182    interaction_query: Query<
183        (&Interaction, &ComputedUiTargetCamera, &RotateCamera),
184        (Changed<Interaction>, With<Button>),
185    >,
186    mut camera_query: Query<&mut Transform, With<Camera>>,
187) {
188    for (interaction, computed_target, RotateCamera(direction)) in &interaction_query {
189        if let Interaction::Pressed = *interaction {
190            // Since TargetCamera propagates to the children, we can use it to find
191            // which side of the screen the button is on.
192            if let Some(mut camera_transform) = compu
...
```

---

## Function resource_exists_and_changed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_exists_and_changed.html

**Contents:**
- Function resource_exists_and_changed Copy item path
- §Example

A SystemCondition-satisfying system that returns true if the resource of the given type has been added or mutably dereferenced since the condition was last checked.

Note that simply mutably dereferencing a resource is considered a change (DerefMut). Bevy does not compare resources to their previous values.

The condition will return false if the resource does not exist.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_exists_and_changed<T>(res: Option<Res<'_, T>>) -> boolwhere
    T: Resource,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_exists_and_changed` will only return true if the
    // given resource exists and was just changed (or added)
    my_system.run_if(
        resource_exists_and_changed::<Counter>
        // By default detecting changes will also trigger if the resource was
        // just added, this won't work with my example so I will add a second
        // condition to make sure the resource wasn't just added
        .and(not(resource_added::<Counter>))
    ),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `Counter` doesn't exist so `my_system` 
...
```

---

## Struct OverrideClip Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.OverrideClip.html

**Contents:**
- Struct OverrideClip Copy item path
- Trait Implementations§
  - impl Component for OverrideClipwhere OverrideClip: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior
    - fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_replace() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>

UI node entities with this component will ignore any clipping rect they inherit, the node will not be clipped regardless of its ancestors’ Overflow setting.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct OverrideClip;
```

---

## Macro vec Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.vec.html

**Contents:**
- Macro vec Copy item path

Creates a Vec containing the arguments.

vec! allows Vecs to be defined with the same syntax as array expressions. There are two forms of this macro:

Note that unlike array expressions this syntax supports all elements which implement Clone and the number of elements doesn’t have to be a constant.

This will use clone to duplicate an expression, so one should be careful using this with types having a nonstandard Clone implementation. For example, vec![Rc::new(1); 5] will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.

Also, note that vec![expr; 0] is allowed, and produces an empty vector. This will still evaluate expr, however, and immediately drop the resulting value, so be mindful of side effects.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! vec {
    () => { ... };
    ($elem:expr; $n:expr) => { ... };
    ($($x:expr),+ $(,)?) => { ... };
}
```

Example 2 (javascript):
```javascript
let v = vec![1, 2, 3];
assert_eq!(v[0], 1);
assert_eq!(v[1], 2);
assert_eq!(v[2], 3);
```

Example 3 (javascript):
```javascript
let v = vec![1; 3];
assert_eq!(v, [1, 1, 1]);
```

---

## Type Alias TextUiReader Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/type.TextUiReader.html

**Contents:**
- Type Alias TextUiReader Copy item path
- Aliased Type§

UI alias for TextReader.

**Examples:**

Example 1 (unknown):
```unknown
pub type TextUiReader<'w, 's> = TextReader<'w, 's, Text>;
```

Example 2 (unknown):
```unknown
pub struct TextUiReader<'w, 's> { /* private fields */ }
```

---

## Crate app Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/index.html

**Contents:**
- Crate app Copy item path
- Modules§
- Macros§
- Structs§
- Enums§
- Traits§
- Functions§
- Type Aliases§
- Derive Macros§

This crate is about everything concerning the highest-level, application layer of a Bevy app.

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/utils/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§
- Functions§

The utilities prelude.

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct DragLeave Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragLeave.html

**Contents:**
- Struct DragLeave Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragLeave
    - fn clone(&self) -> DragLeave
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragLeave
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragLeave
    - type This<'from_arg> = DragLeave

Fires when a pointer dragging the dragged entity leaves the target entity.

Pointer button pressed while leaving drag.

The entity that was being dragged when the pointer left the target entity.

Information about the latest prior picking intersection.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragLeave {
    pub button: PointerButton,
    pub dragged: Entity,
    pub hit: HitData,
}
```

---

## Trait ColorToComponents Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ColorToComponents.html

**Contents:**
- Trait ColorToComponents Copy item path
- Required Methods§
    - fn to_f32_array(self) -> [f32; 4]
    - fn to_f32_array_no_alpha(self) -> [f32; 3]
    - fn to_vec4(self) -> Vec4
    - fn to_vec3(self) -> Vec3
    - fn from_f32_array(color: [f32; 4]) -> Self
    - fn from_f32_array_no_alpha(color: [f32; 3]) -> Self
    - fn from_vec4(color: Vec4) -> Self
    - fn from_vec3(color: Vec3) -> Self

Trait with methods for converting colors to non-color types

Convert to an f32 array

Convert to an f32 array without the alpha value

Convert from an f32 array

Convert from an f32 array without the alpha value

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ColorToComponents {
    // Required methods
    fn to_f32_array(self) -> [f32; 4];
    fn to_f32_array_no_alpha(self) -> [f32; 3];
    fn to_vec4(self) -> Vec4;
    fn to_vec3(self) -> Vec3;
    fn from_f32_array(color: [f32; 4]) -> Self;
    fn from_f32_array_no_alpha(color: [f32; 3]) -> Self;
    fn from_vec4(color: Vec4) -> Self;
    fn from_vec3(color: Vec3) -> Self;
}
```

---

## Struct TransformTreeChanged Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.TransformTreeChanged.html

**Contents:**
- Struct TransformTreeChanged Copy item path
- Trait Implementations§
  - impl Clone for TransformTreeChanged
    - fn clone(&self) -> TransformTreeChanged
    - fn clone_from(&mut self, source: &Self)
  - impl Component for TransformTreeChangedwhere TransformTreeChanged: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior

An optimization for transform propagation. This ZST marker component uses change detection to mark all entities of the hierarchy as “dirty” if any of their descendants have a changed Transform. If this component is not marked is_changed(), propagation will halt.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct TransformTreeChanged;
```

---

## Struct CubicBezier Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicBezier.html

**Contents:**
- Struct CubicBezier Copy item path
    - §Interpolation
    - §Tangency
    - §Continuity
    - §Usage
- Fields§
- Implementations§
  - impl<P> CubicBezier<P>where P: VectorSpace,
    - pub fn new(control_points: impl IntoIterator<Item = [P; 4]>) -> CubicBezier<P>
      - Examples found in repository?

A spline composed of a single cubic Bezier curve.

Useful for user-drawn curves with local control, or animation easing. See CubicSegment::new_bezier_easing for use in easing.

The curve only passes through the first and last control point in each set of four points. The curve is divided into “segments” by every fourth control point.

Tangents are manually defined by the two intermediate control points within each set of four points. You can think of the control points the curve passes through as “anchors”, and as the intermediate control points as the anchors displaced along their tangent vectors

A Bezier curve is at minimum C0 continuous, meaning it has no holes or jumps. Each curve segment is C2, meaning the tangent vector changes smoothly between each set of four control points, but this doesn’t hold at the control points between segments. Making the whole curve C1 or C2 requires moving the intermediate control points to align the tangent vectors between segments, and can result in a loss of local control.

The control points of the Bezier curve.

Create a new cubic Bezier curve from sets of control points.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicBezier<P>where
    P: VectorSpace,{
    pub control_points: Vec<[P; 4]>,
}
```

Example 2 (javascript):
```javascript
let points = [[
    vec2(-1.0, -20.0),
    vec2(3.0, 2.0),
    vec2(5.0, 3.0),
    vec2(9.0, 8.0),
]];
let bezier = CubicBezier::new(points).to_curve().unwrap();
let positions: Vec<_> = bezier.iter_positions(100).collect();
```

Example 3 (unknown):
```unknown
73fn spawn_curve_sprite<T: CurveColor>(commands: &mut Commands, y: f32, points: [T; 4]) {
74    commands.spawn((
75        Sprite::sized(Vec2::new(75., 75.)),
76        Transform::from_xyz(0., y, 0.),
77        Curve(CubicBezier::new([points]).to_curve().unwrap()),
78    ));
79}
```

---

## Struct ScreenSpaceAmbientOcclusionPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ScreenSpaceAmbientOcclusionPlugin.html

**Contents:**
- Struct ScreenSpaceAmbientOcclusionPlugin Copy item path
- Trait Implementations§
  - impl Plugin for ScreenSpaceAmbientOcclusionPlugin
    - fn build(&self, app: &mut App)
    - fn finish(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn cleanup(&self, _app: &mut App)
    - fn name(&self) -> &str
    - fn is_unique(&self) -> bool
- Auto Trait Implementations§

Plugin for screen space ambient occlusion.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ScreenSpaceAmbientOcclusionPlugin;
```

---

## Struct Text Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Text.html

**Contents:**
- Struct Text Copy item path
- Tuple Fields§
- Implementations§
  - impl Text
    - pub fn new(text: impl Into<String>) -> Text
      - Examples found in repository?
- Methods from Deref<Target = String>§
    - pub fn as_str(&self) -> &str
      - §Examples
    - pub fn as_mut_str(&mut self) -> &mut str

The top-level UI text component.

Adding Text to an entity will pull in required components for setting up a UI text node.

The string in this component is the first ‘text span’ in a hierarchy of text spans that are collected into a ComputedTextBlock. See TextSpan for the component used by children of entities with Text.

Note that Transform on this entity is managed automatically by the UI layout system.

Makes a new text component.

Extracts a string slice containing the entire String.

Converts a String into a mutable string slice.

Appends a given string slice onto the end of this String.

Copies elements from src range to the end of the string.

Panics if the range has start_bound > end_bound, or, if the range is bounded on either end and does not lie on a char boundary.

Returns this String’s capacity, in bytes.

Reserves capacity for at least additional bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient.

Panics if the new capacity overflows usize.

This might not actually increase the capacity:

Reserves the minimum capacity for at least additional bytes more than the current length. Unlike reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling reserve_exact, capacity will be greater than or equal to self.len() + additional. Does nothing if the capacity is already sufficient.

Panics if the new capacity overflows usize.

This might not actually increase the capacity:

Tries to reserve capacity for at least additional bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling try_reserve, capacity will be greater than or equal to self.len() + additional if it returns Ok(()). Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.

If the capacity overflows, or the allocator reports a failure, then an error is returned.

Tries to reserve the minimum capacity for at least additional bytes more than the current length. Unlike try_reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling try_reserve_exact, capacity will be greater than or equal to self.len() + additional if it returns Ok(()). Does nothing if the capacity is alr

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Text(pub String);
```

Example 2 (unknown):
```unknown
// Basic usage.
world.spawn(Text::new("hello world!"));

// With non-default style.
world.spawn((
    Text::new("hello world!"),
    TextFont {
        font: font_handle.clone().into(),
        font_size: 60.0,
        ..Default::default()
    },
    TextColor(BLUE.into()),
));

// With text justification.
world.spawn((
    Text::new("hello world\nand bevy!"),
    TextLayout::new_with_justify(Justify::Center)
));

// With spans
world.spawn(Text::new("hello ")).with_children(|parent| {
    parent.spawn(TextSpan::new("world"));
    parent.spawn((TextSpan::new("!"), TextColor(BLUE.into())));
});
```

Example 3 (unknown):
```unknown
154pub fn ui_text(label: &str, color: Color) -> impl Bundle + use<> {
155    (
156        Text::new(label),
157        TextFont {
158            font_size: 18.0,
159            ..default()
160        },
161        TextColor(color),
162    )
163}
```

Example 4 (unknown):
```unknown
403fn spawn_help_text(commands: &mut Commands) {
404    commands.spawn((
405        Text::new(""),
406        Node {
407            position_type: PositionType::Absolute,
408            top: px(12),
409            left: px(12),
410            ..default()
411        },
412    ));
413}
```

---

## Struct ElasticCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ElasticCurve.html

**Contents:**
- Struct ElasticCurve Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl Clone for ElasticCurve
    - fn clone(&self) -> ElasticCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ElasticCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>

f(omega,t) = 1 - (1 - t)²(2sin(omega * t) / omega + cos(omega * t)), parametrized by omega

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ElasticCurve(pub f32);
```

---

## Struct Segment3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Segment3d.html

**Contents:**
- Struct Segment3d Copy item path
- Fields§
- Implementations§
  - impl Segment3d
    - pub const fn new(point1: Vec3, point2: Vec3) -> Segment3d
    - pub fn from_direction_and_length(direction: Dir3, length: f32) -> Segment3d
    - pub fn from_scaled_direction(scaled_direction: Vec3) -> Segment3d
    - pub fn from_ray_and_length(ray: Ray3d, length: f32) -> Segment3d
    - pub const fn point1(&self) -> Vec3
    - pub const fn point2(&self) -> Vec3

A line segment defined by two endpoints in 3D space.

The endpoints of the line segment.

Create a new Segment3d from its endpoints.

Create a new Segment3d centered at the origin with the given direction and length.

The endpoints will be at -direction * length / 2.0 and direction * length / 2.0.

Create a new Segment3d centered at the origin from a vector representing the direction and length of the line segment.

The endpoints will be at -scaled_direction / 2.0 and scaled_direction / 2.0.

Create a new Segment3d starting from the origin of the given ray, going in the direction of the ray for the given length.

The endpoints will be at ray.origin and ray.origin + length * ray.direction.

Get the position of the first endpoint of the line segment.

Get the position of the second endpoint of the line segment.

Compute the midpoint between the two endpoints of the line segment.

Compute the length of the line segment.

Compute the squared length of the line segment.

Compute the normalized direction pointing from the first endpoint to the second endpoint.

For the non-panicking version, see Segment3d::try_direction.

Panics if a valid direction could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Try to compute the normalized direction pointing from the first endpoint to the second endpoint.

Returns Err(InvalidDirectionError) if a valid direction could not be computed, for example when the endpoints are coincident, NaN, or infinite.

Compute the vector from the first endpoint to the second endpoint.

Compute the segment transformed by the given Isometry3d.

Compute the segment translated by the given vector.

Compute the segment rotated around the origin by the given rotation.

Compute the segment rotated around the given point by the given rotation.

Compute the segment rotated around its own center.

Compute the segment with its center at the origin, keeping the same direction and length.

Compute the segment with a new length, keeping the same direction and center.

Reverses the direction of the line segment by swapping the endpoints.

Returns the line segment with its direction reversed by swapping the endpoints.

Returns the point on the Segment3d that is closest to the specified point.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Segment3d {
    pub vertices: [Vec3; 2],
}
```

---

## Derive Macro Deref Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Deref.html

**Contents:**
- Derive Macro Deref Copy item path
- §Example
  - §Tuple Structs
  - §Named Structs

Implements Deref for structs. This is especially useful when utilizing the newtype pattern.

For single-field structs, the implementation automatically uses that field. For multi-field structs, you must specify which field to use with the #[deref] attribute.

If you need DerefMut as well, consider using the other derive macro alongside this one.

Using a single-field struct:

Using a multi-field struct:

Using a single-field struct:

Using a multi-field struct:

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Deref)]
{
    // Attributes available to this derive:
    #[deref]
}
```

Example 2 (javascript):
```javascript
use bevy_derive::Deref;

#[derive(Deref)]
struct MyNewtype(String);

let foo = MyNewtype(String::from("Hello"));
assert_eq!("Hello", *foo);
```

Example 3 (javascript):
```javascript
use bevy_derive::Deref;

#[derive(Deref)]
struct MyStruct<T>(#[deref] String, PhantomData<T>);

let foo = MyStruct(String::from("Hello"), PhantomData::<usize>);
assert_eq!("Hello", *foo);
```

Example 4 (javascript):
```javascript
use bevy_derive::{Deref, DerefMut};

#[derive(Deref, DerefMut)]
struct MyStruct {
  value: String,
}

let foo = MyStruct {
  value: String::from("Hello")
};
assert_eq!("Hello", *foo);
```

---

## Struct AssetChanged Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AssetChanged.html

**Contents:**
- Struct AssetChanged Copy item path
- §Quirks
- §Performance
- Trait Implementations§
  - impl<A> QueryFilter for AssetChanged<A>where A: AsAssetId,
    - const IS_ARCHETYPAL: bool = false
    - unsafe fn filter_fetch( state: &<AssetChanged<A> as WorldQuery>::State, fetch: &mut <AssetChanged<A> as WorldQuery>::Fetch<'_>, entity: Entity, table_row: TableRow, ) -> bool
  - impl<A> WorldQuery for AssetChanged<A>where A: AsAssetId,
    - const IS_DENSE: bool = <&A>::IS_DENSE
    - type Fetch<'w> = AssetChangedFetch<'w, A>

Filter that selects entities with an A for an asset that changed after the system last ran, where A is a component that implements AsAssetId.

Unlike Changed<A>, this is true whenever the asset for the A in ResMut<Assets<A>> changed. For example, when a mesh changed through the Assets<Mesh>::get_mut method, AssetChanged<Mesh> will iterate over all entities with the Handle<Mesh> for that mesh. Meanwhile, Changed<Handle<Mesh>> will iterate over no entities.

Swapping the actual A component is a common pattern. So you should check for both AssetChanged<A> and Changed<A> with Or<(Changed<A>, AssetChanged<A>)>.

The list of changed assets only gets updated in the AssetEventSystems system set, which runs in PostUpdate. Therefore, AssetChanged will only pick up asset changes in schedules following AssetEventSystems or the next frame. Consider adding the system in the Last schedule after AssetEventSystems if you need to react without frame delay to asset changes.

When at least one A is updated, this will read a hashmap once per entity with an A component. The runtime of the query is proportional to how many entities with an A it matches.

If no A asset updated since the last time the system ran, then no lookups occur.

SAFETY: read-only access

SAFETY: ROQueryFetch<Self> is the same as QueryFetch<Self>

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AssetChanged<A>(/* private fields */)
where
    A: AsAssetId;
```

---

## Struct PointerTraversalItem Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PointerTraversalItem.html

**Contents:**
- Struct PointerTraversalItem Copy item path
- Auto Trait Implementations§
  - impl<'__w, '__s> Freeze for PointerTraversalItem<'__w, '__s>
  - impl<'__w, '__s> RefUnwindSafe for PointerTraversalItem<'__w, '__s>
  - impl<'__w, '__s> Send for PointerTraversalItem<'__w, '__s>
  - impl<'__w, '__s> Sync for PointerTraversalItem<'__w, '__s>
  - impl<'__w, '__s> Unpin for PointerTraversalItem<'__w, '__s>
  - impl<'__w, '__s> UnwindSafe for PointerTraversalItem<'__w, '__s>
- Blanket Implementations§
  - impl<T> Any for Twhere T: 'static + ?Sized,

Automatically generated WorldQuery item type for PointerTraversal, returned when iterating over query results.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PointerTraversalItem<'__w, '__s> { /* private fields */ }
```

---

## Struct FixedUpdate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FixedUpdate.html

**Contents:**
- Struct FixedUpdate Copy item path
- Trait Implementations§
  - impl Clone for FixedUpdate
    - fn clone(&self) -> FixedUpdate
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for FixedUpdate
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for FixedUpdate
    - fn default() -> FixedUpdate
  - impl Hash for FixedUpdate

The schedule that contains most gameplay logic, which runs at a fixed rate rather than every render frame. For logic that should run once per render frame, use the Update schedule instead.

Examples of systems that should run at a fixed rate include (but are not limited to):

See the Update schedule for examples of systems that should not use this schedule. See the FixedMain schedule for details on how fixed updates work. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FixedUpdate;
```

---

## Trait DirectAssetAccessExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.DirectAssetAccessExt.html

**Contents:**
- Trait DirectAssetAccessExt Copy item path
- Required Methods§
    - fn add_asset<A>(&mut self, asset: impl Into<A>) -> Handle<A>where A: Asset,
    - fn load_asset<'a, A>(&self, path: impl Into<AssetPath<'a>>) -> Handle<A>where A: Asset,
    - fn load_asset_with_settings<'a, A, S>( &self, path: impl Into<AssetPath<'a>>, settings: impl Fn(&mut S) + Send + Sync + 'static, ) -> Handle<A>where A: Asset, S: Settings,
- Dyn Compatibility§
- Implementors§
  - impl DirectAssetAccessExt for World

An extension trait for methods for working with assets directly from a World.

Insert an asset similarly to Assets::add.

Load an asset similarly to AssetServer::load.

Load an asset with settings, similarly to AssetServer::load_with_settings.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait DirectAssetAccessExt {
    // Required methods
    fn add_asset<A>(&mut self, asset: impl Into<A>) -> Handle<A>
       where A: Asset;
    fn load_asset<'a, A>(&self, path: impl Into<AssetPath<'a>>) -> Handle<A>
       where A: Asset;
    fn load_asset_with_settings<'a, A, S>(
        &self,
        path: impl Into<AssetPath<'a>>,
        settings: impl Fn(&mut S) + Send + Sync + 'static,
    ) -> Handle<A>
       where A: Asset,
             S: Settings;
}
```

---

## Enum InterpolationColorSpace Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.InterpolationColorSpace.html

**Contents:**
- Enum InterpolationColorSpace Copy item path
- Variants§
  - Oklaba
  - Oklcha
  - OklchaLong
  - Srgba
  - LinearRgba
  - Hsla
  - HslaLong
  - Hsva

The color space used for interpolation.

Interpolates in OKLABA space.

Interpolates in OKLCHA space, taking the shortest hue path.

Interpolates in OKLCHA space, taking the longest hue path.

Interpolates in sRGBA space.

Interpolates in linear sRGBA space.

Interpolates in HSLA space, taking the shortest hue path.

Interpolates in HSLA space, taking the longest hue path.

Interpolates in HSVA space, taking the shortest hue path.

Interpolates in HSVA space, taking the longest hue path.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum InterpolationColorSpace {
    Oklaba,
    Oklcha,
    OklchaLong,
    Srgba,
    LinearRgba,
    Hsla,
    HslaLong,
    Hsva,
    HsvaLong,
}
```

---

## Struct Laba Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Laba.html

**Contents:**
- Struct Laba Copy item path
- §Conversion
- Fields§
- Implementations§
  - impl Laba
    - pub const CIE_EPSILON: f32 = 0.00885645207f32
    - pub const CIE_KAPPA: f32 = 903.296325f32
    - pub const fn new(lightness: f32, a: f32, b: f32, alpha: f32) -> Laba
      - §Arguments
    - pub const fn lab(lightness: f32, a: f32, b: f32) -> Laba

Color in LAB color space, with alpha

Conversion between the various color spaces is achieved using Rust’s native From trait. Because certain color spaces are defined by their transformation to and from another space, these From implementations reflect that set of definitions.

For example, the sRGB space is defined by its relationship with Linear RGB, and HWB by its with sRGB. As such, it is the responsibility of sRGB to provide From implementations for Linear RGB, and HWB for sRGB. To then provide conversion between Linear RGB and HWB directly, HWB is responsible for implementing these conversions, delegating to sRGB as an intermediatory. This ensures that all conversions take the shortest path between any two spaces, and limit the proliferation of domain specific knowledge for each color space to their respective definitions.

The lightness channel. [0.0, 1.5]

The a axis. [-1.5, 1.5]

The b axis. [-1.5, 1.5]

The alpha channel. [0.0, 1.0]

See Continuity (16) (17)

See Continuity (16) (17)

Construct a new Laba color from components.

Construct a new Laba color from (l, a, b) components, with the default alpha (1.0).

Return a copy of this color with the lightness channel set to the given value.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Laba {
    pub lightness: f32,
    pub a: f32,
    pub b: f32,
    pub alpha: f32,
}
```

Example 2 (javascript):
```javascript
let color = Srgba::rgb(0.5, 0.5, 0.5);

// Using From explicitly
let linear_color = LinearRgba::from(color);

// Using Into
let linear_color: LinearRgba = color.into();
```

---

## Derive Macro DerefMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.DerefMut.html

**Contents:**
- Derive Macro DerefMut Copy item path
- §Example
  - §Tuple Structs
  - §Named Structs

Implements DerefMut for structs. This is especially useful when utilizing the newtype pattern.

For single-field structs, the implementation automatically uses that field. For multi-field structs, you must specify which field to use with the #[deref] attribute.

DerefMut requires a Deref implementation. You can implement it manually or use Bevy’s derive macro for convenience.

Using a single-field struct:

Using a multi-field struct:

Using a single-field struct:

Using a multi-field struct:

**Examples:**

Example 1 (unknown):
```unknown
#[derive(DerefMut)]
{
    // Attributes available to this derive:
    #[deref]
}
```

Example 2 (javascript):
```javascript
use bevy_derive::{Deref, DerefMut};

#[derive(Deref, DerefMut)]
struct MyNewtype(String);

let mut foo = MyNewtype(String::from("Hello"));
foo.push_str(" World!");
assert_eq!("Hello World!", *foo);
```

Example 3 (javascript):
```javascript
use bevy_derive::{Deref, DerefMut};

#[derive(Deref, DerefMut)]
struct MyStruct<T>(#[deref] String, PhantomData<T>);

let mut foo = MyStruct(String::from("Hello"), PhantomData::<usize>);
foo.push_str(" World!");
assert_eq!("Hello World!", *foo);
```

Example 4 (javascript):
```javascript
use bevy_derive::{Deref, DerefMut};

#[derive(Deref, DerefMut)]
struct MyStruct {
  value: String,
}

let mut foo = MyStruct {
  value: String::from("Hello")
};
foo.push_str(" World!");
assert_eq!("Hello World!", *foo);
```

---

## Struct RawHandleWrapper Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/window/struct.RawHandleWrapper.html

**Contents:**
- Struct RawHandleWrapper Copy item path
- Implementations§
  - impl RawHandleWrapper
    - pub fn new<W>( window: &WindowWrapper<W>, ) -> Result<RawHandleWrapper, HandleError>where W: HasWindowHandle + HasDisplayHandle + 'static,
    - pub unsafe fn get_handle(&self) -> ThreadLockedRawWindowHandleWrapper
      - §Safety
    - pub fn get_window_handle(&self) -> RawWindowHandle
    - pub unsafe fn set_window_handle( &mut self, window_handle: RawWindowHandle, ) -> &mut RawHandleWrapper
      - §Safety
    - pub fn get_display_handle(&self) -> RawDisplayHandle

A wrapper over RawWindowHandle and RawDisplayHandle that allows us to safely pass it across threads.

Depending on the platform, the underlying pointer-containing handle cannot be used on all threads, and so we cannot simply make it (or any type that has a safe operation to get a RawWindowHandle or RawDisplayHandle) thread-safe.

Creates a RawHandleWrapper from a WindowWrapper.

Returns a HasWindowHandle + HasDisplayHandle impl, which exposes WindowHandle and DisplayHandle.

Some platforms have constraints on where/how this handle can be used. For example, some platforms don’t support doing window operations off of the main thread. The caller must ensure the RawHandleWrapper is only used in valid contexts.

Gets the stored window handle.

Sets the window handle.

The passed in RawWindowHandle must be a valid window handle.

Gets the stored display handle

Sets the display handle.

The passed in RawDisplayHandle must be a valid display handle.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RawHandleWrapper { /* private fields */ }
```

---

## Enum MaxTrackSizingFunction Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.MaxTrackSizingFunction.html

**Contents:**
- Enum MaxTrackSizingFunction Copy item path
- Variants§
  - Px(f32)
  - Percent(f32)
  - MinContent
  - MaxContent
  - FitContentPx(f32)
  - FitContentPercent(f32)
  - Auto
  - Fraction(f32)

Track maximum size should be a fixed pixel value

Track maximum size should be a percentage value

Track maximum size should be content sized under a min-content constraint

Track maximum size should be content sized under a max-content constraint

Track maximum size should be sized according to the fit-content formula with a fixed pixel limit

Track maximum size should be sized according to the fit-content formula with a percentage limit

Track maximum size should be automatically sized

The dimension as a fraction of the total available grid space (fr units in CSS) Specified value is the numerator of the fraction. Denominator is the sum of all fractions specified in that grid dimension.

Spec: https://www.w3.org/TR/css3-grid-layout/#fr-unit

Track maximum size should be a percent of the viewport’s smaller dimension.

Track maximum size should be a percent of the viewport’s smaller dimension.

Track maximum size should be a percent of the viewport’s height dimension.

Track maximum size should be a percent of the viewport’s width dimension.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum MaxTrackSizingFunction {
    Px(f32),
    Percent(f32),
    MinContent,
    MaxContent,
    FitContentPx(f32),
    FitContentPercent(f32),
    Auto,
    Fraction(f32),
    VMin(f32),
    VMax(f32),
    Vh(f32),
    Vw(f32),
}
```

---

## Struct EntityMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.EntityMut.html

**Contents:**
- Struct EntityMut Copy item path
- §Examples
- Implementations§
  - impl<'w> EntityMut<'w>
    - pub fn reborrow(&mut self) -> EntityMut<'_>
    - pub fn into_readonly(self) -> EntityRef<'w>
    - pub fn as_readonly(&self) -> EntityRef<'_>
    - pub fn id(&self) -> Entity
    - pub fn location(&self) -> EntityLocation
    - pub fn archetype(&self) -> &Archetype

Provides mutable access to a single entity and all of its components.

Contrast with EntityWorldMut, which allows adding and removing components, despawning the entity, and provides mutable access to the entire world. Because of this, EntityWorldMut cannot coexist with any other world accesses.

Disjoint mutable access.

Returns a new instance with a shorter lifetime. This is useful if you have &mut EntityMut, but you need EntityMut.

Consumes self and returns read-only access to all of the entity’s components, with the world 'w lifetime.

Gets read-only access to all of the entity’s components.

Returns the ID of the current entity.

Gets metadata indicating the location where the current entity is stored.

Returns the archetype that the current entity belongs to.

Returns true if the current entity has a component of type T. Otherwise, this returns false.

If you do not know the concrete type of a component, consider using Self::contains_id or Self::contains_type_id.

Returns true if the current entity has a component identified by component_id. Otherwise, this returns false.

Returns true if the current entity has a component with the type identified by type_id. Otherwise, this returns false.

Gets access to the component of type T for the current entity. Returns None if the entity does not have a component of type T.

Returns read-only components for the current entity that match the query Q.

If the entity does not have the components required by the query Q.

Returns read-only components for the current entity that match the query Q, or None if the entity does not have the components required by the query Q.

Returns components for the current entity that match the query Q, or None if the entity does not have the components required by the query Q.

It is the caller’s responsibility to ensure that the QueryData does not provide aliasing mutable references to the same component.

Consumes self and returns components for the current entity that match the query Q for the world lifetime 'w, or None if the entity does not have the components required by the query Q.

It is the caller’s responsibility to ensure that the QueryData does not provide aliasing mutable references to the same component.

Consumes self and gets access to the component of type T with the world 'w lifetime for the current entity.

Returns None if the entity does not have a component of type T.

Gets access to the component of type T for the current entity, including change detection

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct EntityMut<'w> { /* private fields */ }
```

Example 2 (unknown):
```unknown
fn disjoint_system(
    query1: Query<EntityMut, With<A>>,
    query2: Query<EntityMut, Without<A>>,
) {
    // ...
}
```

Example 3 (javascript):
```javascript
#[derive(Component)]
struct X(usize);
#[derive(Component)]
struct Y(usize);

let mut entity = world.spawn((X(0), Y(0))).into_mutable();
// Get mutable access to two components at once
// SAFETY: X and Y are different components
let (mut x, mut y) =
    unsafe { entity.get_components_mut_unchecked::<(&mut X, &mut Y)>() }.unwrap();
*x = X(1);
*y = Y(1);
// This would trigger undefined behavior, as the `&mut X`s would alias:
// entity.get_components_mut_unchecked::<(&mut X, &mut X)>();
```

Example 4 (javascript):
```javascript
#[derive(Component)]
struct X(usize);
#[derive(Component)]
struct Y(usize);

let mut entity = world.spawn((X(0), Y(0))).into_mutable();
// Get mutable access to two components at once
// SAFETY: X and Y are different components
let (mut x, mut y) =
    unsafe { entity.into_components_mut_unchecked::<(&mut X, &mut Y)>() }.unwrap();
*x = X(1);
*y = Y(1);
// This would trigger undefined behavior, as the `&mut X`s would alias:
// entity.into_components_mut_unchecked::<(&mut X, &mut X)>();
```

---

## Struct ImageNode Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ImageNode.html

**Contents:**
- Struct ImageNode Copy item path
- Fields§
- Implementations§
  - impl ImageNode
    - pub fn new(texture: Handle<Image>) -> ImageNode
      - Examples found in repository?
    - pub fn solid_color(color: Color) -> ImageNode
    - pub fn from_atlas_image(image: Handle<Image>, atlas: TextureAtlas) -> ImageNode
      - Examples found in repository?
    - pub const fn with_color(self, color: Color) -> ImageNode

A UI Node that renders an image.

The tint color used to draw the image.

This is multiplied by the color of each pixel in the image. The field value defaults to solid white, which will pass the image through unmodified.

Handle to the texture.

This defaults to a TRANSPARENT_IMAGE_HANDLE, which points to a fully transparent 1x1 texture.

The (optional) texture atlas used to render the image.

Whether the image should be flipped along its x-axis.

Whether the image should be flipped along its y-axis.

An optional rectangle representing the region of the image to render, instead of rendering the full image. This is an easy one-off alternative to using a TextureAtlas.

When used with a TextureAtlas, the rect is offset by the atlas’s minimal (top-left) corner position.

Controls how the image is altered to fit within the layout and how the layout algorithm determines the space to allocate for the image.

Create a new ImageNode with the given texture.

Create a solid color ImageNode.

This is primarily useful for debugging / mocking the extents of your image.

Create a ImageNode from an image, with an associated texture atlas

Flip the image along its x-axis

Flip the image along its y-axis

Required Components: Node, ImageNodeSize, ContentSize.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

A transparent 1x1 image with a solid white tint.

This will be invisible by default. To set this to a visible image, you need to set the texture field to a valid image handle, or use Handle<Image>’s default 1x1 solid white texture (as is done in ImageNode::solid_color).

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ImageNode {
    pub color: Color,
    pub image: Handle<Image>,
    pub texture_atlas: Option<TextureAtlas>,
    pub flip_x: bool,
    pub flip_y: bool,
    pub rect: Option<Rect>,
    pub image_mode: NodeImageMode,
}
```

Example 2 (javascript):
```javascript
82    pub fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
83        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Image)));
84        commands.spawn((
85            ImageNode::new(asset_server.load("branding/bevy_logo_dark.png")),
86            DespawnOnExit(super::Scene::Image),
87        ));
88    }
89}
90
91mod text {
92    use bevy::{color::palettes::css::*, prelude::*};
93
94    pub fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
95        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Text)));
96        commands.spawn((
97            T
...
```

Example 3 (unknown):
```unknown
135fn spawn_image(
136    parent: &mut ChildSpawnerCommands,
137    asset_server: &Res<AssetServer>,
138    update_transform: impl UpdateTransform + Component,
139) {
140    spawn_container(parent, update_transform, |parent| {
141        parent.spawn((
142            ImageNode::new(asset_server.load("branding/bevy_logo_dark_big.png")),
143            Node {
144                height: px(100),
145                position_type: PositionType::Absolute,
146                top: px(-50),
147                left: px(-200),
148                ..default()
149            },
150        ));
151    });
152
...
```

Example 4 (javascript):
```javascript
38fn atlas_render_system(
39    mut commands: Commands,
40    mut state: ResMut<State>,
41    font_atlas_sets: Res<FontAtlasSets>,
42    images: Res<Assets<Image>>,
43) {
44    if let Some(set) = font_atlas_sets.get(&state.handle)
45        && let Some((_size, font_atlases)) = set.iter().next()
46    {
47        let x_offset = state.atlas_count as f32;
48        if state.atlas_count == font_atlases.len() as u32 {
49            return;
50        }
51        let font_atlas = &font_atlases[state.atlas_count as usize];
52        let image = images.get(&font_atlas.texture).unwrap();
53        state
...
```

---

## Struct CircularInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CircularInOutCurve.html

**Contents:**
- Struct CircularInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for CircularInOutCurve
    - fn clone(&self) -> CircularInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for CircularInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as CircularIn for t < 0.5 and as CircularOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CircularInOutCurve;
```

---

## Struct MessageMutator Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.MessageMutator.html

**Contents:**
- Struct MessageMutator Copy item path
- §Usage
- §Concurrency
- §Clearing, Reading, and Peeking
- Implementations§
  - impl<'w, 's, E> MessageMutator<'w, 's, E>where E: Message,
    - pub fn read(&mut self) -> MessageMutIterator<'_, E> ⓘ
      - Examples found in repository?
    - pub fn read_with_id(&mut self) -> MessageMutIteratorWithId<'_, E> ⓘ
    - pub fn par_read(&mut self) -> MessageMutParIter<'_, E>

Mutably reads messages of type T keeping track of which messages have already been read by each system allowing multiple systems to read the same messages. Ideal for chains of systems that all want to modify the same messages.

MessageMutators are usually declared as a SystemParam.

Multiple systems with MessageMutator<T> of the same message type can not run concurrently. They also can not be executed in parallel with MessageReader or MessageWriter.

Messages are stored in a double buffered queue that switches each frame. This switch also clears the previous frame’s messages. Messages should be read each frame otherwise they may be lost. For manual control over this behavior, see Messages.

Most of the time systems will want to use MessageMutator::read(). This function creates an iterator over all messages that haven’t been read yet by this system, marking the message as read in the process.

Iterates over the messages this MessageMutator has not seen yet. This updates the MessageMutator’s message counter, which means subsequent message reads will not include messages that happened before now.

Like read, except also returning the MessageId of the messages.

Returns a parallel iterator over the messages this MessageMutator has not seen yet. See also for_each.

Determines the number of messages available to be read from this MessageMutator without consuming any.

Returns true if there are no messages available to read.

The following example shows a useful pattern where some behavior is triggered if new messages are available. MessageMutator::clear() is used so the same messages don’t re-trigger the behavior the next time the system runs.

Consumes all available messages.

This means these messages will not appear in calls to MessageMutator::read() or MessageMutator::read_with_id() and MessageMutator::is_empty() will return true.

For usage, see MessageMutator::is_empty().

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct MessageMutator<'w, 's, E>where
    E: Message,{ /* private fields */ }
```

Example 2 (unknown):
```unknown
#[derive(Message, Debug)]
pub struct MyMessage(pub u32); // Custom message type.
fn my_system(mut reader: MessageMutator<MyMessage>) {
    for message in reader.read() {
        message.0 += 1;
        println!("received message: {:?}", message);
    }
}
```

Example 3 (unknown):
```unknown
57fn apply_armor_to_damage(
58    mut dmg_messages: MessageMutator<DealDamage>,
59    mut armor_messages: MessageWriter<ArmorBlockedDamage>,
60) {
61    for message in dmg_messages.read() {
62        message.amount -= 1;
63        if message.amount <= 0 {
64            // Zero-sized messages can also be sent with 'send'
65            armor_messages.write(ArmorBlockedDamage);
66        }
67    }
68}
```

Example 4 (javascript):
```javascript
#[derive(Message)]
struct MyMessage {
    value: usize,
}

#[derive(Resource, Default)]
struct Counter(AtomicUsize);

// setup
let mut world = World::new();
world.init_resource::<Messages<MyMessage>>();
world.insert_resource(Counter::default());

let mut schedule = Schedule::default();
schedule.add_systems(|mut messages: MessageMutator<MyMessage>, counter: Res<Counter>| {
    messages.par_read().for_each(|MyMessage { value }| {
        counter.0.fetch_add(*value, Ordering::Relaxed);
    });
});
for value in 0..100 {
    world.write_message(MyMessage { value });
}
schedule.run(&mut world);
let 
...
```

---

## Struct NameOrEntity Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.NameOrEntity.html

**Contents:**
- Struct NameOrEntity Copy item path
- §Implementation
- Fields§
- Trait Implementations§
  - impl QueryData for NameOrEntity
    - unsafe fn fetch<'__w, '__s>( _state: &'__s <NameOrEntity as WorldQuery>::State, _fetch: &mut <NameOrEntity as WorldQuery>::Fetch<'__w>, _entity: Entity, _table_row: TableRow, ) -> <NameOrEntity as QueryData>::Item<'__w, '__s>
    - const IS_READ_ONLY: bool = true
    - type ReadOnly = NameOrEntity
    - type Item<'__w, '__s> = NameOrEntityItem<'__w, '__s>
    - fn shrink<'__wlong, '__wshort, '__s>( item: <NameOrEntity as QueryData>::Item<'__wlong, '__s>, ) -> <NameOrEntity as QueryData>::Item<'__wshort, '__s>where '__wlong: '__wshort,

Convenient query for giving a human friendly name to an entity.

The Display impl for NameOrEntity returns the Name where there is one or {index}v{generation} for entities without one.

A Name that the entity might have that is displayed if available.

The unique identifier of the entity as a fallback.

SAFETY: we assert fields are readonly below

SAFETY: we call fetch for each member that implements Fetch.

SAFETY: we call set_archetype for each member that implements Fetch

SAFETY: we call set_table for each member that implements Fetch

SAFETY: we assert fields are readonly below

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct NameOrEntity {
    pub name: Option<&'static Name>,
    pub entity: Entity,
}
```

Example 2 (unknown):
```unknown
fn increment_score(mut scores: Query<(NameOrEntity, &mut Score)>) {
    for (name, mut score) in &mut scores {
        score.0 += 1.0;
        if score.0.is_nan() {
            log::error!("Score for {name} is invalid");
        }
    }
}
```

---

## Derive Macro SystemSet Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.SystemSet.html

**Contents:**
- Derive Macro SystemSet Copy item path

Derive macro generating an impl of the trait SystemSet.

This does not work for unions.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(SystemSet)]
```

---

## Struct String Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.String.html

**Contents:**
- Struct String Copy item path
- §Examples
- §UTF-8
- §Deref
- §Representation
- Implementations§
  - impl String
    - pub const fn new() -> String
      - §Examples
    - pub fn with_capacity(capacity: usize) -> String

A UTF-8–encoded, growable string.

String is the most common string type. It has ownership over the contents of the string, stored in a heap-allocated buffer (see Representation). It is closely related to its borrowed counterpart, the primitive str.

You can create a String from a literal string with String::from:

You can append a char to a String with the push method, and append a &str with the push_str method:

If you have a vector of UTF-8 bytes, you can create a String from it with the from_utf8 method:

Strings are always valid UTF-8. If you need a non-UTF-8 string, consider OsString. It is similar, but without the UTF-8 constraint. Because UTF-8 is a variable width encoding, Strings are typically smaller than an array of the same chars:

This raises interesting questions as to how s[i] should work. What should i be here? Several options include byte indices and char indices but, because of UTF-8 encoding, only byte indices would provide constant time indexing. Getting the ith char, for example, is available using chars:

Next, what should s[i] return? Because indexing returns a reference to underlying data it could be &u8, &[u8], or something similar. Since we’re only providing one index, &u8 makes the most sense but that might not be what the user expects and can be explicitly achieved with as_bytes():

Due to these ambiguities/restrictions, indexing with a usize is simply forbidden:

It is more clear, however, how &s[i..j] should work (that is, indexing with a range). It should accept byte indices (to be constant-time) and return a &str which is UTF-8 encoded. This is also called “string slicing”. Note this will panic if the byte indices provided are not character boundaries - see is_char_boundary for more details. See the implementations for SliceIndex<str> for more details on string slicing. For a non-panicking version of string slicing, see get.

The bytes and chars methods return iterators over the bytes and codepoints of the string, respectively. To iterate over codepoints along with byte indices, use char_indices.

String implements Deref<Target = str>, and so inherits all of str’s methods. In addition, this means that you can pass a String to a function which takes a &str by using an ampersand (&):

This will create a &str from the String and pass it in. This conversion is very inexpensive, and so generally, functions will accept &strs as arguments unless they need a String for some specific reason.

In certain cases Rust doesn’t have enoug

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct String { /* private fields */ }
```

Example 2 (javascript):
```javascript
let hello = String::from("Hello, world!");
```

Example 3 (javascript):
```javascript
let mut hello = String::from("Hello, ");

hello.push('w');
hello.push_str("orld!");
```

Example 4 (javascript):
```javascript
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("💖", sparkle_heart);
```

---

## Trait Resource Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Resource.html

**Contents:**
- Trait Resource Copy item path
- §Examples
- §!Sync Resources
- Implementors§
  - impl Resource for ScreenSpaceTransmissionQualitywhere ScreenSpaceTransmissionQuality: Send + Sync + 'static,
  - impl Resource for DebugPickingModewhere DebugPickingMode: Send + Sync + 'static,
  - impl Resource for MeshBindGroupswhere MeshBindGroups: Send + Sync + 'static,
  - impl Resource for RenderMeshInstanceswhere RenderMeshInstances: Send + Sync + 'static,
  - impl Resource for TimeUpdateStrategywhere TimeUpdateStrategy: Send + Sync + 'static,
  - impl Resource for AccessibilityRequestedwhere AccessibilityRequested: Send + Sync + 'static,

A type that can be inserted into a World as a singleton.

You can access resource data in systems using the Res and ResMut system parameters

Only one resource of each type can be stored in a World at any given time.

A !Sync type cannot implement Resource. However, it is possible to wrap a Send but not Sync type in SyncCell or the currently unstable Exclusive to make it Sync. This forces only having mutable access (&mut T only, never &T), but makes it safe to reference across multiple threads.

This will fail to compile since RefCell is !Sync.

This will compile since the RefCell is wrapped with SyncCell.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Resource:
    Send
    + Sync
    + 'static { }
```

Example 2 (unknown):
```unknown
#[derive(Resource)]
struct MyResource { value: u32 }

world.insert_resource(MyResource { value: 42 });

fn read_resource_system(resource: Res<MyResource>) {
    assert_eq!(resource.value, 42);
}

fn write_resource_system(mut resource: ResMut<MyResource>) {
    assert_eq!(resource.value, 42);
    resource.value = 0;
    assert_eq!(resource.value, 0);
}
```

Example 3 (unknown):
```unknown
#[derive(Resource)]
struct NotSync {
   counter: RefCell<usize>,
}
```

Example 4 (unknown):
```unknown
use bevy_platform::cell::SyncCell;

#[derive(Resource)]
struct ActuallySync {
   counter: SyncCell<RefCell<usize>>,
}
```

---

## Struct GamepadSettings Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.GamepadSettings.html

**Contents:**
- Struct GamepadSettings Copy item path
  - §Usage
  - §Note
- Fields§
- Implementations§
  - impl GamepadSettings
    - pub fn get_button_settings(&self, button: GamepadButton) -> &ButtonSettings
      - §Examples
    - pub fn get_axis_settings(&self, axis: GamepadAxis) -> &AxisSettings
      - §Examples

Gamepad settings component.

It is used to create a bevy component that stores the settings of GamepadButton and GamepadAxis in Gamepad. If no user defined ButtonSettings, AxisSettings, or ButtonAxisSettings are defined, the default settings of each are used as a fallback accordingly.

The GamepadSettings are used to determine when raw gamepad events should register. Events that don’t meet the change thresholds defined in GamepadSettings will not register. To modify these settings, mutate the corresponding component.

The default button settings.

The default axis settings.

The default button axis settings.

The user defined button settings.

The user defined axis settings.

The user defined button axis settings.

Returns the ButtonSettings of the GamepadButton.

If no user defined ButtonSettings are specified the default ButtonSettings get returned.

Returns the AxisSettings of the GamepadAxis.

If no user defined AxisSettings are specified the default AxisSettings get returned.

Returns the ButtonAxisSettings of the GamepadButton.

If no user defined ButtonAxisSettings are specified the default ButtonAxisSettings get returned.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct GamepadSettings {
    pub default_button_settings: ButtonSettings,
    pub default_axis_settings: AxisSettings,
    pub default_button_axis_settings: ButtonAxisSettings,
    pub button_settings: HashMap<GamepadButton, ButtonSettings>,
    pub axis_settings: HashMap<GamepadAxis, AxisSettings>,
    pub button_axis_settings: HashMap<GamepadButton, ButtonAxisSettings>,
}
```

Example 2 (javascript):
```javascript
let button_settings = settings.get_button_settings(GamepadButton::South);
```

Example 3 (javascript):
```javascript
let axis_settings = settings.get_axis_settings(GamepadAxis::LeftStickX);
```

Example 4 (javascript):
```javascript
let button_axis_settings = settings.get_button_axis_settings(GamepadButton::South);
```

---

## Struct Update Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Update.html

**Contents:**
- Struct Update Copy item path
- Trait Implementations§
  - impl Clone for Update
    - fn clone(&self) -> Update
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Update
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Default for Update
    - fn default() -> Update
  - impl Hash for Update

The schedule that contains any app logic that must run once per render frame. For most gameplay logic, consider using FixedUpdate instead.

Examples of systems that should run once per render frame include (but are not limited to):

See the FixedUpdate schedule for examples of systems that should not use this schedule. See the Main schedule for some details about how schedules are run.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Update;
```

---

## Macro format Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.format.html

**Contents:**
- Macro format Copy item path
- §Panics
- §Examples

Creates a String using interpolation of runtime expressions.

The first argument format! receives is a format string. This must be a string literal. The power of the formatting string is in the {}s contained. Additional parameters passed to format! replace the {}s within the formatting string in the order given unless named or positional parameters are used.

See the formatting syntax documentation in std::fmt for details.

A common use for format! is concatenation and interpolation of strings. The same convention is used with print! and write! macros, depending on the intended destination of the string; all these macros internally use format_args!.

To convert a single value to a string, use the to_string method. This will use the Display formatting trait.

To concatenate literals into a &'static str, use the concat! macro.

format! panics if a formatting trait implementation returns an error. This indicates an incorrect implementation since fmt::Write for String never returns an error itself.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! format {
    ($($arg:tt)*) => { ... };
}
```

Example 2 (javascript):
```javascript
format!("test");                             // => "test"
format!("hello {}", "world!");               // => "hello world!"
format!("x = {}, y = {val}", 10, val = 30);  // => "x = 10, y = 30"
let (x, y) = (1, 2);
format!("{x} + {y} = 3");                    // => "1 + 2 = 3"
```

---

## Struct CubicHermite Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicHermite.html

**Contents:**
- Struct CubicHermite Copy item path
    - §Interpolation
    - §Tangency
    - §Continuity
    - §Parametrization
    - §Usage
- Fields§
- Implementations§
  - impl<P> CubicHermite<P>where P: VectorSpace,
    - pub fn new( control_points: impl IntoIterator<Item = P>, tangents: impl IntoIterator<Item = P>, ) -> CubicHermite<P>

A spline interpolated continuously between the nearest two control points, with the position and velocity of the curve specified at both control points. This curve passes through all control points, with the specified velocity which includes direction and parametric speed.

Useful for smooth interpolation when you know the position and velocity at two points in time, such as network prediction.

The curve passes through every control point.

Tangents are explicitly defined at each control point.

The curve is at minimum C1 continuous, meaning that it has no holes or jumps and the tangent vector also has no sudden jumps.

The first segment of the curve connects the first two control points, the second connects the second and third, and so on. This remains true when a cyclic curve is formed with to_curve_cyclic, in which case the final curve segment connects the last control point to the first.

The control points of the Hermite curve.

Create a new Hermite curve from sets of control points.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicHermite<P>where
    P: VectorSpace,{
    pub control_points: Vec<(P, P)>,
}
```

Example 2 (javascript):
```javascript
let points = [
    vec2(-1.0, -20.0),
    vec2(3.0, 2.0),
    vec2(5.0, 3.0),
    vec2(9.0, 8.0),
];
let tangents = [
    vec2(0.0, 1.0),
    vec2(0.0, 1.0),
    vec2(0.0, 1.0),
    vec2(0.0, 1.0),
];
let hermite = CubicHermite::new(points, tangents).to_curve().unwrap();
let positions: Vec<_> = hermite.iter_positions(100).collect();
```

Example 3 (javascript):
```javascript
202fn form_curve(
203    control_points: &ControlPoints,
204    spline_mode: SplineMode,
205    cycling_mode: CyclingMode,
206) -> Curve {
207    let (points, tangents): (Vec<_>, Vec<_>) =
208        control_points.points_and_tangents.iter().copied().unzip();
209
210    match spline_mode {
211        SplineMode::Hermite => {
212            let spline = CubicHermite::new(points, tangents);
213            Curve(match cycling_mode {
214                CyclingMode::NotCyclic => spline.to_curve().ok(),
215                CyclingMode::Cyclic => spline.to_curve_cyclic().ok(),
216            })
217   
...
```

---

## Struct Text2d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Text2d.html

**Contents:**
- Struct Text2d Copy item path
- Tuple Fields§
- Implementations§
  - impl Text2d
    - pub fn new(text: impl Into<String>) -> Text2d
      - Examples found in repository?
- Methods from Deref<Target = String>§
    - pub fn as_str(&self) -> &str
      - §Examples
    - pub fn as_mut_str(&mut self) -> &mut str

The top-level 2D text component.

Adding Text2d to an entity will pull in required components for setting up 2d text. Example usage.

The string in this component is the first ‘text span’ in a hierarchy of text spans that are collected into a ComputedTextBlock. See TextSpan for the component used by children of entities with Text2d.

With Text2d the justify field of TextLayout only affects the internal alignment of a block of text and not its relative position, which is controlled by the Anchor component. This means that for a block of text consisting of only one line that doesn’t wrap, the justify field will have no effect.

Makes a new 2d text component.

Extracts a string slice containing the entire String.

Converts a String into a mutable string slice.

Appends a given string slice onto the end of this String.

Copies elements from src range to the end of the string.

Panics if the range has start_bound > end_bound, or, if the range is bounded on either end and does not lie on a char boundary.

Returns this String’s capacity, in bytes.

Reserves capacity for at least additional bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient.

Panics if the new capacity overflows usize.

This might not actually increase the capacity:

Reserves the minimum capacity for at least additional bytes more than the current length. Unlike reserve, this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling reserve_exact, capacity will be greater than or equal to self.len() + additional. Does nothing if the capacity is already sufficient.

Panics if the new capacity overflows usize.

This might not actually increase the capacity:

Tries to reserve capacity for at least additional bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling try_reserve, capacity will be greater than or equal to self.len() + additional if it returns Ok(()). Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.

If the capacity overflows, or the allocator reports a failure, then an error is returned.

Tries to reserve the minimum capacity for at least additional bytes more than the current length. Unlike try_reserve, this will not d

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct Text2d(pub String);
```

Example 2 (unknown):
```unknown
// Basic usage.
world.spawn(Text2d::new("hello world!"));

// With non-default style.
world.spawn((
    Text2d::new("hello world!"),
    TextFont {
        font: font_handle.clone().into(),
        font_size: 60.0,
        ..Default::default()
    },
    TextColor(BLUE.into()),
));

// With text justification.
world.spawn((
    Text2d::new("hello world\nand bevy!"),
    TextLayout::new_with_justify(Justify::Center)
));

// With spans
world.spawn(Text2d::new("hello ")).with_children(|parent| {
    parent.spawn(TextSpan::new("world"));
    parent.spawn((TextSpan::new("!"), TextColor(BLUE.into())
...
```

Example 3 (unknown):
```unknown
53fn spawn_text(mut commands: Commands, mut reader: MessageReader<StreamMessage>) {
54    for (per_frame, message) in reader.read().enumerate() {
55        commands.spawn((
56            Text2d::new(message.0.to_string()),
57            TextLayout::new_with_justify(Justify::Center),
58            Transform::from_xyz(per_frame as f32 * 100.0, 300.0, 0.0),
59        ));
60    }
61}
```

Example 4 (unknown):
```unknown
273fn create_label(
274    commands: &mut Commands,
275    translation: (f32, f32, f32),
276    text: &str,
277    text_style: TextFont,
278) {
279    commands.spawn((
280        Text2d::new(text),
281        text_style,
282        TextLayout::new_with_justify(Justify::Center),
283        Transform {
284            translation: Vec3::new(translation.0, translation.1, translation.2),
285            ..default()
286        },
287    ));
288}
```

---

## Struct BackInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BackInCurve.html

**Contents:**
- Struct BackInCurve Copy item path
- Trait Implementations§
  - impl Clone for BackInCurve
    - fn clone(&self) -> BackInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for BackInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = 2.70158 * t³ - 1.70158 * t²

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BackInCurve;
```

---

## Derive Macro Reflect Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Reflect.html

**Contents:**
- Derive Macro Reflect Copy item path
- §Container Attributes
  - §#[reflect(Ident)]
    - §Default Registrations
    - §Special Identifiers
  - §#[reflect(opaque)]
  - §#[reflect(from_reflect = false)]
  - §#[reflect(type_path = false)]
  - §#[reflect(no_field_bounds)]
    - §Example

The main derive macro used by bevy_reflect for deriving its Reflect trait.

This macro can be used on all structs and enums (unions are not supported). It will automatically generate implementations for Reflect, Typed, GetTypeRegistration, and FromReflect. And, depending on the item’s structure, will either implement Struct, TupleStruct, or Enum.

See the FromReflect derive macro for more information on how to customize the FromReflect implementation.

This macro comes with some helper attributes that can be added to the container item in order to provide additional functionality or alter the generated implementations.

In addition to those listed, this macro can also use the attributes for TypePath derives.

The #[reflect(Ident)] attribute is used to add type data registrations to the GetTypeRegistration implementation corresponding to the given identifier, prepended by Reflect.

For example, #[reflect(Foo, Bar)] would add two registrations: one for ReflectFoo and another for ReflectBar. This assumes these types are indeed in-scope wherever this macro is called.

This is often used with traits that have been marked by the #[reflect_trait] macro in order to register the type’s implementation of that trait.

The following types are automatically registered when deriving Reflect:

There are a few “special” identifiers that work a bit differently:

The #[reflect(opaque)] attribute denotes that the item should implement Reflect as an opaque type, hiding its structure and fields from the reflection API. This means that it will forgo implementing Struct, TupleStruct, or Enum.

Furthermore, it requires that the type implements [Clone]. If planning to serialize this type using the reflection serializers, then the Serialize and Deserialize traits will need to be implemented and registered as well.

This attribute will opt-out of the default FromReflect implementation.

This is useful for when a type can’t or shouldn’t implement FromReflect, or if a manual implementation is desired.

Note that in the latter case, ReflectFromReflect will no longer be automatically registered.

This attribute will opt-out of the default TypePath implementation.

This is useful for when a type can’t or shouldn’t implement TypePath, or if a manual implementation is desired.

This attribute will opt-out of the default trait bounds added to all field types for the generated reflection trait impls.

Normally, all fields will have the bounds TypePath, and either FromReflect or Reflect depen

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Reflect)]
{
    // Attributes available to this derive:
    #[reflect]
    #[type_path]
    #[type_name]
}
```

Example 2 (unknown):
```unknown
#[derive(Reflect)] // ERROR: overflow evaluating the requirement `Foo: FromReflect`
struct Foo {
  foo: Vec<Foo>,
}

// Generates a where clause like:
// impl bevy_reflect::Reflect for Foo
// where
//   Foo: Any + Send + Sync,
//   Vec<Foo>: FromReflect + TypePath + MaybeTyped + RegisterForReflection,
```

Example 3 (unknown):
```unknown
#[derive(Reflect)]
#[reflect(no_field_bounds)]
struct Foo {
  foo: Vec<Foo>,
}

// Generates a where clause like:
// impl bevy_reflect::Reflect for Foo
// where
//   Self: Any + Send + Sync,
```

Example 4 (unknown):
```unknown
trait Trait {
  type Assoc;
}

#[derive(Reflect)]
#[reflect(where T::Assoc: List)]
struct Foo<T: Trait> where T::Assoc: Default {
  value: T::Assoc,
}

// Generates a where clause like:
//
// impl<T: Trait> bevy_reflect::Reflect for Foo<T>
// where
//   Foo<T>: Any + Send + Sync,
//   T::Assoc: Default,
//   T: TypePath,
//   T::Assoc: FromReflect + TypePath + MaybeTyped + RegisterForReflection,
//   T::Assoc: List,
// {/* ... */}
```

---

## Trait Animatable Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Animatable.html

**Contents:**
- Trait Animatable Copy item path
- Required Methods§
    - fn interpolate(a: &Self, b: &Self, time: f32) -> Self
    - fn blend(inputs: impl Iterator<Item = BlendInput<Self>>) -> Self
- Dyn Compatibility§
- Implementations on Foreign Types§
  - impl Animatable for bool
    - fn interpolate(a: &bool, b: &bool, t: f32) -> bool
    - fn blend(inputs: impl Iterator<Item = BlendInput<bool>>) -> bool
  - impl Animatable for f32

An animatable value type.

Interpolates between a and b with an interpolation factor of time.

The time parameter here may not be clamped to the range [0.0, 1.0].

Blends one or more values together.

Implementors should return a default value when no inputs are provided here.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait Animatable:
    Sized
    + Reflect
    + Send
    + Sync
    + 'static {
    // Required methods
    fn interpolate(a: &Self, b: &Self, time: f32) -> Self;
    fn blend(inputs: impl Iterator<Item = BlendInput<Self>>) -> Self;
}
```

---

## Struct ConicalFrustum Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ConicalFrustum.html

**Contents:**
- Struct ConicalFrustum Copy item path
- Fields§
- Trait Implementations§
  - impl Bounded3d for ConicalFrustum
    - fn aabb_3d(&self, isometry: impl Into<Isometry3d>) -> Aabb3d
    - fn bounding_sphere(&self, isometry: impl Into<Isometry3d>) -> BoundingSphere
  - impl Clone for ConicalFrustum
    - fn clone(&self) -> ConicalFrustum
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ConicalFrustum

A conical frustum primitive. A conical frustum can be created by slicing off a section of a cone.

The radius of the top of the frustum

The radius of the base of the frustum

The height of the frustum

Returns the default ConicalFrustum with a top radius of 0.25, bottom radius of 0.5, and a height of 0.5.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ConicalFrustum {
    pub radius_top: f32,
    pub radius_bottom: f32,
    pub height: f32,
}
```

---

## Enum WindingOrder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.WindingOrder.html

**Contents:**
- Enum WindingOrder Copy item path
- Variants§
  - Clockwise
  - CounterClockwise
  - Invalid
- Trait Implementations§
  - impl Clone for WindingOrder
    - fn clone(&self) -> WindingOrder
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for WindingOrder

The winding order for a set of points

A clockwise winding order

A counterclockwise winding order

An invalid winding order indicating that it could not be computed reliably. This often happens in degenerate cases where the points lie on the same line

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum WindingOrder {
    Clockwise,
    CounterClockwise,
    Invalid,
}
```

---

## Trait Primitive3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Primitive3d.html

**Contents:**
- Trait Primitive3d Copy item path
- Implementors§
  - impl Primitive3d for Capsule3d
  - impl Primitive3d for Cone
  - impl Primitive3d for ConicalFrustum
  - impl Primitive3d for Cuboid
  - impl Primitive3d for Cylinder
  - impl Primitive3d for Dir3
  - impl Primitive3d for Dir3A
  - impl Primitive3d for InfinitePlane3d

A marker trait for 3D primitives

**Examples:**

Example 1 (unknown):
```unknown
pub trait Primitive3d { }
```

---

## Struct PointLight Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.PointLight.html

**Contents:**
- Struct PointLight Copy item path
  - §Shadows
- Fields§
- Implementations§
  - impl PointLight
    - pub const DEFAULT_SHADOW_DEPTH_BIAS: f32 = 0.0799999982f32
    - pub const DEFAULT_SHADOW_NORMAL_BIAS: f32 = 0.600000024f32
    - pub const DEFAULT_SHADOW_MAP_NEAR_Z: f32 = 0.100000001f32
- Trait Implementations§
  - impl Clone for PointLight

A light that emits light in all directions from a central point.

Real-world values for intensity (luminous power in lumens) based on the electrical power consumption of the type of real-world light are:

To enable shadows, set the shadows_enabled property to true.

To control the resolution of the shadow maps, use the PointLightShadowMap resource.

The color of this light source.

Luminous power in lumens, representing the amount of light emitted by this source in all directions.

Cut-off for the light’s area-of-effect. Fragments outside this range will not be affected by this light at all, so it’s important to tune this together with intensity to prevent hard lighting cut-offs.

Simulates a light source coming from a spherical volume with the given radius.

This affects the size of specular highlights created by this light, as well as the soft shadow penumbra size. Because of this, large values may not produce the intended result – for example, light radius does not affect shadow softness or diffuse lighting.

Whether this light casts shadows.

Whether soft shadows are enabled.

Soft shadows, also known as percentage-closer soft shadows or PCSS, cause shadows to become blurrier (i.e. their penumbra increases in radius) as they extend away from objects. The blurriness of the shadow depends on the PointLight::radius of the light; larger lights result in larger penumbras and therefore blurrier shadows.

Currently, soft shadows are rather noisy if not using the temporal mode. If you enable soft shadows, consider choosing ShadowFilteringMethod::Temporal and enabling temporal antialiasing (TAA) to smooth the noise out over time.

Note that soft shadows are significantly more expensive to render than hard shadows.

Whether this point light contributes diffuse lighting to meshes with lightmaps.

Set this to false if your lightmap baking tool bakes the direct diffuse light from this point light into the lightmaps in order to avoid counting the radiance from this light twice. Note that the specular portion of the light is always considered, because Bevy currently has no means to bake specular light.

By default, this is set to true.

A bias used when sampling shadow maps to avoid “shadow-acne”, or false shadow occlusions that happen as a result of shadow-map fragments not mapping 1:1 to screen-space fragments. Too high of a depth bias can lead to shadows detaching from their casters, or “peter-panning”. This bias can be tuned together with shadow_normal_bias to co

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct PointLight {
    pub color: Color,
    pub intensity: f32,
    pub range: f32,
    pub radius: f32,
    pub shadows_enabled: bool,
    pub soft_shadows_enabled: bool,
    pub affects_lightmapped_mesh_diffuse: bool,
    pub shadow_depth_bias: f32,
    pub shadow_normal_bias: f32,
    pub shadow_map_near_z: f32,
}
```

---

## Type Alias InternedAppLabel Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/type.InternedAppLabel.html

**Contents:**
- Type Alias InternedAppLabel Copy item path
- Aliased Type§
- Tuple Fields§

A shorthand for Interned<dyn AppLabel>.

**Examples:**

Example 1 (unknown):
```unknown
pub type InternedAppLabel = Interned<dyn AppLabel>;
```

Example 2 (unknown):
```unknown
pub struct InternedAppLabel(pub &'static dyn AppLabel);
```

---

## Struct InRef Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.InRef.html

**Contents:**
- Struct InRef Copy item path
- §Examples
- Tuple Fields§
- Trait Implementations§
  - impl<'i, T> Debug for InRef<'i, T>where T: Debug + ?Sized,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<'i, T> Deref for InRef<'i, T>where T: ?Sized,
    - type Target = T
    - fn deref(&self) -> &<InRef<'i, T> as Deref>::Target
  - impl<T> SystemInput for InRef<'_, T>where T: 'static + ?Sized,

A SystemInput type which denotes that a System receives a read-only reference to a value of type T from its caller.

This is similar to In but takes a reference to a value instead of the value itself. See InMut for the mutable version.

See SystemInput to learn more about system inputs in general.

Here is a simple example of a system that logs the passed in message.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct InRef<'i, T>(pub &'i T)
where
    T: ?Sized;
```

Example 2 (javascript):
```javascript
#[derive(Resource, Default)]
struct Log(String);

fn log(InRef(msg): InRef<str>, mut log: ResMut<Log>) {
    writeln!(log.0, "{}", msg).unwrap();
}

let mut world = World::new();
world.init_resource::<Log>();
let mut log_system = IntoSystem::into_system(log);
log_system.initialize(&mut world);

log_system.run("Hello, world!", &mut world);
```

---

## Struct CircularSegment Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CircularSegment.html

**Contents:**
- Struct CircularSegment Copy item path
- Fields§
- Implementations§
  - impl CircularSegment
    - pub const fn new(radius: f32, angle: f32) -> CircularSegment
      - Examples found in repository?
    - pub const fn from_radians(radius: f32, angle: f32) -> CircularSegment
    - pub const fn from_degrees(radius: f32, angle: f32) -> CircularSegment
    - pub const fn from_turns(radius: f32, fraction: f32) -> CircularSegment
      - Examples found in repository?

A primitive representing a circular segment: the area enclosed by the arc of a circle and its chord (the line between its endpoints).

The segment is drawn starting from Vec2::Y, extending equally on either side. To orient the segment differently, apply a rotation. The segment is drawn with the center of its circle at the origin Vec2::ZERO. When positioning a segment, the apothem function may be particularly useful.

Warning: Circular segments with negative angle or radius, or with angle greater than an entire circle, are not officially supported. We recommend normalizing circular segments to have an angle in [0, 2π].

The arc defining the segment

Create a new CircularSegment from a radius, and an angle

Create a new CircularSegment from a radius and an angle in radians.

Create a new CircularSegment from a radius and an angle in degrees.

Create a new CircularSegment from a radius and a number of turns of a circle.

For instance, 0.5 turns is a semicircle.

Get the half-angle of the segment

Get the angle of the segment

Get the radius of the segment

Get the length of the arc defining the segment

Get half the length of the segment’s base, also known as its chord

Get the length of the segment’s base, also known as its chord

Get the midpoint of the segment’s base, also known as its chord

Get the length of the apothem of this segment, which is the signed distance between the segment and the center of its circle

Get the length of the sagitta of this segment, also known as its height

Returns the default CircularSegment with radius 0.5 and covering a third of a circle

Converts this sector into a Mesh using a default CircularSegmentMeshBuilder.

See the documentation of CircularSegmentMeshBuilder for more details.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CircularSegment {
    pub arc: Arc2d,
}
```

Example 2 (javascript):
```javascript
66    pub fn setup(
67        mut commands: Commands,
68        mut meshes: ResMut<Assets<Mesh>>,
69        mut materials: ResMut<Assets<ColorMaterial>>,
70    ) {
71        commands.spawn((Camera2d, DespawnOnExit(super::Scene::Shapes)));
72
73        let shapes = [
74            meshes.add(Circle::new(50.0)),
75            meshes.add(CircularSector::new(50.0, 1.0)),
76            meshes.add(CircularSegment::new(50.0, 1.25)),
77            meshes.add(Ellipse::new(25.0, 50.0)),
78            meshes.add(Annulus::new(25.0, 50.0)),
79            meshes.add(Capsule2d::new(25.0, 50.0)),
80          
...
```

Example 3 (javascript):
```javascript
35fn setup(
36    mut commands: Commands,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    commands.spawn(Camera2d);
41
42    let shapes = [
43        meshes.add(Circle::new(50.0)),
44        meshes.add(CircularSector::new(50.0, 1.0)),
45        meshes.add(CircularSegment::new(50.0, 1.25)),
46        meshes.add(Ellipse::new(25.0, 50.0)),
47        meshes.add(Annulus::new(25.0, 50.0)),
48        meshes.add(Capsule2d::new(25.0, 50.0)),
49        meshes.add(Rhombus::new(75.0, 100.0)),
50        meshes.add(Rectangle::new(50.0, 100.0)),
51     
...
```

Example 4 (javascript):
```javascript
34fn setup(
35    mut commands: Commands,
36    asset_server: Res<AssetServer>,
37    mut meshes: ResMut<Assets<Mesh>>,
38    mut materials: ResMut<Assets<ColorMaterial>>,
39) {
40    let material = materials.add(asset_server.load("branding/icon.png"));
41
42    commands.spawn((
43        Camera2d,
44        Camera {
45            clear_color: ClearColorConfig::Custom(GRAY.into()),
46            ..default()
47        },
48    ));
49
50    const NUM_SLICES: i32 = 8;
51    const SPACING_X: f32 = 100.0;
52    const OFFSET_X: f32 = SPACING_X * (NUM_SLICES - 1) as f32 / 2.0;
53
54    // This draws 
...
```

---

## Function resource_changed Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.resource_changed.html

**Contents:**
- Function resource_changed Copy item path
- §Panics
- §Example

A SystemCondition-satisfying system that returns true if the resource of the given type has been added or mutably dereferenced since the condition was last checked.

Note that simply mutably dereferencing a resource is considered a change (DerefMut). Bevy does not compare resources to their previous values.

The condition will panic if the resource does not exist.

**Examples:**

Example 1 (unknown):
```unknown
pub fn resource_changed<T>(res: Res<'_, T>) -> boolwhere
    T: Resource,
```

Example 2 (unknown):
```unknown
app.add_systems(
    // `resource_changed` will only return true if the
    // given resource was just changed (or added)
    my_system.run_if(
        resource_changed::<Counter>
        // By default detecting changes will also trigger if the resource was
        // just added, this won't work with my example so I will add a second
        // condition to make sure the resource wasn't just added
        .and(not(resource_added::<Counter>))
    ),
);

fn my_system(mut counter: ResMut<Counter>) {
    counter.0 += 1;
}

// `Counter` hasn't been changed so `my_system` won't run
app.run(&mut worl
...
```

---

## Trait CyclicCubicGenerator Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.CyclicCubicGenerator.html

**Contents:**
- Trait CyclicCubicGenerator Copy item path
- Required Associated Types§
    - type Error
- Required Methods§
    - fn to_curve_cyclic(&self) -> Result<CubicCurve<P>, Self::Error>
- Implementors§
  - impl<P> CyclicCubicGenerator<P> for LinearSpline<P>where P: VectorSpace,
    - type Error = InsufficientDataError
  - impl<P> CyclicCubicGenerator<P> for CubicBSpline<P>where P: VectorSpace<Scalar = f32>,
    - type Error = InsufficientDataError

Implement this on cubic splines that can generate a cyclic cubic curve from their spline parameters.

This makes sense only when the control data can be interpreted cyclically.

An error type indicating why construction might fail.

Build a cyclic CubicCurve by computing the interpolation coefficients for each curve segment, treating the control data as cyclic so that the result is a closed curve.

**Examples:**

Example 1 (unknown):
```unknown
pub trait CyclicCubicGenerator<P>where
    P: VectorSpace,{
    type Error;

    // Required method
    fn to_curve_cyclic(&self) -> Result<CubicCurve<P>, Self::Error>;
}
```

---

## Module prelude Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/light/prelude/index.html

**Contents:**
- Module prelude Copy item path
- Structs§

This includes the most common types in this crate, re-exported for your convenience.

---

## Struct SpritePickingPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.SpritePickingPlugin.html

**Contents:**
- Struct SpritePickingPlugin Copy item path
- Trait Implementations§
  - impl Clone for SpritePickingPlugin
    - fn clone(&self) -> SpritePickingPlugin
    - fn clone_from(&mut self, source: &Self)
  - impl Plugin for SpritePickingPlugin
    - fn build(&self, app: &mut App)
    - fn ready(&self, _app: &App) -> bool
    - fn finish(&self, _app: &mut App)
    - fn cleanup(&self, _app: &mut App)

Enables the sprite picking backend, allowing you to click on, hover over and drag sprites.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct SpritePickingPlugin;
```

---

## Type Alias Animation Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/type.Animation.html

**Contents:**
- Type Alias Animation Copy item path
- Aliased Type§

Deprecated alias for AnimationSystems.

**Examples:**

Example 1 (unknown):
```unknown
pub type Animation = AnimationSystems;
```

Example 2 (unknown):
```unknown
pub struct Animation;
```

---

## Struct Insert Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Insert.html

**Contents:**
- Struct Insert Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Insert
    - fn clone(&self) -> Insert
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Insert
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl EntityEvent for Insertwhere Insert: Send + Sync + 'static,
    - fn event_target(&self) -> Entity

Trigger emitted when a component is inserted, regardless of whether or not the entity already had that component. Runs after Add, if it ran. See ComponentHooks::on_insert for more information.

The entity this component was inserted into.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Insert {
    pub entity: Entity,
}
```

---

## Struct RepeatedGridTrack Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.RepeatedGridTrack.html

**Contents:**
- Struct RepeatedGridTrack Copy item path
- Implementations§
  - impl RepeatedGridTrack
    - pub fn px<T>(repetition: impl Into<GridTrackRepetition>, value: f32) -> Twhere T: From<RepeatedGridTrack>,
      - Examples found in repository?
    - pub fn percent<T>(repetition: impl Into<GridTrackRepetition>, value: f32) -> Twhere T: From<RepeatedGridTrack>,
    - pub fn auto<T>(repetition: u16) -> Twhere T: From<RepeatedGridTrack>,
      - Examples found in repository?
    - pub fn fr<T>(repetition: u16, value: f32) -> Twhere T: From<RepeatedGridTrack>,
      - Examples found in repository?

Represents a possibly repeated GridTrack.

The repetition parameter can either be:

Note: that in the common case you want a non-repeating track (repetition count 1), you may use the constructor methods on GridTrack to create a RepeatedGridTrack. i.e. GridTrack::px(10.0) is equivalent to RepeatedGridTrack::px(1, 10.0).

You may only use one auto-repetition per track list. And if your track list contains an auto repetition then all tracks (in and outside of the repetition) must be fixed size (px or percent). Integer repetitions are just shorthand for writing out N tracks longhand and are not subject to the same limitations.

Create a repeating set of grid tracks with a fixed pixel size

Create a repeating set of grid tracks with a percentage size

Create a repeating set of grid tracks with automatic size

Create a repeating set of grid tracks with an fr size. Note that this will give the track a content-based minimum size. Usually you are best off using GridTrack::flex instead which uses a zero minimum size.

Create a repeating set of grid tracks with a minmax(0, Nfr) size.

Create a repeating set of grid tracks with min-content size

Create a repeating set of grid tracks with max-content size

Create a repeating set of fit-content() grid tracks with fixed pixel limit

Create a repeating set of fit-content() grid tracks with percentage limit

Create a repeating set of minmax() grid track

Create a repeating set of grid tracks with the percentage size of the viewport’s smaller dimension

Create a repeating set of grid tracks with the percentage size of the viewport’s larger dimension

Create a repeating set of grid tracks with the percentage size of the viewport’s height dimension

Create a repeating set of grid tracks with the percentage size of the viewport’s width dimension

Create a repetition of a set of tracks

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct RepeatedGridTrack { /* private fields */ }
```

Example 2 (javascript):
```javascript
75fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
76    // Camera
77
78    commands.spawn(Camera2d);
79
80    // Instructions
81
82    let text_font = TextFont::default();
83
84    commands
85        .spawn((
86            Text::new(
87                "Next Overflow Setting (O)\nNext Container Size (S)\nToggle Animation (space)\n\n",
88            ),
89            text_font.clone(),
90            Node {
91                position_type: PositionType::Absolute,
92                top: px(12),
93                left: px(12),
94                ..default()
95            },
96     
...
```

Example 3 (javascript):
```javascript
22fn setup(mut commands: Commands) {
23    let w = 60;
24    let h = 40;
25
26    commands.spawn(Camera2d);
27    commands.insert_resource(UiScale(0.5));
28
29    commands
30        .spawn((
31            Node {
32                width: percent(100),
33                height: percent(100),
34                overflow: Overflow::scroll(),
35                ..Default::default()
36            },
37            ScrollPosition(Vec2::ZERO),
38            ScrollableNode,
39            ScrollStart(Vec2::ZERO),
40        ))
41        .observe(
42            |drag: On<Pointer<Drag>>,
43             ui_sca
...
```

Example 4 (javascript):
```javascript
800    pub fn setup(mut commands: Commands) {
801        let color_stops = vec![
802            ColorStop::new(Color::BLACK, px(5)),
803            ColorStop::new(Color::WHITE, px(5)),
804            ColorStop::new(Color::WHITE, percent(100)),
805            ColorStop::auto(RED),
806        ];
807
808        commands.spawn((Camera2d, DespawnOnExit(super::Scene::RadialGradient)));
809        commands
810            .spawn((
811                Node {
812                    width: percent(100),
813                    height: percent(100),
814                    display: Display::Grid,
815        
...
```

---

## Struct ScheduleRunnerPlugin Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.ScheduleRunnerPlugin.html

**Contents:**
- Struct ScheduleRunnerPlugin Copy item path
- Fields§
- Implementations§
  - impl ScheduleRunnerPlugin
    - pub fn run_once() -> ScheduleRunnerPlugin
      - Examples found in repository?
    - pub fn run_loop(wait_duration: Duration) -> ScheduleRunnerPlugin
      - Examples found in repository?
- Trait Implementations§
  - impl Default for ScheduleRunnerPlugin

Configures an App to run its Schedule according to a given RunMode.

ScheduleRunnerPlugin is included in the MinimalPlugins plugin group.

ScheduleRunnerPlugin is not included in the DefaultPlugins plugin group which assumes that the Schedule will be executed by other means: typically, the winit event loop (see WinitPlugin) executes the schedule making ScheduleRunnerPlugin unnecessary.

Determines whether the Schedule is run once or repeatedly.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ScheduleRunnerPlugin {
    pub run_mode: RunMode,
}
```

Example 2 (unknown):
```unknown
16fn main() {
17    if cfg!(feature = "bevy_window") {
18        println!("This example is running with the bevy_window feature enabled and will not run headless.");
19        println!("Disable the default features and rerun the example to run headless.");
20        println!("To do so, run:");
21        println!();
22        println!("    cargo run --example headless --no-default-features --features bevy_log");
23        return;
24    }
25
26    // This app runs once
27    App::new()
28        .add_plugins(DefaultPlugins.set(ScheduleRunnerPlugin::run_once()))
29        .add_systems(Update, hel
...
```

Example 3 (unknown):
```unknown
16fn main() {
17    if cfg!(feature = "bevy_window") {
18        println!("This example is running with the bevy_window feature enabled and will not run headless.");
19        println!("Disable the default features and rerun the example to run headless.");
20        println!("To do so, run:");
21        println!();
22        println!("    cargo run --example headless --no-default-features --features bevy_log");
23        return;
24    }
25
26    // This app runs once
27    App::new()
28        .add_plugins(DefaultPlugins.set(ScheduleRunnerPlugin::run_once()))
29        .add_systems(Update, hel
...
```

Example 4 (javascript):
```javascript
71fn main() {
72    let config = AppConfig {
73        width: 1920,
74        height: 1080,
75        single_image: true,
76    };
77
78    // setup frame capture
79    App::new()
80        .insert_resource(SceneController::new(
81            config.width,
82            config.height,
83            config.single_image,
84        ))
85        .insert_resource(ClearColor(Color::srgb_u8(0, 0, 0)))
86        .add_plugins(
87            DefaultPlugins
88                .set(ImagePlugin::default_nearest())
89                // Not strictly necessary, as the inclusion of ScheduleRunnerPlugin below
90
...
```

---

## Struct DragEnd Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.DragEnd.html

**Contents:**
- Struct DragEnd Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for DragEnd
    - fn clone(&self) -> DragEnd
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for DragEnd
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for DragEnd
    - type This<'from_arg> = DragEnd

Fires when a pointer is dragging the target entity and a pointer released event is received.

Pointer button pressed, moved, and released to trigger this event.

The vector of drag movement measured from start to final pointer position.

This is stored in screen pixels, not world coordinates. Screen pixels go from top-left to bottom-right, whereas (in 2D) world coordinates go from bottom-left to top-right. Consider using methods on Camera to convert from screen-space to world-space.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct DragEnd {
    pub button: PointerButton,
    pub distance: Vec2,
}
```

---

## Struct ShowAabbGizmo Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ShowAabbGizmo.html

**Contents:**
- Struct ShowAabbGizmo Copy item path
- Fields§
- Trait Implementations§
  - impl Component for ShowAabbGizmowhere ShowAabbGizmo: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior
    - fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>

Add this Component to an entity to draw its Aabb component.

The color of the box.

The default color from the AabbGizmoConfigGroup config is used if None,

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ShowAabbGizmo {
    pub color: Option<Color>,
}
```

---

## Struct ResolvedBorderRadius Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ResolvedBorderRadius.html

**Contents:**
- Struct ResolvedBorderRadius Copy item path
- Fields§
- Implementations§
  - impl ResolvedBorderRadius
    - pub const ZERO: ResolvedBorderRadius
- Trait Implementations§
  - impl Clone for ResolvedBorderRadius
    - fn clone(&self) -> ResolvedBorderRadius
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ResolvedBorderRadius

Represents the resolved border radius values for a UI node.

The values are in physical pixels.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ResolvedBorderRadius {
    pub top_left: f32,
    pub top_right: f32,
    pub bottom_right: f32,
    pub bottom_left: f32,
}
```

---

## Struct Camera3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Camera3d.html

**Contents:**
- Struct Camera3d Copy item path
- Fields§
      - §Notes
- Trait Implementations§
  - impl Clone for Camera3d
    - fn clone(&self) -> Camera3d
    - fn clone_from(&mut self, source: &Self)
  - impl Component for Camera3dwhere Camera3d: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable

A 3D camera component. Enables the main 3D render graph for a Camera.

The camera coordinate space is right-handed X-right, Y-up, Z-back. This means “forward” is -Z.

The depth clear operation to perform for the main 3d pass.

The texture usages for the depth texture created for the main 3d pass.

How many individual steps should be performed in the Transmissive3d pass.

Roughly corresponds to how many “layers of transparency” are rendered for screen space specular transmissive objects. Each step requires making one additional texture copy, so it’s recommended to keep this number to a reasonably low value. Defaults to 1.

The quality of the screen space specular transmission blur effect, applied to whatever’s “behind” transmissive objects when their roughness is greater than 0.0.

Higher qualities are more GPU-intensive.

Note: You can get better-looking results at any quality level by enabling TAA. See: TemporalAntiAliasPlugin

Required Components: Camera, Projection.

A component’s Required Components are inserted whenever it is inserted. Note that this will also insert the required components of the required components, recursively, in depth-first order.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Camera3d {
    pub depth_load_op: Camera3dDepthLoadOp,
    pub depth_texture_usages: Camera3dDepthTextureUsage,
    pub screen_space_specular_transmission_steps: usize,
    pub screen_space_specular_transmission_quality: ScreenSpaceTransmissionQuality,
}
```

---

## Struct InheritedVisibility Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.InheritedVisibility.html

**Contents:**
- Struct InheritedVisibility Copy item path
- Implementations§
  - impl InheritedVisibility
    - pub const HIDDEN: InheritedVisibility
    - pub const VISIBLE: InheritedVisibility
    - pub fn get(self) -> bool
- Trait Implementations§
  - impl Clone for InheritedVisibility
    - fn clone(&self) -> InheritedVisibility
    - fn clone_from(&mut self, source: &Self)

Whether or not an entity is visible in the hierarchy. This will not be accurate until VisibilityPropagate runs in the PostUpdate schedule.

If this is false, then ViewVisibility should also be false.

An entity that is invisible in the hierarchy.

An entity that is visible in the hierarchy.

Returns true if the entity is visible in the hierarchy. Otherwise, returns false.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct InheritedVisibility(/* private fields */);
```

---

## Struct LayoutConfig Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.LayoutConfig.html

**Contents:**
- Struct LayoutConfig Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for LayoutConfig
    - fn clone(&self) -> LayoutConfig
    - fn clone_from(&mut self, source: &Self)
  - impl Component for LayoutConfigwhere LayoutConfig: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

This component can be added to any UI node to modify its layout behavior.

If set to true the coordinates for this node and its descendents will be rounded to the nearest physical pixel. This can help prevent visual artifacts like blurry images or semi-transparent edges that can occur with sub-pixel positioning.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct LayoutConfig {
    pub use_rounding: bool,
}
```

---

## Trait Measured3d Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Measured3d.html

**Contents:**
- Trait Measured3d Copy item path
- Required Methods§
    - fn area(&self) -> f32
    - fn volume(&self) -> f32
- Implementors§
  - impl Measured3d for Capsule3d
  - impl Measured3d for Cone
  - impl Measured3d for Cuboid
  - impl Measured3d for Cylinder
  - impl Measured3d for Sphere

A trait for getting measurements of 3D shapes

Get the surface area of the shape

Get the volume of the shape

**Examples:**

Example 1 (unknown):
```unknown
pub trait Measured3d {
    // Required methods
    fn area(&self) -> f32;
    fn volume(&self) -> f32;
}
```

---

## Enum ValParseError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ValParseError.html

**Contents:**
- Enum ValParseError Copy item path
- Variants§
  - UnitMissing
  - ValueMissing
  - InvalidValue
  - InvalidUnit
- Trait Implementations§
  - impl Debug for ValParseError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for ValParseError

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ValParseError {
    UnitMissing,
    ValueMissing,
    InvalidValue,
    InvalidUnit,
}
```

---

## Trait ValNum Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.ValNum.html

**Contents:**
- Trait ValNum Copy item path
- Required Methods§
    - fn val_num_f32(self) -> f32
- Implementations on Foreign Types§
  - impl ValNum for f32
    - fn val_num_f32(self) -> f32
  - impl ValNum for f64
    - fn val_num_f32(self) -> f32
  - impl ValNum for i8
    - fn val_num_f32(self) -> f32

All the types that should be able to be used in the Val enum should implement this trait.

Instead of just implementing Into<Val> a custom trait is added. This is done in order to prevent having to define a default unit, which could lead to confusion especially for newcomers.

Called by the Val helper functions to convert the implementing type to an f32 that can be used by Val.

**Examples:**

Example 1 (unknown):
```unknown
pub trait ValNum {
    // Required method
    fn val_num_f32(self) -> f32;
}
```

---

## Struct Propagate Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.Propagate.html

**Contents:**
- Struct Propagate Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<C> Clone for Propagate<C>where C: Clone + Component + PartialEq,
    - fn clone(&self) -> Propagate<C>
    - fn clone_from(&mut self, source: &Self)
  - impl<C> Component for Propagate<C>where C: Component + Clone + PartialEq, Propagate<C>: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Causes the inner component to be added to this entity and all direct and transient relationship targets. A target with a Propagate<C> component of its own will override propagation from that point in the tree.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Propagate<C>(pub C)
where
    C: Component + Clone + PartialEq;
```

---

## Trait AppGizmoBuilder Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/gizmos/trait.AppGizmoBuilder.html

**Contents:**
- Trait AppGizmoBuilder Copy item path
- Required Methods§
    - fn init_gizmo_group<Config>(&mut self) -> &mut Selfwhere Config: GizmoConfigGroup,
    - fn insert_gizmo_config<Config>( &mut self, group: Config, config: GizmoConfig, ) -> &mut Selfwhere Config: GizmoConfigGroup,
- Dyn Compatibility§
- Implementors§
  - impl AppGizmoBuilder for App

A extension trait adding App::init_gizmo_group and App::insert_gizmo_config.

Registers GizmoConfigGroup in the app enabling the use of Gizmos<Config>.

Configurations can be set using the GizmoConfigStore Resource.

Insert a GizmoConfig into a specific GizmoConfigGroup.

This method should be preferred over AppGizmoBuilder::init_gizmo_group if and only if you need to configure fields upon initialization.

This trait is not dyn compatible.

In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.

**Examples:**

Example 1 (unknown):
```unknown
pub trait AppGizmoBuilder {
    // Required methods
    fn init_gizmo_group<Config>(&mut self) -> &mut Self
       where Config: GizmoConfigGroup;
    fn insert_gizmo_config<Config>(
        &mut self,
        group: Config,
        config: GizmoConfig,
    ) -> &mut Self
       where Config: GizmoConfigGroup;
}
```

---

## Struct AnimatableCurveEvaluator Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.AnimatableCurveEvaluator.html

**Contents:**
- Struct AnimatableCurveEvaluator Copy item path
- Trait Implementations§
  - impl<A> AnimationCurveEvaluator for AnimatableCurveEvaluator<A>where A: Animatable,
    - fn blend( &mut self, graph_node: NodeIndex, ) -> Result<(), AnimationEvaluationError>
    - fn add(&mut self, graph_node: NodeIndex) -> Result<(), AnimationEvaluationError>
    - fn push_blend_register( &mut self, weight: f32, graph_node: NodeIndex, ) -> Result<(), AnimationEvaluationError>
    - fn commit( &mut self, entity: EntityMutExcept<'_, '_, (AnimationTarget, AnimationPlayer, AnimationGraphHandle)>, ) -> Result<(), AnimationEvaluationError>
  - impl<A> FromArg for AnimatableCurveEvaluator<A>where A: Animatable + TypePath, AnimatableCurveEvaluator<A>: Any + Send + Sync, BasicAnimationCurveEvaluator<A>: FromReflect + TypePath + MaybeTyped + RegisterForReflection, Box<dyn AnimatableProperty<Property = A>>: FromReflect + TypePath + MaybeTyped + RegisterForReflection,
    - type This<'from_arg> = AnimatableCurveEvaluator<A>
    - fn from_arg( arg: Arg<'_>, ) -> Result<<AnimatableCurveEvaluator<A> as FromArg>::This<'_>, ArgError>

An AnimatableCurveEvaluator for AnimatableProperty instances.

You shouldn’t ordinarily need to instantiate one of these manually. Bevy will automatically do so when you use an AnimatableCurve instance.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct AnimatableCurveEvaluator<A>where
    A: Animatable,{ /* private fields */ }
```

---

## Trait Material Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.Material.html

**Contents:**
- Trait Material Copy item path
- §Example
- Provided Methods§
    - fn vertex_shader() -> ShaderRef
    - fn fragment_shader() -> ShaderRef
    - fn alpha_mode(&self) -> AlphaMode
    - fn opaque_render_method(&self) -> OpaqueRendererMethod
    - fn depth_bias(&self) -> f32
    - fn reads_view_transmission_texture(&self) -> bool
    - fn prepass_vertex_shader() -> ShaderRef

Materials are used alongside MaterialPlugin, Mesh3d, and MeshMaterial3d to spawn entities that are rendered with a specific Material type. They serve as an easy to use high level way to render Mesh3d entities with custom shader logic.

Materials must implement AsBindGroup to define how data will be transferred to the GPU and bound in shaders. AsBindGroup can be derived, which makes generating bindings straightforward. See the AsBindGroup docs for details.

Here is a simple Material implementation. The AsBindGroup derive has many features. To see what else is available, check out the AsBindGroup documentation.

In WGSL shaders, the material’s binding would look like this:

Returns this material’s vertex shader. If ShaderRef::Default is returned, the default mesh vertex shader will be used.

Returns this material’s fragment shader. If ShaderRef::Default is returned, the default mesh fragment shader will be used.

Returns this material’s AlphaMode. Defaults to AlphaMode::Opaque.

Returns if this material should be rendered by the deferred or forward renderer. for AlphaMode::Opaque or AlphaMode::Mask materials. If OpaqueRendererMethod::Auto, it will default to what is selected in the DefaultOpaqueRendererMethod resource.

Add a bias to the view depth of the mesh which can be used to force a specific render order. for meshes with similar depth, to avoid z-fighting. The bias is in depth-texture units so large values may be needed to overcome small depth differences.

Returns whether the material would like to read from ViewTransmissionTexture.

This allows taking color output from the Opaque3d pass as an input, (for screen-space transmission) but requires rendering to take place in a separate Transmissive3d pass.

Returns this material’s prepass vertex shader. If ShaderRef::Default is returned, the default prepass vertex shader will be used.

This is used for the various prepasses as well as for generating the depth maps required for shadow mapping.

Returns this material’s prepass fragment shader. If ShaderRef::Default is returned, the default prepass fragment shader will be used.

This is used for the various prepasses as well as for generating the depth maps required for shadow mapping.

Returns this material’s deferred vertex shader. If ShaderRef::Default is returned, the default deferred vertex shader will be used.

Returns this material’s deferred fragment shader. If ShaderRef::Default is returned, the default deferred fragment shader will be used.

Return

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait Material:
    Sized
    + Asset
    + AsBindGroup
    + Clone {
Show 14 methods    // Provided methods
    fn vertex_shader() -> ShaderRef { ... }
    fn fragment_shader() -> ShaderRef { ... }
    fn alpha_mode(&self) -> AlphaMode { ... }
    fn opaque_render_method(&self) -> OpaqueRendererMethod { ... }
    fn depth_bias(&self) -> f32 { ... }
    fn reads_view_transmission_texture(&self) -> bool { ... }
    fn prepass_vertex_shader() -> ShaderRef { ... }
    fn prepass_fragment_shader() -> ShaderRef { ... }
    fn deferred_vertex_shader() -> ShaderRef { ... }
    fn deferred_fragmen
...
```

Example 2 (unknown):
```unknown
#[derive(AsBindGroup, Debug, Clone, Asset, TypePath)]
pub struct CustomMaterial {
    // Uniform bindings must implement `ShaderType`, which will be used to convert the value to
    // its shader-compatible equivalent. Most core math types already implement `ShaderType`.
    #[uniform(0)]
    color: LinearRgba,
    // Images can be bound as textures in shaders. If the Image's sampler is also needed, just
    // add the sampler attribute with a different binding index.
    #[texture(1)]
    #[sampler(2)]
    color_texture: Handle<Image>,
}

// All functions on `Material` have default impls. You
...
```

Example 3 (wgsl):
```wgsl
@group(#{MATERIAL_BIND_GROUP}) @binding(0) var<uniform> color: vec4<f32>;
@group(#{MATERIAL_BIND_GROUP}) @binding(1) var color_texture: texture_2d<f32>;
@group(#{MATERIAL_BIND_GROUP}) @binding(2) var color_sampler: sampler;
```

---

## Struct UnevenSampleCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.UnevenSampleCurve.html

**Contents:**
- Struct UnevenSampleCurve Copy item path
- Implementations§
  - impl<T, I> UnevenSampleCurve<T, I>
    - pub fn new( timed_samples: impl IntoIterator<Item = (f32, T)>, interpolation: I, ) -> Result<UnevenSampleCurve<T, I>, UnevenCoreError>where I: Fn(&T, &T, f32) -> T,
    - pub fn map_sample_times(self, f: impl Fn(f32) -> f32) -> UnevenSampleCurve<T, I>
- Trait Implementations§
  - impl<T, I> Clone for UnevenSampleCurve<T, I>where T: Clone, I: Clone,
    - fn clone(&self) -> UnevenSampleCurve<T, I>
    - fn clone_from(&mut self, source: &Self)
  - impl<T, I> Curve<T> for UnevenSampleCurve<T, I>where T: Clone, I: Fn(&T, &T, f32) -> T,

A curve that is defined by interpolation over unevenly spaced samples with explicit interpolation.

Create a new UnevenSampleCurve using the provided interpolation to interpolate between adjacent timed_samples. The given samples are filtered to finite times and sorted internally; if there are not at least 2 valid timed samples, an error will be returned.

The interpolation takes two values by reference together with a scalar parameter and produces an owned value. The expectation is that interpolation(&x, &y, 0.0) and interpolation(&x, &y, 1.0) are equivalent to x and y respectively.

This UnevenSampleAutoCurve, but with the sample times moved by the map f. In principle, when f is monotone, this is equivalent to CurveExt::reparametrize, but the function inputs to each are inverses of one another.

The samples are re-sorted by time after mapping and deduplicated by output time, so the function f should generally be injective over the sample times of the curve.

Note: This is not a fully stable implementation of TypePath due to usage of type_name for function members.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct UnevenSampleCurve<T, I> { /* private fields */ }
```

---

## Module derivatives Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derivatives/index.html

**Contents:**
- Module derivatives Copy item path
- Modules§
- Structs§
- Traits§

This module holds traits related to extracting derivatives from curves. In applications, the derivatives of interest are chiefly the first and second; in this module, these are provided by the traits CurveWithDerivative and CurveWithTwoDerivatives.

These take ownership of the curve they are used on by default, so that the resulting output may be used in more durable contexts. For example, CurveWithDerivative<T> is not dyn-compatible, but Curve<WithDerivative<T>> is, so if such a curve needs to be stored in a dynamic context, calling with_derivative and then placing the result in a Box<Curve<WithDerivative<T>>> is sensible.

On the other hand, in more transient contexts, consuming a value merely to sample derivatives is inconvenient, and in these cases, it is recommended to use by_ref when possible to create a referential curve first, retaining liveness of the original.

This module also holds the SampleDerivative and SampleTwoDerivatives traits, which can be used to easily implement CurveWithDerivative and its counterpart.

---

## Struct QuarticInCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.QuarticInCurve.html

**Contents:**
- Struct QuarticInCurve Copy item path
- Trait Implementations§
  - impl Clone for QuarticInCurve
    - fn clone(&self) -> QuarticInCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for QuarticInCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct QuarticInCurve;
```

---

## Struct Despawn Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Despawn.html

**Contents:**
- Struct Despawn Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Despawn
    - fn clone(&self) -> Despawn
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Despawn
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl EntityEvent for Despawnwhere Despawn: Send + Sync + 'static,
    - fn event_target(&self) -> Entity

EntityEvent emitted for each component on an entity when it is despawned. See ComponentHooks::on_despawn for more information.

The entity that held this component before it was despawned.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Despawn {
    pub entity: Entity,
}
```

---

## Struct Drag Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.Drag.html

**Contents:**
- Struct Drag Copy item path
- Fields§
- Trait Implementations§
  - impl Clone for Drag
    - fn clone(&self) -> Drag
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for Drag
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl FromArg for Drag
    - type This<'from_arg> = Drag

Fires while the target entity is being dragged.

Pointer button pressed and moved to trigger this event.

The total distance vector of a drag, measured from drag start to the current position.

This is stored in screen pixels, not world coordinates. Screen pixels go from top-left to bottom-right, whereas (in 2D) world coordinates go from bottom-left to top-right. Consider using methods on Camera to convert from screen-space to world-space.

The change in position since the last drag event.

This is stored in screen pixels, not world coordinates. Screen pixels go from top-left to bottom-right, whereas (in 2D) world coordinates go from bottom-left to top-right. Consider using methods on Camera to convert from screen-space to world-space.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Drag {
    pub button: PointerButton,
    pub distance: Vec2,
    pub delta: Vec2,
}
```

---

## Trait CurveExt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.CurveExt.html

**Contents:**
- Trait CurveExt Copy item path
- Provided Methods§
    - fn sample_iter( &self, iter: impl IntoIterator<Item = f32>, ) -> impl Iterator<Item = Option<T>>
    - fn sample_iter_unchecked( &self, iter: impl IntoIterator<Item = f32>, ) -> impl Iterator<Item = T>
    - fn sample_iter_clamped( &self, iter: impl IntoIterator<Item = f32>, ) -> impl Iterator<Item = T>
    - fn map<S, F>(self, f: F) -> MapCurve<T, S, Self, F>where F: Fn(T) -> S,
      - Examples found in repository?
    - fn reparametrize<F>(self, domain: Interval, f: F) -> ReparamCurve<T, Self, F>where F: Fn(f32) -> f32,
      - §Examples
    - fn reparametrize_linear( self, domain: Interval, ) -> Result<LinearReparamCurve<T, Self>, LinearReparamError>

Extension trait implemented by curves, allowing access to a number of adaptors and convenience methods.

This trait is automatically implemented for all curves that are Sized. In particular, it is implemented for types like Box<dyn Curve<T>>. CurveExt is not dyn-compatible itself.

For more information, see the module-level documentation.

Sample a collection of n >= 0 points on this curve at the parameter values t_n, returning None if the point is outside of the curve’s domain.

The samples are returned in the same order as the parameter values t_n were provided and will include all results. This leaves the responsibility for things like filtering and sorting to the user for maximum flexibility.

Sample a collection of n >= 0 points on this curve at the parameter values t_n, extracting the associated values. This is the unchecked version of sampling, which should only be used if the sample times t_n are already known to lie within the curve’s domain.

Values sampled from outside of a curve’s domain are generally considered invalid; data which is nonsensical or otherwise useless may be returned in such a circumstance, and extrapolation beyond a curve’s domain should not be relied upon.

The samples are returned in the same order as the parameter values t_n were provided and will include all results. This leaves the responsibility for things like filtering and sorting to the user for maximum flexibility.

Sample a collection of n >= 0 points on this curve at the parameter values t_n, clamping t_n to lie inside the domain of the curve.

The samples are returned in the same order as the parameter values t_n were provided and will include all results. This leaves the responsibility for things like filtering and sorting to the user for maximum flexibility.

Create a new curve by mapping the values of this curve via a function f; i.e., if the sample at time t for this curve is x, the value at time t on the new curve will be f(x).

Create a new Curve whose parameter space is related to the parameter space of this curve by f. For each time t, the sample from the new curve at time t is the sample from this curve at time f(t). The given domain will be the domain of the new curve. The function f is expected to take domain into self.domain().

Note that this is the opposite of what one might expect intuitively; for example, if this curve has a parameter domain of [0, 1], then stretching the parameter domain to [0, 2] would be performed as follows, dividing by what mig

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait CurveExt<T>: Sized + Curve<T> {
Show 18 methods    // Provided methods
    fn sample_iter(
        &self,
        iter: impl IntoIterator<Item = f32>,
    ) -> impl Iterator<Item = Option<T>> { ... }
    fn sample_iter_unchecked(
        &self,
        iter: impl IntoIterator<Item = f32>,
    ) -> impl Iterator<Item = T> { ... }
    fn sample_iter_clamped(
        &self,
        iter: impl IntoIterator<Item = f32>,
    ) -> impl Iterator<Item = T> { ... }
    fn map<S, F>(self, f: F) -> MapCurve<T, S, Self, F>
       where F: Fn(T) -> S { ... }
    fn reparametrize<F>(
        self,

...
```

Example 2 (javascript):
```javascript
124fn display_curves(
125    mut gizmos: Gizmos,
126    ease_functions: Query<(&EaseFunctionPlot, &Transform, &Children)>,
127    mut transforms: Query<&mut Transform, Without<EaseFunctionPlot>>,
128    mut ui_text: Single<&mut Text>,
129    time: Res<Time>,
130) {
131    let samples = 100;
132    let duration = 2.5;
133    let time_margin = 0.5;
134
135    let now = ((time.elapsed_secs() % (duration + time_margin * 2.0) - time_margin) / duration)
136        .clamp(0.0, 1.0);
137
138    ui_text.0 = format!("Progress: {now:.2}");
139
140    for (EaseFunctionPlot(function, color), transform, chi
...
```

Example 3 (javascript):
```javascript
let my_curve = ConstantCurve::new(Interval::UNIT, 1.0);
let scaled_curve = my_curve.reparametrize(interval(0.0, 2.0).unwrap(), |t| t / 2.0);
```

Example 4 (javascript):
```javascript
// Reverse a curve:
let my_curve = ConstantCurve::new(Interval::UNIT, 1.0);
let domain = my_curve.domain();
let reversed_curve = my_curve.reparametrize(domain, |t| domain.end() - (t - domain.start()));

// Take a segment of a curve:
let curve_segment = my_curve.reparametrize(interval(0.0, 0.5).unwrap(), |t| 0.5 + t);
```

---

## Struct PropagateStop Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.PropagateStop.html

**Contents:**
- Struct PropagateStop Copy item path
- Trait Implementations§
  - impl<C> Component for PropagateStop<C>where PropagateStop<C>: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior
    - fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_replace() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>

Stops the propagation at this entity. Children will not inherit the component.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct PropagateStop<C>(/* private fields */);
```

---

## Struct CubicCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.CubicCurve.html

**Contents:**
- Struct CubicCurve Copy item path
- Implementations§
  - impl<P> CubicCurve<P>where P: VectorSpace<Scalar = f32>,
    - pub fn from_segments( segments: impl IntoIterator<Item = CubicSegment<P>>, ) -> Option<CubicCurve<P>>
    - pub fn position(&self, t: f32) -> P
      - Examples found in repository?
    - pub fn velocity(&self, t: f32) -> P
    - pub fn acceleration(&self, t: f32) -> P
    - pub fn iter_samples<'a, 'b>( &'b self, subdivisions: usize, sample_function: impl FnMut(&CubicCurve<P>, f32) -> P + 'a, ) -> impl Iterator<Item = P> + 'awhere 'b: 'a,
    - pub fn segments(&self) -> &[CubicSegment<P>]

A collection of CubicSegments chained into a single parametric curve. It is a Curve with domain [0, N], where N is its number of segments.

Use any struct that implements the CubicGenerator trait to create a new curve, such as CubicBezier.

Create a new curve from a collection of segments. If the collection of segments is empty, a curve cannot be built and None will be returned instead.

Compute the position of a point on the cubic curve at the parametric value t.

Note that t varies from 0..=(n_points - 3).

Compute the first derivative with respect to t at t. This is the instantaneous velocity of a point on the cubic curve at t.

Note that t varies from 0..=(n_points - 3).

Compute the second derivative with respect to t at t. This is the instantaneous acceleration of a point on the cubic curve at t.

Note that t varies from 0..=(n_points - 3).

A flexible iterator used to sample curves with arbitrary functions.

This splits the curve into subdivisions of evenly spaced t values across the length of the curve from start (t = 0) to end (t = n), where n = self.segment_count(), returning an iterator evaluating the curve with the supplied sample_function at each t.

For subdivisions = 2, this will split the curve into two lines, or three points, and return an iterator with 3 items, the three points, one at the start, middle, and end.

The list of segments contained in this CubicCurve.

This spline’s global t value is equal to how many segments it has.

All method accepting t on CubicCurve depends on the global t. When sampling over the entire curve, you should either use one of the iter_* methods or account for the segment count using curve.segments().len().

Iterate over the curve split into subdivisions, sampling the position at each step.

Iterate over the curve split into subdivisions, sampling the velocity at each step.

Iterate over the curve split into subdivisions, sampling the acceleration at each step.

Adds a segment to the curve

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct CubicCurve<P>where
    P: VectorSpace,{ /* private fields */ }
```

Example 2 (javascript):
```javascript
89fn animate_curve<T: CurveColor>(
90    time: Res<Time>,
91    mut query: Query<(&mut Transform, &mut Sprite, &Curve<T>)>,
92) {
93    let t = (ops::sin(time.elapsed_secs()) + 1.) / 2.;
94
95    for (mut transform, mut sprite, cubic_curve) in &mut query {
96        // position takes a point from the curve where 0 is the initial point
97        // and 1 is the last point
98        sprite.color = cubic_curve.0.position(t).into();
99        transform.translation.x = 600. * (t - 0.5);
100    }
101}
```

Example 3 (javascript):
```javascript
169fn draw_curve(curve: Res<Curve>, mut gizmos: Gizmos) {
170    let Some(ref curve) = curve.0 else {
171        return;
172    };
173    // Scale resolution with curve length so it doesn't degrade as the length increases.
174    let resolution = 100 * curve.segments().len();
175    gizmos.linestrip(
176        curve.iter_positions(resolution).map(|pt| pt.extend(0.0)),
177        Color::srgb(1.0, 1.0, 1.0),
178    );
179}
```

Example 4 (javascript):
```javascript
169fn draw_curve(curve: Res<Curve>, mut gizmos: Gizmos) {
170    let Some(ref curve) = curve.0 else {
171        return;
172    };
173    // Scale resolution with curve length so it doesn't degrade as the length increases.
174    let resolution = 100 * curve.segments().len();
175    gizmos.linestrip(
176        curve.iter_positions(resolution).map(|pt| pt.extend(0.0)),
177        Color::srgb(1.0, 1.0, 1.0),
178    );
179}
```

---

## Struct BackOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BackOutCurve.html

**Contents:**
- Struct BackOutCurve Copy item path
- Trait Implementations§
  - impl Clone for BackOutCurve
    - fn clone(&self) -> BackOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for BackOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

f(t) = 1.0 + 2.70158 * (t - 1.0)³ - 1.70158 * (t - 1.0)²

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BackOutCurve;
```

---

## Trait AnimationCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AnimationCurve.html

**Contents:**
- Trait AnimationCurve Copy item path
- Required Methods§
    - fn clone_value(&self) -> Box<dyn AnimationCurve>
    - fn domain(&self) -> Interval
    - fn evaluator_id(&self) -> EvaluatorId<'_>
    - fn create_evaluator(&self) -> Box<dyn AnimationCurveEvaluator>
    - fn apply( &self, curve_evaluator: &mut (dyn AnimationCurveEvaluator + 'static), t: f32, weight: f32, graph_node: NodeIndex, ) -> Result<(), AnimationEvaluationError>
- Implementors§
  - impl<C> AnimationCurve for WeightsCurve<C>where C: IterableCurve<f32> + Debug + Clone + Reflectable,
  - impl<P, C> AnimationCurve for AnimatableCurve<P, C>where P: Send + Sync + 'static + AnimatableProperty + Clone, C: AnimationCompatibleCurve<<P as AnimatableProperty>::Property> + Clone,

A low-level trait that provides control over how curves are actually applied to entities by the animation system.

Typically, this will not need to be implemented manually, since it is automatically implemented by AnimatableCurve and other curves used by the animation system (e.g. those that animate parts of transforms or morph weights). However, this can be implemented manually when AnimatableCurve is not sufficiently expressive.

In many respects, this behaves like a type-erased form of Curve, where the output type of the curve is remembered only in the components that are mutated in the implementation of apply.

Returns a boxed clone of this value.

The range of times for which this animation is defined.

Returns the type ID of the AnimationCurveEvaluator.

This must match the type returned by Self::create_evaluator. It must be a single type that doesn’t depend on the type of the curve.

Returns a newly-instantiated AnimationCurveEvaluator for use with this curve.

All curve types must return the same type of AnimationCurveEvaluator. The returned value must match the type returned by Self::evaluator_id.

Samples the curve at the given time t, and pushes the sampled value onto the evaluation stack of the curve_evaluator.

The curve_evaluator parameter points to the value returned by Self::create_evaluator, upcast to an &mut dyn AnimationCurveEvaluator. Typically, implementations of Self::apply will want to downcast the curve_evaluator parameter to the concrete type Self::evaluator_id in order to push values of the appropriate type onto its evaluation stack.

Be sure not to confuse the t and weight values. The former determines the position at which the curve is sampled, while weight ultimately determines how much the stack values will be blended together (see the definition of AnimationCurveEvaluator::blend).

**Examples:**

Example 1 (unknown):
```unknown
pub trait AnimationCurve:
    Debug
    + Send
    + Sync
    + 'static {
    // Required methods
    fn clone_value(&self) -> Box<dyn AnimationCurve>;
    fn domain(&self) -> Interval;
    fn evaluator_id(&self) -> EvaluatorId<'_>;
    fn create_evaluator(&self) -> Box<dyn AnimationCurveEvaluator>;
    fn apply(
        &self,
        curve_evaluator: &mut (dyn AnimationCurveEvaluator + 'static),
        t: f32,
        weight: f32,
        graph_node: NodeIndex,
    ) -> Result<(), AnimationEvaluationError>;
}
```

---

## Derive Macro Bundle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/derive.Bundle.html

**Contents:**
- Derive Macro Bundle Copy item path

Implement the Bundle trait.

**Examples:**

Example 1 (unknown):
```unknown
#[derive(Bundle)]
{
    // Attributes available to this derive:
    #[bundle]
}
```

---

## Macro error_once Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/macro.error_once.html

**Contents:**
- Macro error_once Copy item path

Call error! once per call site.

Useful for logging within systems which are called every frame.

**Examples:**

Example 1 (javascript):
```javascript
macro_rules! error_once {
    ($($arg:tt)+) => { ... };
}
```

---

## Struct BVec4A Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BVec4A.html

**Contents:**
- Struct BVec4A Copy item path
- Implementations§
  - impl BVec4A
    - pub const FALSE: BVec4A
    - pub const TRUE: BVec4A
    - pub const fn new(x: bool, y: bool, z: bool, w: bool) -> BVec4A
    - pub const fn splat(v: bool) -> BVec4A
    - pub const fn from_array(a: [bool; 4]) -> BVec4A
    - pub fn bitmask(self) -> u32
    - pub fn any(self) -> bool

A 4-dimensional SIMD vector mask.

This type is 16 byte aligned.

Creates a new vector mask.

Creates a vector mask with all elements set to v.

Creates a new vector mask from a bool array.

Returns a bitmask with the lowest 4 bits set from the elements of self.

A true element results in a 1 bit and a false element in a 0 bit. Element x goes into the first lowest bit, element y into the second, etc.

Returns true if any of the elements are true, false otherwise.

Returns true if all the elements are true, false otherwise.

Tests the value at index.

Panics if index is greater than 3.

Sets the element at index.

Panics if index is greater than 3.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BVec4A(/* private fields */);
```

---

## Struct App Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.App.html

**Contents:**
- Struct App Copy item path
- §Examples
- Implementations§
  - impl App
    - pub fn new() -> App
      - Examples found in repository?
    - pub fn empty() -> App
    - pub fn update(&mut self)
      - Examples found in repository?
    - pub fn run(&mut self) -> AppExit

App is the primary API for writing user applications. It automates the setup of a standard lifecycle and provides interface glue for plugins.

A single App can contain multiple SubApp instances, but App methods only affect the “main” one. To access a particular SubApp, use get_sub_app or get_sub_app_mut.

Here is a simple “Hello World” Bevy app:

Creates a new App with some default structure to enable core engine features. This is the preferred constructor for most use cases.

Creates a new empty App with minimal default configuration.

Use this constructor if you want to customize scheduling, exit handling, cleanup, etc.

Runs the default schedules of all sub-apps (starting with the “main” app) once.

Runs the App by calling its runner.

This will (re)build the App first. For general usage, see the example on the item level documentation.

Calls to App::run() will never return on iOS and Web.

Headless apps can generally expect this method to return control to the caller when it completes, but that is not the case for windowed apps. Windowed apps are typically driven by an event loop and some platforms expect the program to terminate when the event loop ends.

By default, Bevy uses the winit crate for window creation.

Panics if not all plugins have been built.

Sets the function that will be called when the app is run.

The runner function f is called only once by App::run. If the presence of a main loop in the app is desired, it is the responsibility of the runner function to provide it.

The runner function is usually not set manually, but by Bevy integrated plugins (e.g. WinitPlugin).

Returns the state of all plugins. This is usually called by the event loop, but can be useful for situations where you want to use App::update.

Runs Plugin::finish for each plugin. This is usually called by the event loop once all plugins are ready, but can be useful for situations where you want to use App::update.

Runs Plugin::cleanup for each plugin. This is usually called by the event loop after App::finish, but can be useful for situations where you want to use App::update.

Adds one or more systems to the given schedule in this app’s Schedules.

Registers a system and returns a SystemId so it can later be called by World::run_system.

It’s possible to register the same systems more than once, they’ll be stored separately.

This is different from adding systems to a Schedule with App::add_systems, because the SystemId that is returned can be used anywhere in the 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub struct App { /* private fields */ }
```

Example 2 (unknown):
```unknown
fn main() {
   App::new()
       .add_systems(Update, hello_world_system)
       .run();
}

fn hello_world_system() {
   println!("hello world");
}
```

Example 3 (unknown):
```unknown
5fn main() {
6    App::new().run();
7}
```

Example 4 (unknown):
```unknown
5fn main() {
6    App::new().add_plugins(DefaultPlugins).run();
7}
```

---

## Enum GizmoLineStyle Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.GizmoLineStyle.html

**Contents:**
- Enum GizmoLineStyle Copy item path
- Variants (Non-exhaustive)§
  - Solid
  - Dotted
  - Dashed
    - Fields
- Trait Implementations§
  - impl Clone for GizmoLineStyle
    - fn clone(&self) -> GizmoLineStyle
    - fn clone_from(&mut self, source: &Self)

An enum used to configure the style of gizmo lines, similar to CSS line-style

A solid line without any decorators

A dashed line with configurable gap and line sizes

The length of the gap in line_widths

The length of the visible line in line_widths

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
#[non_exhaustive]pub enum GizmoLineStyle {
    Solid,
    Dotted,
    Dashed {
        gap_scale: f32,
        line_scale: f32,
    },
}
```

---

## Enum ConvexPolygonError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.ConvexPolygonError.html

**Contents:**
- Enum ConvexPolygonError Copy item path
- Variants§
  - Concave
- Trait Implementations§
  - impl Clone for ConvexPolygonError
    - fn clone(&self) -> ConvexPolygonError
    - fn clone_from(&mut self, source: &Self)
  - impl Debug for ConvexPolygonError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for ConvexPolygonError

An error that happens when creating a ConvexPolygon.

The created polygon is not convex.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum ConvexPolygonError {
    Concave,
}
```

---

## Enum JustifySelf Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.JustifySelf.html

**Contents:**
- Enum JustifySelf Copy item path
- Variants§
  - Auto
  - Start
  - End
  - Center
  - Baseline
  - Stretch
- Implementations§
  - impl JustifySelf

Used to control how the specified item is aligned within the space it’s given.

https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self

Use the parent node’s JustifyItems value to determine how this item should be aligned.

This item will be aligned with the start of the axis.

This item will be aligned with the end of the axis.

This item will be aligned along the center of the axis.

This item will be aligned at the baseline.

This item will be stretched to fill the space it’s given.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum JustifySelf {
    Auto,
    Start,
    End,
    Center,
    Baseline,
    Stretch,
}
```

---

## Enum PingPongError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.PingPongError.html

**Contents:**
- Enum PingPongError Copy item path
- Variants§
  - SourceDomainEndInfinite
- Trait Implementations§
  - impl Debug for PingPongError
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl Display for PingPongError
    - fn fmt(&self, __formatter: &mut Formatter<'_>) -> Result<(), Error>
  - impl Error for PingPongError
    - fn source(&self) -> Option<&(dyn Error + 'static)>

An error indicating that a ping ponging of a curve couldn’t be performed because of malformed inputs.

The source curve that was to be ping ponged had unbounded domain end.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum PingPongError {
    SourceDomainEndInfinite,
}
```

---

## Enum JumpAt Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.JumpAt.html

**Contents:**
- Enum JumpAt Copy item path
- Variants§
  - Start
  - End
  - None
  - Both
- Trait Implementations§
  - impl Clone for JumpAt
    - fn clone(&self) -> JumpAt
    - fn clone_from(&mut self, source: &Self)

Configuration options for the EaseFunction::Steps curves. This closely replicates the CSS step function specification.

Indicates that the first step happens when the animation begins.

Indicates that the last step happens when the animation ends.

Indicates neither early nor late jumps happen.

Indicates both early and late jumps happen.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum JumpAt {
    Start,
    End,
    None,
    Both,
}
```

---

## Struct ElasticInOutCurve Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ElasticInOutCurve.html

**Contents:**
- Struct ElasticInOutCurve Copy item path
- Trait Implementations§
  - impl Clone for ElasticInOutCurve
    - fn clone(&self) -> ElasticInOutCurve
    - fn clone_from(&mut self, source: &Self)
  - impl Curve<f32> for ElasticInOutCurve
    - fn domain(&self) -> Interval
    - fn sample_unchecked(&self, t: f32) -> f32
    - fn sample(&self, t: f32) -> Option<T>
    - fn sample_clamped(&self, t: f32) -> T

Behaves as ElasticIn for t < 0.5 and as ElasticOut for t >= 0.5

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ElasticInOutCurve;
```

---

## Function update_stopped Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/fn.update_stopped.html

**Contents:**
- Function update_stopped Copy item path

remove Inherited::<C> and C for entities with a PropagateStop::<C>

**Examples:**

Example 1 (unknown):
```unknown
pub fn update_stopped<C, F>(
    commands: Commands<'_, '_>,
    q: Query<'_, '_, Entity, (With<Inherited<C>>, With<PropagateStop<C>>, F)>,
)where
    C: Component + Clone + PartialEq,
    F: QueryFilter,
```

---

## Struct OnEnter Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.OnEnter.html

**Contents:**
- Struct OnEnter Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<S> Clone for OnEnter<S>where S: Clone + States,
    - fn clone(&self) -> OnEnter<S>
    - fn clone_from(&mut self, source: &Self)
  - impl<S> Debug for OnEnter<S>where S: Debug + States,
    - fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>
  - impl<S> Default for OnEnter<S>where S: Default + States,
    - fn default() -> OnEnter<S>

The label of a Schedule that only runs whenever State<S> enters the provided state.

This schedule ignores identity transitions.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct OnEnter<S>(pub S)
where
    S: States;
```

---

## Struct FilteredResourcesMut Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.FilteredResourcesMut.html

**Contents:**
- Struct FilteredResourcesMut Copy item path
- §Examples
- Implementations§
  - impl<'w, 's> FilteredResourcesMut<'w, 's>
    - pub fn as_readonly(&self) -> FilteredResources<'_, 's>
    - pub fn reborrow(&mut self) -> FilteredResourcesMut<'_, 's>
    - pub fn access(&self) -> &Access
    - pub fn has_read<R>(&self) -> boolwhere R: Resource,
    - pub fn has_write<R>(&self) -> boolwhere R: Resource,
    - pub fn get<R>(&self) -> Result<Ref<'_, R>, ResourceFetchError>where R: Resource,

Provides mutable access to a set of Resources defined by the contained Access.

Use FilteredResources if you only need read-only access to resources.

To be useful as a SystemParam, this must be configured using a FilteredResourcesMutParamBuilder to build the system using a SystemParamBuilder.

This can be used alongside ordinary Res and ResMut parameters if they do not conflict.

But it will conflict if it tries to read the same resource that another parameter writes, or write the same resource that another parameter reads.

Gets read-only access to all of the resources this FilteredResourcesMut can access.

Returns a new instance with a shorter lifetime. This is useful if you have &mut FilteredResourcesMut, but you need FilteredResourcesMut.

Returns a reference to the underlying Access.

Returns true if the FilteredResources has read access to the given resource. Note that Self::get() may still return Err if the resource does not exist.

Returns true if the FilteredResources has write access to the given resource. Note that Self::get_mut() may still return Err if the resource does not exist.

Gets a reference to the resource of the given type if it exists and the FilteredResources has access to it.

Gets a pointer to the resource with the given ComponentId if it exists and the FilteredResources has access to it.

Gets a mutable reference to the resource of the given type if it exists and the FilteredResources has access to it.

Gets a mutable pointer to the resource with the given ComponentId if it exists and the FilteredResources has access to it.

Consumes self and gets mutable access to resource of the given type with the world 'w lifetime if it exists and the FilteredResources has access to it.

Consumes self and gets mutable access to resource with the given ComponentId with the world 'w lifetime if it exists and the FilteredResources has access to it.

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct FilteredResourcesMut<'w, 's> { /* private fields */ }
```

Example 2 (javascript):
```javascript
// Use `FilteredResourcesMutParamBuilder` to declare access to resources.
let system = (FilteredResourcesMutParamBuilder::new(|builder| {
    builder.add_write::<B>().add_read::<C>().add_write::<D>();
}),)
    .build_state(&mut world)
    .build_system(resource_system);

world.init_resource::<A>();
world.init_resource::<C>();
world.init_resource::<D>();

fn resource_system(mut res: FilteredResourcesMut) {
    // The resource exists, but we have no access, so we can't read it or write it.
    assert!(res.get::<A>().is_err());
    assert!(res.get_mut::<A>().is_err());
    // The resource doesn't
...
```

Example 3 (javascript):
```javascript
let system = (
    FilteredResourcesMutParamBuilder::new(|builder| {
        builder.add_read::<A>().add_write::<B>();
    }),
    ParamBuilder,
    ParamBuilder,
)
    .build_state(&mut world)
    .build_system(resource_system);

// Read access to A does not conflict with read access to A or write access to C.
// Write access to B does not conflict with access to A or C.
fn resource_system(mut filtered: FilteredResourcesMut, res_a: Res<A>, res_mut_c: ResMut<C>) {
    let res_a_2: Ref<A> = filtered.get::<A>().unwrap();
    let res_mut_b: Mut<B> = filtered.get_mut::<B>().unwrap();
}
```

Example 4 (javascript):
```javascript
let system = (
    FilteredResourcesMutParamBuilder::new(|builder| {
        builder.add_write::<A>();
    }),
    ParamBuilder,
)
    .build_state(&mut world)
    .build_system(invalid_resource_system);

// Read access to A conflicts with write access to A.
fn invalid_resource_system(filtered: FilteredResourcesMut, res_a: Res<A>) { }
```

---

## Struct BorderColor Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.BorderColor.html

**Contents:**
- Struct BorderColor Copy item path
- Fields§
- Implementations§
  - impl BorderColor
    - pub const DEFAULT: BorderColor
    - pub fn all(color: impl Into<Color>) -> BorderColor
      - Examples found in repository?
    - pub fn set_all(&mut self, color: impl Into<Color>) -> &mut BorderColor
      - Examples found in repository?
    - pub fn is_fully_transparent(&self) -> bool

The border color of the UI node.

Border color is transparent by default.

Helper to create a BorderColor struct with all borders set to the given color

Helper to set all border colors to a given color.

Check if all contained border colors are transparent

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct BorderColor {
    pub top: Color,
    pub right: Color,
    pub bottom: Color,
    pub left: Color,
}
```

Example 2 (unknown):
```unknown
72fn create_button() -> impl Bundle {
73    (
74        Button,
75        Node {
76            width: px(150),
77            height: px(65),
78            border: UiRect::all(px(5)),
79            // horizontally center child text
80            justify_content: JustifyContent::Center,
81            // vertically center child text
82            align_items: AlignItems::Center,
83            ..default()
84        },
85        BorderColor::all(Color::BLACK),
86        BorderRadius::MAX,
87        BackgroundColor(Color::srgb(0.15, 0.15, 0.15)),
88    )
89}
```

Example 3 (unknown):
```unknown
127    fn rotate_button(caption: &str, direction: Direction) -> impl Bundle {
128        (
129            RotateCamera(direction),
130            Button,
131            Node {
132                width: px(40),
133                height: px(40),
134                border: UiRect::all(px(2)),
135                justify_content: JustifyContent::Center,
136                align_items: AlignItems::Center,
137                ..default()
138            },
139            BorderColor::all(Color::WHITE),
140            BackgroundColor(Color::srgb(0.25, 0.25, 0.25)),
141            children![Text::new(ca
...
```

Example 4 (unknown):
```unknown
353fn highlight_focused_element(
354    input_focus: Res<InputFocus>,
355    // While this isn't strictly needed for the example,
356    // we're demonstrating how to be a good citizen by respecting the `InputFocusVisible` resource.
357    input_focus_visible: Res<InputFocusVisible>,
358    mut query: Query<(Entity, &mut BorderColor)>,
359) {
360    for (entity, mut border_color) in query.iter_mut() {
361        if input_focus.0 == Some(entity) && input_focus_visible.0 {
362            // Don't change the border size / radius here,
363            // as it would result in wiggling buttons when 
...
```

---

## Struct ShowLightGizmo Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.ShowLightGizmo.html

**Contents:**
- Struct ShowLightGizmo Copy item path
- Fields§
- Trait Implementations§
  - impl Component for ShowLightGizmowhere ShowLightGizmo: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )
    - fn clone_behavior() -> ComponentCloneBehavior
    - fn on_add() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>
    - fn on_insert() -> Option<for<'w> fn(DeferredWorld<'w>, HookContext)>

Add this Component to an entity to draw any of its lights components (PointLight, SpotLight and DirectionalLight).

Default color strategy for this light gizmo. if None, use the one provided by LightGizmoConfigGroup.

Returns the argument unchanged.

Creates Self using default().

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct ShowLightGizmo {
    pub color: Option<LightGizmoColor>,
}
```

---

## Struct Inherited Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/app/struct.Inherited.html

**Contents:**
- Struct Inherited Copy item path
- Tuple Fields§
- Trait Implementations§
  - impl<C> Clone for Inherited<C>where C: Clone + Component + PartialEq,
    - fn clone(&self) -> Inherited<C>
    - fn clone_from(&mut self, source: &Self)
  - impl<C> Component for Inherited<C>where C: Component + Clone + PartialEq, Inherited<C>: Send + Sync + 'static,
    - const STORAGE_TYPE: StorageType = bevy_ecs::component::StorageType::Table
    - type Mutability = Mutable
    - fn register_required_components( _requiree: ComponentId, required_components: &mut RequiredComponentsRegistrator<'_, '_>, )

Internal struct for managing propagation

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub struct Inherited<C>(pub C)
where
    C: Component + Clone + PartialEq;
```

---

## Trait AudioSinkPlayback Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/trait.AudioSinkPlayback.html

**Contents:**
- Trait AudioSinkPlayback Copy item path
- Required Methods§
    - fn volume(&self) -> Volume
    - fn set_volume(&mut self, volume: Volume)
    - fn speed(&self) -> f32
    - fn set_speed(&self, speed: f32)
    - fn play(&self)
    - fn position(&self) -> Duration
    - fn try_seek(&self, pos: Duration) -> Result<(), SeekError>
      - §Errors

Common interactions with an audio sink.

Gets the volume of the sound as a Volume.

If the sink is muted, this returns the managed volume rather than the sink’s actual volume. This allows you to use the returned volume as if the sink were not muted, because a muted sink has a physical volume of 0.

Changes the volume of the sound to the given Volume.

If the sink is muted, changing the volume won’t unmute it, i.e. the sink’s volume will remain “off” / “muted”. However, the sink will remember the volume change and it will be used when unmute is called. This allows you to control the volume even when the sink is muted.

Gets the speed of the sound.

The value 1.0 is the “normal” speed (unfiltered input). Any value other than 1.0 will change the play speed of the sound.

Changes the speed of the sound.

The value 1.0 is the “normal” speed (unfiltered input). Any value other than 1.0 will change the play speed of the sound.

Resumes playback of a paused sink.

No effect if not paused.

Returns the position of the sound that’s being played.

This takes into account any speedup or delay applied.

Example: if you set_speed(2.0) and position() returns 5s, then the position in the recording is 10s from its start.

Attempts to seek to a given position in the current source.

This blocks between 0 and ~5 milliseconds.

As long as the duration of the source is known, seek is guaranteed to saturate at the end of the source. For example given a source that reports a total duration of 42 seconds calling try_seek() with 60 seconds as argument will seek to 42 seconds.

This function will return SeekError::NotSupported if one of the underlying sources does not support seeking.

It will return an error if an implementation ran into one during the seek.

When seeking beyond the end of a source, this function might return an error if the duration of the source is not known.

Pauses playback of this sink.

No effect if already paused. A paused sink can be resumed with play.

Returns true if the sink is paused.

Sinks can be paused and resumed using pause and play.

It won’t be possible to restart it afterwards.

Returns true if this sink has no more sounds to play.

Returns true if the sink is muted.

Muting a sink sets the volume to 0. Use unmute to unmute the sink and restore the original volume.

Restores the volume to the value it was before it was muted.

Toggles playback of the sink.

If the sink is paused, toggling playback resumes it. If the sink is playing, toggling pl

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
pub trait AudioSinkPlayback {
Show 16 methods    // Required methods
    fn volume(&self) -> Volume;
    fn set_volume(&mut self, volume: Volume);
    fn speed(&self) -> f32;
    fn set_speed(&self, speed: f32);
    fn play(&self);
    fn position(&self) -> Duration;
    fn try_seek(&self, pos: Duration) -> Result<(), SeekError>;
    fn pause(&self);
    fn is_paused(&self) -> bool;
    fn stop(&self);
    fn empty(&self) -> bool;
    fn is_muted(&self) -> bool;
    fn mute(&mut self);
    fn unmute(&mut self);

    // Provided methods
    fn toggle_playback(&self) { ... }
    fn toggle_mute(&
...
```

Example 2 (javascript):
```javascript
72fn pause(
73    keyboard_input: Res<ButtonInput<KeyCode>>,
74    music_controller: Query<&AudioSink, With<MyMusic>>,
75) {
76    let Ok(sink) = music_controller.single() else {
77        return;
78    };
79
80    if keyboard_input.just_pressed(KeyCode::Space) {
81        sink.toggle_playback();
82    }
83}
```

Example 3 (unknown):
```unknown
133fn mute(keyboard_input: Res<ButtonInput<KeyCode>>, mut sinks: Query<&mut SpatialAudioSink>) {
134    if keyboard_input.just_pressed(KeyCode::KeyM) {
135        for mut sink in sinks.iter_mut() {
136            sink.toggle_mute();
137        }
138    }
139}
```

Example 4 (javascript):
```javascript
85fn mute(
86    keyboard_input: Res<ButtonInput<KeyCode>>,
87    mut music_controller: Query<&mut AudioSink, With<MyMusic>>,
88) {
89    let Ok(mut sink) = music_controller.single_mut() else {
90        return;
91    };
92
93    if keyboard_input.just_pressed(KeyCode::KeyM) {
94        sink.toggle_mute();
95    }
96}
```

---

## Function default Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/fn.default.html

**Contents:**
- Function default Copy item path
      - Examples found in repository?

An ergonomic abbreviation for Default::default() to make initializing structs easier.

This is especially helpful when combined with “struct update syntax”.

**Examples:**

Example 1 (unknown):
```unknown
pub fn default<T>() -> Twhere
    T: Default,
```

Example 2 (javascript):
```javascript
use bevy_utils::default;

#[derive(Default)]
struct Foo {
  a: usize,
  b: usize,
  c: usize,
}

// Normally you would initialize a struct with defaults using "struct update syntax"
// combined with `Default::default()`. This example sets `Foo::a` to 10 and the remaining
// values to their defaults.
let foo = Foo {
  a: 10,
  ..Default::default()
};

// But now you can do this, which is equivalent:
let foo = Foo {
  a: 10,
  ..default()
};
```

Example 3 (javascript):
```javascript
72    fn default() -> Self {
73        Self::Global(default())
74    }
75}
76
77/// Buttons consist of three parts: the button itself, a label child, and a
78/// value child. This specifies one of the three entities.
79#[derive(Clone, Copy, PartialEq, Component)]
80enum ColorGradingOptionWidgetType {
81    /// The parent button.
82    Button,
83    /// The label of the button.
84    Label,
85    /// The numerical value that the button displays.
86    Value,
87}
88
89#[derive(Clone, Copy, Component)]
90struct ColorGradingOptionWidget {
91    widget_type: ColorGradingOptionWidgetType,
92    opti
...
```

Example 4 (unknown):
```unknown
91    fn new(quantize_steps: u32) -> Self {
92        Self {
93            quantize_steps,
94            ..default()
95        }
96    }
```

---

## Struct IVec3 Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/struct.IVec3.html

**Contents:**
- Struct IVec3 Copy item path
- Fields§
- Implementations§
  - impl IVec3
    - pub const ZERO: IVec3
    - pub const ONE: IVec3
    - pub const NEG_ONE: IVec3
    - pub const MIN: IVec3
    - pub const MAX: IVec3
    - pub const X: IVec3

A 3-dimensional vector.

A unit vector pointing along the positive X axis.

A unit vector pointing along the positive Y axis.

A unit vector pointing along the positive Z axis.

A unit vector pointing along the negative X axis.

A unit vector pointing along the negative Y axis.

A unit vector pointing along the negative Z axis.

Creates a new vector.

Creates a vector with all elements set to v.

Returns a vector containing each element of self modified by a mapping function f.

Creates a vector from the elements in if_true and if_false, selecting which to use for each element of self.

A true element in the mask uses the corresponding element from if_true, and false uses the element from if_false.

Creates a new vector from an array.

Converts self to [x, y, z]

Creates a vector from the first 3 values in slice.

Panics if slice is less than 3 elements long.

Writes the elements of self to the first 3 elements in slice.

Panics if slice is less than 3 elements long.

Creates a 4D vector from self and the given w value.

Creates a 2D vector from the x and y elements of self, discarding z.

Truncation may also be performed by using self.xy().

Creates a 3D vector from self with the given value of x.

Creates a 3D vector from self with the given value of y.

Creates a 3D vector from self with the given value of z.

Computes the dot product of self and rhs.

Returns a vector where every component is the dot product of self and rhs.

Computes the cross product of self and rhs.

Returns a vector containing the minimum values for each element of self and rhs.

In other words this computes [min(x, rhs.x), min(self.y, rhs.y), ..].

Returns a vector containing the maximum values for each element of self and rhs.

In other words this computes [max(self.x, rhs.x), max(self.y, rhs.y), ..].

Component-wise clamping of values, similar to i32::clamp.

Each element in min must be less-or-equal to the corresponding element in max.

Will panic if min is greater than max when glam_assert is enabled.

Returns the horizontal minimum of self.

In other words this computes min(x, y, ..).

Returns the horizontal maximum of self.

In other words this computes max(x, y, ..).

Returns the index of the first minimum element of self.

Returns the index of the first maximum element of self.

Returns the sum of all elements of self.

In other words, this computes self.x + self.y + ...

Returns the product of all elements of self.

In other words, this computes self.x * self.y * ...

Ret

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
#[repr(C)]pub struct IVec3 {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
```

---

## Enum CubicNurbsError Copy item path

**URL:** https://docs.rs/bevy/0.17.2/bevy/prelude/enum.CubicNurbsError.html

**Contents:**
- Enum CubicNurbsError Copy item path
- Variants§
  - KnotsNumberMismatch
    - Fields
  - DescendingKnots
  - ConstantKnots
  - WeightsNumberMismatch
    - Fields
  - NotEnoughControlPoints
    - Fields

Error during construction of CubicNurbs

Provided the wrong number of knots.

Expected number of knots

Provided number of knots

The provided knots had a descending knot pair. Subsequent knots must either increase or stay the same.

The provided knots were all equal. Knots must contain at least one increasing pair.

Provided a different number of weights and control points.

Expected number of weights

Provided number of weights

The number of control points provided is less than 4.

The number of control points provided

Returns the argument unchanged.

That is, this conversion is whatever the implementation of From<T> for U chooses to do.

**Examples:**

Example 1 (unknown):
```unknown
pub enum CubicNurbsError {
    KnotsNumberMismatch {
        expected: usize,
        provided: usize,
    },
    DescendingKnots,
    ConstantKnots,
    WeightsNumberMismatch {
        expected: usize,
        provided: usize,
    },
    NotEnoughControlPoints {
        provided: usize,
    },
}
```

---
